<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="TypeScript"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>TypeScript | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E9%A1%B9"><span class="toc-number">2.</span> <span class="toc-text"> 选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text"> 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text"> 具体类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.2.1.</span> <span class="toc-text"> 数组接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 字面值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 元组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.5.</span> <span class="toc-text"> never类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.6.</span> <span class="toc-text"> void类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unknown%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.7.</span> <span class="toc-text"> unknown类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.8.</span> <span class="toc-text"> 函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call"><span class="toc-number">3.1.8.1.</span> <span class="toc-text"> [[Call]]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#construct"><span class="toc-number">3.1.8.2.</span> <span class="toc-text"> [[Construct]]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text"> 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 并类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 交类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.2.4.</span> <span class="toc-text"> 类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D"><span class="toc-number">3.2.5.</span> <span class="toc-text"> 类型谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keyof"><span class="toc-number">3.2.6.</span> <span class="toc-text"> keyof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">3.2.7.</span> <span class="toc-text"> typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.8.</span> <span class="toc-text"> 索引类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.9.</span> <span class="toc-text"> 条件运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in"><span class="toc-number">3.2.10.</span> <span class="toc-text"> in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.11.</span> <span class="toc-text"> 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.11.1.</span> <span class="toc-text"> 函数定义泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.11.2.</span> <span class="toc-text"> 函数类型泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.11.3.</span> <span class="toc-text"> class泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.11.4.</span> <span class="toc-text"> 接口定义泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.11.5.</span> <span class="toc-text"> 类型别名泛型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text"> 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text"> 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%91%E5%AE%9A"><span class="toc-number">4.2.</span> <span class="toc-text"> 解构绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text"> 函数定义语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%AD%BE%E5%90%8D"><span class="toc-number">5.2.</span> <span class="toc-text"> 重载签名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BBclass"><span class="toc-number">6.</span> <span class="toc-text"> 类class</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#implements"><span class="toc-number">6.1.</span> <span class="toc-text"> implements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%AD%BE%E5%90%8D-2"><span class="toc-number">6.2.</span> <span class="toc-text"> 重载签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">6.3.</span> <span class="toc-text"> 索引签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-2"><span class="toc-number">6.4.</span> <span class="toc-text"> 泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7"><span class="toc-number">6.5.</span> <span class="toc-text"> 构造函数参数作为属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.</span> <span class="toc-text"> 抽象类与抽象方法</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">203</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">TypeScript</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/">JavaScript语言</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p>TypeScript是JavaScript的超集，任何合法的JavaScript代码都是合法的TypeScript代码。</p>
<p>TypeScript的目的是为JavaScript提供静态类型检查，使得JavaScript更加清晰明确。你可以将TypeScript当成静态类型版本的JavaScript，它的独有语法类似于Java和C#。</p>
<p>TypeScript的代码无法直接运行，必须要编译为JavaScript，编译通过后TypeScript中的独有语法例如类型声明等都会消失，因此TypeScript无法检查代码运行时的任何问题。</p>
<span id="more"></span>
<h1 id="选项"><a class="markdownIt-Anchor" href="#选项"></a> 选项</h1>
<ul>
<li><code>noImplicitAny</code>：禁止自动推断为<code>any</code></li>
<li><code>strictNullChecks</code>：开启时，TypeScript具有单独的<code>null</code>和<code>undefined</code>类型。不开启时，<code>null</code>和<code>undefined</code>会视作<code>any</code>。</li>
<li><code>strictPropertyInitialization</code>：开启时，<code>class</code>语法中的类字段必须进行初始化，要么通过类字段的初始化表达式，要么在构造函数中使用赋值表达式。</li>
</ul>
<h1 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h1>
<p>大体上，TypeScript=JavaScript+类型，因此类型是TypeScript最核心的内容。<br />
使用<code>类型</code>表示任意一种TypeScript类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">TypeScript类型</th>
<th style="text-align:left">JavaScript类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>undefined</code></td>
<td style="text-align:left"><code>Undefined</code></td>
</tr>
<tr>
<td style="text-align:left"><code>null</code></td>
<td style="text-align:left"><code>Null</code></td>
</tr>
<tr>
<td style="text-align:left"><code>boolean</code></td>
<td style="text-align:left"><code>Boolean</code></td>
</tr>
<tr>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"><code>String</code></td>
</tr>
<tr>
<td style="text-align:left"><code>symbol</code></td>
<td style="text-align:left"><code>Symbol</code></td>
</tr>
<tr>
<td style="text-align:left"><code>number</code></td>
<td style="text-align:left"><code>Number</code></td>
</tr>
<tr>
<td style="text-align:left"><code>bigint</code></td>
<td style="text-align:left"><code>BigInt</code></td>
</tr>
<tr>
<td style="text-align:left"><code>object</code></td>
<td style="text-align:left"><code>Object</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Array&lt;类型&gt;</code>或<code>类型[]</code></td>
<td style="text-align:left"><code>Object</code>(数组对象)</td>
</tr>
<tr>
<td style="text-align:left">元组类型</td>
<td style="text-align:left"><code>Object</code>(数组对象)</td>
</tr>
<tr>
<td style="text-align:left">函数类型</td>
<td style="text-align:left"><code>Object</code>(函数对象)</td>
</tr>
<tr>
<td style="text-align:left"><code>any</code></td>
<td style="text-align:left">可以是任何类型</td>
</tr>
<tr>
<td style="text-align:left"><code>&#123; 属性定义 &#125;</code></td>
<td style="text-align:left">自己或包装类型满足属性要求的类型</td>
</tr>
<tr>
<td style="text-align:left">接口</td>
<td style="text-align:left">自己或包装类型满足接口要求的类型</td>
</tr>
<tr>
<td style="text-align:left">并类型</td>
<td style="text-align:left">参与并运算的类型的并集</td>
</tr>
<tr>
<td style="text-align:left">交类型</td>
<td style="text-align:left">参与交运算的类型的交集</td>
</tr>
<tr>
<td style="text-align:left">字面值类型</td>
<td style="text-align:left">字面值所属的类型</td>
</tr>
<tr>
<td style="text-align:left"><code>never</code></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><code>void</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>unknown</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>Function</code></td>
<td style="text-align:left">具有<code>bind</code>, <code>call</code>,<code>apply</code>和<code>[[Call]]</code>的对象</td>
</tr>
</tbody>
</table>
<h2 id="具体类型"><a class="markdownIt-Anchor" href="#具体类型"></a> 具体类型</h2>
<h3 id="对象类型"><a class="markdownIt-Anchor" href="#对象类型"></a> 对象类型</h3>
<p>对象是一系列属性的集合，因此在TypeScript中，通过定义对于属性的要求，来限制能够赋值的对象（若包装类型满足要求也符合条件，因此不一定限制为JavaScript中的<code>Object</code>类型）<br />
这种定义在TypeScript通常称为对象类型，它形如JavaScript中的对象字面值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有属性要求的对象类型</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 有一个属性要求的对象类型</span></span><br><span class="line">&#123; 属性要求<span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 有多个属性要求的对象类型，用,或;分隔，最后的,或;是可选的</span></span><br><span class="line">&#123; 属性要求<span class="number">1</span>, 属性要求<span class="number">2</span>, &#125;</span><br></pre></td></tr></table></figure>
<p>属性要求有下列形式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">属性键: 类型</span><br><span class="line">属性键?: 类型</span><br><span class="line"><span class="keyword">readonly</span> 属性键: 类型</span><br><span class="line">[index: <span class="built_in">number</span>]: 类型 <span class="comment">// 对所有数组索引属性键的要求</span></span><br><span class="line">[index: <span class="built_in">string</span>]: 类型 <span class="comment">// 对所有字符串索引属性键的要求</span></span><br><span class="line">属性键(形式参数列表): 返回类型 <span class="comment">// 函数类型，等价于 属性键: 函数类型</span></span><br><span class="line"><span class="comment">// 属性键有下列形式：</span></span><br><span class="line">标识符名</span><br><span class="line">字符串字面值</span><br><span class="line">数字字面值</span><br><span class="line">[知名<span class="built_in">Symbol</span>]</span><br></pre></td></tr></table></figure>
<p>冒号左侧的是属性键，对象类型要求属性键不能相同。<br />
属性键后带有问号<code>?</code>的属性要求，表示这是一个可选的属性要求，所限制的值可以没有该属性。<br />
属性键前面带有<code>readonly</code>的属性要求，表示这是一个只读的属性，当试图修改它的值时TypeScript会报错。<code>readonly</code>不是JavaScript语言的内容，而是TypeScript的独有功能，在被编译为JavaScript后不存在所谓只读属性。<br />
因此可选属性的类型，等价于原有类型与<code>undefined</code>类型的并集。</p>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p>接口是为方便对象类型的合并，以及基于已有对象类型创建新对象类型设计的。它类似于起别名，但有一些独有的特征，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> 接口名 对象类型;</span><br></pre></td></tr></table></figure>
<p>独有特征为：<br />
可以用多个同名接口，来定义一种对象类型，每个接口的属性要求都会通过与运算合并。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用<code>extends</code>来基于已有接口创建新接口，相当于把<code>extends</code>的接口中的属性要求复制过来。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A, B &#123;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> C = &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TypeScript提供了一些内置接口类型，以便用户使用：</p>
<h4 id="数组接口"><a class="markdownIt-Anchor" href="#数组接口"></a> 数组接口</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;&#125; <span class="comment">// 数组, 等价于T[]</span></span><br><span class="line"><span class="keyword">interface</span> ReadonlyArray&lt;T&gt; &#123;&#125; <span class="comment">// 只读数组, 等价于readonly T[]</span></span><br></pre></td></tr></table></figure>
<p>可以将<code>Array</code>类型的变量赋给<code>ReadonlyArray</code>，但不能将<code>ReadonlyArray</code>类型的变量赋给<code>Array</code></p>
<h3 id="字面值类型"><a class="markdownIt-Anchor" href="#字面值类型"></a> 字面值类型</h3>
<p><code>number</code>、<code>string</code>和<code>boolean</code>的更具体的类型称为字面值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number更具体的类型</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="comment">// string更具体的类型</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// boolean更具体的类型</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用<code>const</code>声明的变量，在自动推断类型时，如果<code>初始化表达式</code>是一个<code>Number</code>或<code>String</code>或<code>Boolean</code>类型值，就会被推断为字面值类型。例如<code>const a = &quot;abc&quot;</code>。<br />
如果<code>初始化表达式</code>是一个对象，那么对象的属性不会被推断为是字面值类型。例如<code>const a = &#123; s: &quot;abc&quot; &#125;</code>，只会推断为对象类型<code>&#123; s: string &#125;</code>。<br />
如果想让对象的属性被推断为字面值类型，可以在值后面用<code>as</code>来修改推断的类型，例如<code>const a = &#123; s: &quot;abc&quot; as &quot;abc&quot; &#125;</code>。另一种办法是在整个对象后面使用<code>as const</code>将所有属性值为字面值的属性类型推断为字面值类型，例如<code>const a = &#123; s:&quot;abc&quot; &#125; as const</code></p>
<h3 id="元组类型"><a class="markdownIt-Anchor" href="#元组类型"></a> 元组类型</h3>
<p>元组类型的长度是固定的，每个索引的类型也是固定的，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[索引类型, 索引类型, 索引类型]</span><br><span class="line"><span class="keyword">readonly</span> [索引类型, 索引类型, 索引类型] <span class="comment">// 只读的元组</span></span><br></pre></td></tr></table></figure>
<p>每个<code>索引类型</code>可以是下列形式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型</span><br><span class="line">类型? <span class="comment">// 可选类型，等价于 undefined | 类型</span></span><br><span class="line">...类型[]</span><br><span class="line">...元组类型</span><br></pre></td></tr></table></figure>
<p><code>类型</code>表示它对应的索引的值的类型<br />
<code>...类型[]</code>表示从它对应的索引开始，任意个数量的值都是<code>类型</code><br />
<code>...元组类型</code>表示从它对应的索引开始，每个值的类型取决于<code>元组类型</code></p>
<h3 id="never类型"><a class="markdownIt-Anchor" href="#never类型"></a> never类型</h3>
<p><code>never</code>类型通常出现在参数为并类型的函数的<code>switch</code>语句内，在<code>default</code>子句内使用<code>never</code>类型接受参数，如果能够正常赋值，则说明前面的<code>case</code>子句已处理了并类型中所有可能的情况，如果不能正常赋值，则说明还存在没有处理的情况。<br />
正常情况下，使用<code>never</code>类型的<code>default</code>子句永远不会执行。例如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape = Circle | Square;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> shape.sideLength ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">const</span> _exhaustiveCheck: <span class="built_in">never</span> = shape;</span><br><span class="line">      <span class="keyword">return</span> _exhaustiveCheck;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>never</code>的另一种用法是在函数的返回类型中。表示这个函数会抛出异常或者终止程序，从而不会存在一个返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="void类型"><a class="markdownIt-Anchor" href="#void类型"></a> void类型</h3>
<p><code>void</code>类型用于函数定义时，表示函数不返回值。没有任何<code>return</code>语句（或者只有<code>return</code>没有值）的函数会被推断为返回<code>void</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>void</code>类型用于函数表达式时，表示不管函数体中返回什么，函数调用者都不会去关注或使用返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f1: (<span class="function">() =&gt;</span> <span class="built_in">void</span>) = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unknown类型"><a class="markdownIt-Anchor" href="#unknown类型"></a> unknown类型</h3>
<p><code>unknown</code>类型是<code>any</code>的安全版本，它和<code>any</code>一样可以接受任何值，但你不能把<code>unknown</code>类型的值赋给其他类型，也不能在<code>unkown</code>类型上调用方法。<br />
通常用于这样的函数：返回的值可以是任意类型，在使用它之前调用者必须进行检查。<br />
如果调用者不对返回结果进行检查，则根本无法使用这个值。<br />
示例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeParse</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Need to be careful with &#x27;obj&#x27;!</span></span><br><span class="line"><span class="keyword">const</span> result = safeParse(someRandomString);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，返回值<code>result</code>是<code>unknown</code>类型，因此要想进一步使用，必须进行类型检查或者类型断言来缩小范围。</p>
<h3 id="函数类型"><a class="markdownIt-Anchor" href="#函数类型"></a> 函数类型</h3>
<p>每个函数对象都有<code>[[Call]]</code>内部方法，表示任何函数对象都能作为函数调用。<br />
部分函数对象有<code>[[Construct]]</code>内部方法，表示部分函数对象能作为构造函数调用。<br />
函数类型也分为有<code>[[Call]]</code>或有<code>[[Construct]]</code>内部方法两种。</p>
<h4 id="call"><a class="markdownIt-Anchor" href="#call"></a> [[Call]]</h4>
<p>该函数类型的值具有<code>[[Call]]</code>内部方法，能够作为普通函数调用，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种形式</span></span><br><span class="line">(形式参数列表) =&gt; 返回类型</span><br><span class="line"><span class="comment">// 使用对象类型表示的第二种形式</span></span><br><span class="line">&#123;</span><br><span class="line">  (形式参数列表): 返回类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的形式参数列表是以逗号分隔的形式参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空形式参数列表</span></span><br><span class="line">( )</span><br><span class="line"><span class="comment">// 多个形式参数用逗号分隔</span></span><br><span class="line">(形式参数<span class="number">1</span> , 形式参数<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 只有剩余形式参数的形式参数列表</span></span><br><span class="line">( 剩余形式参数 )</span><br><span class="line"><span class="comment">// 剩余形式参数是可选的，但必须是最后一个形式参数</span></span><br><span class="line">(形式参数<span class="number">1</span> , 形式参数<span class="number">2</span>, 剩余形式参数)</span><br></pre></td></tr></table></figure>
<p>每个形式参数有下列形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式参数</span></span><br><span class="line"><span class="built_in">this</span>: 类型 <span class="comment">// 用于控制允许的thisArgument</span></span><br><span class="line">标识符: 类型</span><br><span class="line">标识符?: 类型 <span class="comment">// 等价于 标识符: 类型 | undefined</span></span><br><span class="line">标识符: 类型 = 默认值</span><br><span class="line">对象结构绑定: 类型</span><br><span class="line">数组解构绑定: 类型 = 默认值</span><br><span class="line"><span class="comment">// 剩余形式参数</span></span><br><span class="line">...标识符: 数组类型</span><br><span class="line">...对象解构绑定: 对象类型</span><br><span class="line">...数组结构绑定: 数组类型</span><br></pre></td></tr></table></figure>
<p><code>标识符?: 类型</code>必须位于剩余形式参数之前，同时在其他形式的形式参数之后，通常称为可选参数。在回调函数的声明中，不要使用可选参数。</p>
<h4 id="construct"><a class="markdownIt-Anchor" href="#construct"></a> [[Construct]]</h4>
<p>该函数类型的值具有<code>[[Construct]]</code>内部方法，能够作为普通函数调用，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> (形式参数列表): 返回类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h2>
<h3 id="并类型"><a class="markdownIt-Anchor" href="#并类型"></a> 并类型</h3>
<p>基于已有类型可以使用并运算创建新类型，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型<span class="number">1</span> | 类型<span class="number">2</span></span><br><span class="line">类型<span class="number">1</span> | 类型<span class="number">2</span> | 类型<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>其含义为所限制的值，要么满足类型1的要求，要么满足类型2的要求。<br />
访问并类型对象的属性时候，需要通过<code>typeof</code>等方法明确判断出类型后，才能调用参与并运算的单一类型的独有属性。如果不明确判断类型，只能访问参与并运算的类型都具有的属性。</p>
<h3 id="交类型"><a class="markdownIt-Anchor" href="#交类型"></a> 交类型</h3>
<p>基于已有类型可以使用与运算创建新类型，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型<span class="number">1</span> &amp; 类型<span class="number">2</span></span><br><span class="line">类型<span class="number">1</span> &amp; 类型<span class="number">2</span> &amp; 类型<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>其含义为所限制的值，既要满足类型1的要求，又要满足类型2的要求。<br />
通常只有对象类型才会进行与运算，因为其他类型诸如<code>number</code>, <code>string</code>等与运算的结果是<code>never</code>，不存在满足这种要求的值。</p>
<h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h3>
<p>有的类型书写起来很长，例如对象类型、并类型，多次使用时并不方便。<br />
为了简洁，TypeScript提供了定义类型别名的功能，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 别名 = 类型;</span><br></pre></td></tr></table></figure>
<p>在使用<code>别名</code>的地方，TypeScript会自动将其替换为等号右侧的<code>类型</code>。</p>
<h3 id="类型断言"><a class="markdownIt-Anchor" href="#类型断言"></a> 类型断言</h3>
<p>类型断言用于让TypeScript将一个值的类型视作更具体的类型，或者更概括的类型。<br />
例如<code>interface A extends B</code>，则<code>A</code>是更具体的类型，它继承了<code>B</code>的要求并拥有自己更多的要求，而<code>B</code>是更概括的类型。<code>any</code>类型是最概括的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">值 <span class="keyword">as</span> 更具体的类型/更概括的类型</span><br><span class="line">&lt;更具体的类型/更概括的类型&gt; 值</span><br></pre></td></tr></table></figure>
<p>还有一种非<code>null</code>或<code>undefined</code>断言，令TypeScript忽略一个值为<code>null</code>或<code>undefined</code>的情况，其语法为</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值!</span><br></pre></td></tr></table></figure>
<h3 id="类型谓词"><a class="markdownIt-Anchor" href="#类型谓词"></a> 类型谓词</h3>
<p>类型谓词是一个函数，它的目的是判断一个并类型值的具体类型。通常用在函数的<code>if</code>语句内来缩小类型。<br />
类型谓词返回一个布尔值，通常是使用<code>typeof</code>、相等性运算符、<code>instanceof</code>、<code>Array.is</code>、<code>in</code>等判断类型的结果。<br />
类型谓词的返回类型位置必须写成<code>参数 is 具体类型</code>，例如下面的例子，用<code>swim</code>属性的存在与否判断是否是<code>Fish</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> Fish).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类中也可以定义类型谓词函数，例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystemObject</span> </span>&#123;</span><br><span class="line">  isFile(): <span class="built_in">this</span> is FileRep &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span> <span class="keyword">instanceof</span> FileRep;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="keyof"><a class="markdownIt-Anchor" href="#keyof"></a> keyof</h3>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyof 对象类型</span><br></pre></td></tr></table></figure>
<p><code>keyof</code>会将对象类型中的数组索引属性键和其他字符串属性键，作为字面值类型进行并运算得到新类型。例如<code>keyof &#123;0: number, '1': number&#125;</code>得到的类型是<code>0 | '1'</code>。注意它将数组索引视作<code>number</code>，其他字符串属性键视作<code>string</code>。<br />
对于<code>[index: number]</code>的属性会作为<code>number</code>类型进行并运算，对于<code>[index: string]</code>的属性会作为<code>number| string</code>进行并运算。</p>
<h3 id="typeof"><a class="markdownIt-Anchor" href="#typeof"></a> typeof</h3>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> 标识符/属性访问</span><br></pre></td></tr></table></figure>
<p>在TypeScript中，当在一个类型上下文使用<code>typeof 标识符/属性访问</code>时，它表示<code>标识符/属性访问</code>对应值的类型。<br />
一种特殊用法是<code>typeof 数组对象[number]</code>，用于获取数组元素的类型，等价于<code>typeof 数组对象[0]</code></p>
<h3 id="索引类型"><a class="markdownIt-Anchor" href="#索引类型"></a> 索引类型</h3>
<p>可以通过字面值类型来获取一个对象类型的某个属性键的类型，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象类型[字面值类型]</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123; <span class="attr">age</span>: <span class="built_in">number</span>; name: <span class="built_in">string</span>; alive: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> I1 = Person[<span class="string">&quot;age&quot;</span> | <span class="string">&quot;name&quot;</span>]; <span class="comment">// number | string</span></span><br><span class="line"><span class="keyword">type</span> I2 = Person[keyof Person]; <span class="comment">// number | string | boolean</span></span><br></pre></td></tr></table></figure>
<h3 id="条件运算"><a class="markdownIt-Anchor" href="#条件运算"></a> 条件运算</h3>
<p>条件运算的语法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被判断的类型 <span class="keyword">extends</span> 定义条件的其他类型 ? 为真时的类型 : 为假时的类型;</span><br></pre></td></tr></table></figure>
<p>它的意思是，如果<code>被判断的类型</code>满足了<code>定义条件的其他类型</code>的要求，则该运算的结果是<code>为真时的类型</code>，否则结果是<code>为假时的类型</code>。<br />
条件运算通常和泛型结合使用，因为<code>被判断的类型</code>是一个类型参数时才有意义，例如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BoolOrStr&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125; ? <span class="built_in">boolean</span> : <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<h3 id="in"><a class="markdownIt-Anchor" href="#in"></a> in</h3>
<p>在对象类型中，使用下列语法会同时定义多个属性要求，每个属性要求的属性键是<code>字面值类型</code>（通常是并类型）之一。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [key <span class="keyword">in</span> 字面值类型]: 类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对象类型中，使用下列语法会同时定义多个属性要求，每个属性要求的属性键是<code>对象类型</code>中的属性键，其<code>readonly</code>和可选性质也保持不变。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof 对象类型]: 类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过添加<code>readonly</code>将定义的所有属性变为<code>readonly</code>的，也可以通过添加<code>-readonly</code>将定义的所有属性变为非<code>readonly</code>的。对于可选属性<code>?</code>也是同理，即：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof 对象类型]: 类型 <span class="comment">// 全部只读</span></span><br><span class="line">-<span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof 对象类型]: 类型 <span class="comment">// 全部非只读</span></span><br><span class="line">[key <span class="keyword">in</span> keyof 对象类型]?: 类型 <span class="comment">// 全部可选</span></span><br><span class="line">[key <span class="keyword">in</span> keyof 对象类型]-?: 类型 <span class="comment">// 全部非可选</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h3>
<h4 id="函数定义泛型"><a class="markdownIt-Anchor" href="#函数定义泛型"></a> 函数定义泛型</h4>
<p>在函数中，可以为<code>形式参数列表</code>中使用的类型起一个别名，在函数其他地方使用。<br />
具体而言，如果函数声明了<code>类型参数名</code>，并在<code>形式参数列表</code>中将<code>类型参数名</code>用作类型。<br />
那么在函数体或返回类型处就可以将<code>类型参数名</code>用作类型，其指代的具体类型取决于TypeScript从<code>形式参数列表</code>中推断出的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 标识符&lt;类型参数名&gt;(<span class="params">形式参数列表</span>): 返回类型 </span>&#123; 函数体 &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> 标识符&lt;类型参数名 <span class="title">extends</span> 类型&gt;(<span class="params">形式参数列表</span>): 返回类型 </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<p>当<code>类型参数名</code>后有<code>extends 类型</code>时，<code>形式参数列表</code>中使用<code>类型参数名</code>作为类型的值，必须满足<code>extends</code>后面的<code>类型</code>的要求。例如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longest</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; length: <span class="built_in">number</span> &#125;&gt;(a: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.length &gt;= b.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T extends &#123; length: number&#125;</code>，要求使用类型<code>T</code>的形式参数<code>a</code>和<code>b</code>的值必须具有类型为<code>number</code>的<code>length</code>属性。</p>
<p>在调用函数时，通常会根据传递的实际参数的类型自动推断<code>类型参数名</code>，有时也会无法推断出来，此时可以通过<code>返回函数对象的表达式&lt;类型参数名指代的类型&gt;(实际参数列表)</code>来显式指定<code>类型参数名</code>所表示的类型。</p>
<h4 id="函数类型泛型"><a class="markdownIt-Anchor" href="#函数类型泛型"></a> 函数类型泛型</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[Call]]第一种形式</span></span><br><span class="line">&lt;类型参数名&gt;<span class="function">(<span class="params">形式参数列表</span>) =&gt;</span> 返回类型</span><br><span class="line"><span class="comment">// 使用对象类型表示的第二种形式</span></span><br><span class="line">&#123;</span><br><span class="line">  &lt;类型参数名&gt;(形式参数列表): 返回类型</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [[Construct]]</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> &lt;类型参数名&gt;(形式参数列表): 返回类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="class泛型"><a class="markdownIt-Anchor" href="#class泛型"></a> class泛型</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 标识符&lt;类型参数名&gt; </span>&#123; 可选类体 &#125;</span><br></pre></td></tr></table></figure>
<p><code>static</code>成员不能使用<code>类型参数名</code></p>
<h4 id="接口定义泛型"><a class="markdownIt-Anchor" href="#接口定义泛型"></a> 接口定义泛型</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> 接口名&lt;类型参数名&gt; 对象类型;</span><br></pre></td></tr></table></figure>
<p>这种形式可以定义带有泛型的接口，在<code>对象类型</code>中可以将<code>类型参数名</code>用作类型。<br />
在使用此接口类型时，必须显式指定<code>类型参数名</code>，即<code>let a: 接口名&lt;类型参数名指代的类型&gt;</code></p>
<h4 id="类型别名泛型"><a class="markdownIt-Anchor" href="#类型别名泛型"></a> 类型别名泛型</h4>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 别名&lt;类型参数名&gt; = 类型</span><br></pre></td></tr></table></figure>
<p>这种形式可以定义带有泛型的别名，在<code>类型</code>中可以将<code>类型参数名</code>用作类型。<br />
在使用此接口类型时，必须显式指定<code>类型参数名</code>，即<code>let a: 别名&lt;类型参数名指代的类型&gt;</code></p>
<h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1>
<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量声明<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 多个变量声明用逗号分隔</span></span><br><span class="line"><span class="keyword">var</span> 变量声明<span class="number">1</span>, 变量声明<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> 变量声明<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> 变量声明<span class="number">1</span>, 变量声明<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> 变量声明<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> 变量声明<span class="number">1</span>, 变量声明<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><code>变量声明</code>有三种形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标识符: 类型 <span class="comment">// 这种形式const不可用</span></span><br><span class="line">标识符: 类型 = 初始化表达式</span><br><span class="line">对象解构绑定: 对象类型 = 初始化表达式</span><br><span class="line">数组解构绑定: 数组类型 = 初始化表达式</span><br></pre></td></tr></table></figure>
<p>为了简洁，在<code>变量声明</code>具有<code>初始化表达式</code>时并不需要书写类型，TypeScript会根据<code>初始化表达式</code>自动推断变量的类型。<br />
对一个已声明的变量使用赋值运算符，可以缩小其类型。</p>
<h2 id="解构绑定"><a class="markdownIt-Anchor" href="#解构绑定"></a> 解构绑定</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象解构绑定: 对象类型</span><br><span class="line">数组结构绑定: 数组类型</span><br></pre></td></tr></table></figure>
<p>变量声明中的结构绑定由于必须具有<code>初始化表达式</code>，可以自动推断类型，因此不需要书写类型。<br />
作为参数形参的结构绑定才需要书写类型。</p>
<p>对于变量，要声明类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125;: &#123; <span class="attr">a</span>: <span class="built_in">string</span>; b: <span class="built_in">number</span> &#125; = o;</span><br><span class="line">f([first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>])</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<h2 id="函数定义语法"><a class="markdownIt-Anchor" href="#函数定义语法"></a> 函数定义语法</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 标识符 (<span class="params">形式参数列表</span>): 返回类型 </span>&#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 可选的标识符 (<span class="params">形式参数列表</span>): 返回类型 </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<p>函数的形式参数列表是以逗号分隔的形式参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空形式参数列表</span></span><br><span class="line">( )</span><br><span class="line"><span class="comment">// 多个形式参数用逗号分隔</span></span><br><span class="line">(形式参数<span class="number">1</span> , 形式参数<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 只有剩余形式参数的形式参数列表</span></span><br><span class="line">( 剩余形式参数 )</span><br><span class="line"><span class="comment">// 剩余形式参数是可选的，但必须是最后一个形式参数</span></span><br><span class="line">(形式参数<span class="number">1</span> , 形式参数<span class="number">2</span>, 剩余形式参数)</span><br></pre></td></tr></table></figure>
<p>每个形式参数有下列形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式参数</span></span><br><span class="line"><span class="built_in">this</span>: 类型 <span class="comment">// 用于控制允许的thisArgument</span></span><br><span class="line">标识符: 类型</span><br><span class="line">标识符?: 类型 <span class="comment">// 等价于 标识符: 类型 | undefined</span></span><br><span class="line">标识符: 类型 = 默认值</span><br><span class="line">对象解构绑定: 类型</span><br><span class="line">数组解构绑定: 类型 = 默认值</span><br><span class="line"><span class="comment">// 剩余形式参数</span></span><br><span class="line">...标识符: 数组类型</span><br><span class="line">...对象解构绑定: 对象类型</span><br><span class="line">...数组解构绑定: 数组类型</span><br></pre></td></tr></table></figure>
<p><code>标识符?: 类型</code>必须位于剩余形式参数之前，同时在其他形式的形式参数之后，通常称为可选类型。在回调函数的声明中，不要使用可选参数。</p>
<p>为了简洁，TypeScript会根据函数体内的<code>return</code>语句自动推断返回类型。<br />
为<code>forEach</code>等函数调用传递的函数表达式中，参数也不需要类型，因为可以根据调用者的类型推断出参数的类型。</p>
<h2 id="重载签名"><a class="markdownIt-Anchor" href="#重载签名"></a> 重载签名</h2>
<p>JavaScript不支持重载函数，你只能声明一个函数并根据实际参数的值来进行不同的处理。<br />
TypeScript为了让这一过程更加清晰，提供了重载签名的功能。其语法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 标识符 (<span class="params">形式参数列表<span class="number">1</span></span>): 返回类型</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> 标识符 (<span class="params">形式参数列表<span class="number">2</span></span>): 返回类型</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> 标识符 (<span class="params">兼容上述重载的形式参数列表</span>): 返回类型 </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<p>前两个没有函数体的函数定义语法就是重载签名，它是函数能够进行调用的形式。<br />
最后一个具有函数体的函数定义语法，是对重载签名的具体实现，它的参数需要兼容重载签名的形式参数列表。这个具体实现不是能够进行调用的形式。</p>
<h1 id="类class"><a class="markdownIt-Anchor" href="#类class"></a> 类class</h1>
<p>TypeScript要求必须使用ES2022中的类字段语法定义属性及其类型，不能直接在构造函数中定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 标识符 </span>&#123; 可选类体 &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 标识符 <span class="keyword">extends</span> 左值表达式 </span>&#123; 可选类体 &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 标识符 <span class="title">implements</span> 接口名1, 接口名2 </span>&#123; 可选类体 &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 标识符 <span class="keyword">extends</span> 左值表达式 <span class="title">implements</span> 接口名1, 接口名2 </span>&#123; 可选类体 &#125;</span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 可选的标识符 </span>&#123; 可选类体 &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 可选的标识符 <span class="keyword">extends</span> 左值表达式 </span>&#123; 可选类体 &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 可选的标识符 <span class="title">implements</span> 接口名1, 接口名2 </span>&#123; 可选类体 &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 可选的标识符 <span class="keyword">extends</span> 左值表达式 <span class="title">implements</span> 接口名1, 接口名2 </span>&#123; 可选类体 &#125;</span><br></pre></td></tr></table></figure>
<p>类体中包含若干个类元素，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 标识符 </span>&#123;</span><br><span class="line">  类元素</span><br><span class="line">  类元素</span><br><span class="line">  类元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个类元素是以下几种形式之一，每个类元素前可以有<code>public</code>（没有的话默认是这个，任何地方都可以访问此属性）, <code>protected</code>（只有自己和子类可以访问）或<code>private</code>（只有自己可以访问）修饰符控制可见度，但这是TypeScript独有机制，不影响运行时的访问性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类元素</span></span><br><span class="line">字段定义</span><br><span class="line"><span class="keyword">static</span> 字段定义</span><br><span class="line">方法定义</span><br><span class="line"><span class="keyword">static</span> 方法定义</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>字段定义有下列形式，每个形式前可以有<code>readonly</code>修饰符表示禁止在构造函数或初始化表达式以外的地方赋值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公有字段</span></span><br><span class="line">标识符: 类型</span><br><span class="line">标识符: 类型 = 初始化表达式</span><br><span class="line"><span class="comment">// 私有字段</span></span><br><span class="line">#标识符: 类型</span><br><span class="line">#标识符: 类型 = 初始化表达式</span><br></pre></td></tr></table></figure>
<p>方法定义有以下六种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性名(参数)&#123;函数体&#125; <span class="comment">// 例如 say()&#123;&#125;</span></span><br><span class="line">get 属性名()&#123;函数体&#125; <span class="comment">// 例如 get length()&#123;&#125;</span></span><br><span class="line">set 属性名(参数)&#123;函数体&#125; <span class="comment">// 例如 set length(val)&#123;&#125;</span></span><br><span class="line">* 属性名(参数)&#123;生成器函数体&#125; <span class="comment">// 例如 * gen()&#123;&#125;</span></span><br><span class="line"><span class="keyword">async</span> 属性名(参数)&#123;异步函数体&#125; <span class="comment">// 例如 async f()&#123;&#125;</span></span><br><span class="line"><span class="keyword">async</span> * 属性名(参数)&#123;异步生成器函数体&#125; <span class="comment">// 例如 async *g()&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="implements"><a class="markdownIt-Anchor" href="#implements"></a> implements</h2>
<p><code>implements 接口名</code>子句是TypeScript独有的，它的意思是类的实例属性必须满足接口的要求（接口中的可选属性可以没有）。</p>
<h2 id="重载签名-2"><a class="markdownIt-Anchor" href="#重载签名-2"></a> 重载签名</h2>
<p>类构造函数也支持重载签名，不过它没有显式的返回类型，也不能有泛型参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span>(<span class="params">形式参数列表<span class="number">1</span></span>);</span><br><span class="line"><span class="title">constructor</span>(<span class="params">形式参数列表<span class="number">2</span></span>);</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">兼容上述形式的形式参数列表</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引签名"><a class="markdownIt-Anchor" href="#索引签名"></a> 索引签名</h2>
<p>类也支持索引签名，它要求类的所有实例或static属性都满足特定的类型要求。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[index: <span class="built_in">number</span>]: 类型 <span class="comment">// 对所有数组索引实例属性键的要求</span></span><br><span class="line">[index: <span class="built_in">string</span>]: 类型 <span class="comment">// 对所有字符串索引实例属性键的要求</span></span><br><span class="line"><span class="keyword">static</span> [index: <span class="built_in">number</span>]: 类型 <span class="comment">// 对所有数组索引static属性键的要求</span></span><br><span class="line"><span class="keyword">static</span> [index: <span class="built_in">string</span>]: 类型 <span class="comment">// 对所有字符串索引static属性键的要求</span></span><br></pre></td></tr></table></figure>
<h2 id="泛型-2"><a class="markdownIt-Anchor" href="#泛型-2"></a> 泛型</h2>
<p>类中的泛型写在<code>标识符</code>后面，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 标识符&lt;类型参数名&gt; </span>&#123; 可选类体 &#125;</span><br></pre></td></tr></table></figure>
<p>之后在类中任何非<code>static</code>属性的地方都可以将<code>类型参数名</code>用作类型。</p>
<h2 id="构造函数参数作为属性"><a class="markdownIt-Anchor" href="#构造函数参数作为属性"></a> 构造函数参数作为属性</h2>
<p>由于TypeScript规定必须使用ES2022中的类字段语法定义属性及其类型，不能直接在构造函数中定义，当需要通过构造函数的参数来初始化类字段时，就需要书写如下内容：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Params</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">protected</span> y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> z: <span class="built_in">number</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, z: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中参数名和类型都是重复且没必要的，函数体也是固定格式。<br />
为了简洁，TypeScript提供了基于构造函数参数来定义实例属性并初始化的语法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Params</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> y: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> z: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// No body necessary</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类与抽象方法"><a class="markdownIt-Anchor" href="#抽象类与抽象方法"></a> 抽象类与抽象方法</h2>
<p>TypeScript提供了独有的<code>abstarct</code>关键字来声明抽象类和抽象方法，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 标识符 </span>&#123; 可选类体 &#125;</span><br></pre></td></tr></table></figure>
<p>抽象类不能使用<code>new</code>创建实例。注意抽象类是TypeScript中的机制，转换为JavaScript后<code>abstract</code>关键字会被直接去掉，效果和普通类一样。</p>
<p>在抽象类中，可以定义抽象方法，其语法为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> 没有函数体的方法定义;</span><br></pre></td></tr></table></figure>
<p>抽象方法没有函数体，任何<code>extends</code>继承了抽象类的派生类，必须实现基类规定的抽象方法。注意抽象方法是TypeScript中的机制，转换为JavaScript后，基类中不存在抽象方法。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/TypeScript.html">https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/TypeScript.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/Symbol.html"><i class="fa fa-chevron-left">  </i><span>Symbol</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/ES5.html"><span>ES5</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>