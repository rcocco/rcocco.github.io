<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="learn_js"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>learn_js | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text"> 数组和字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#math%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text"> Math对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#json"><span class="toc-number">3.</span> <span class="toc-text"> JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text"> 高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.2.</span> <span class="toc-text"> 参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="toc-number">3.3.</span> <span class="toc-text"> 绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text"> 对象和原型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toc-number">4.1.</span> <span class="toc-text"> 原型污染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getter%E5%92%8Csetter"><span class="toc-number">4.2.</span> <span class="toc-text"> getter和setter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">4.3.</span> <span class="toc-text"> 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-number">4.4.</span> <span class="toc-text"> instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.5.</span> <span class="toc-text"> this和作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">5.</span> <span class="toc-text"> 调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">5.1.</span> <span class="toc-text"> 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">5.2.</span> <span class="toc-text"> 断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text"> 正则表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F"><span class="toc-number">7.</span> <span class="toc-text"> 日期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="toc-number">8.</span> <span class="toc-text"> 将字符串作为代码执行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text"> 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">9.1.</span> <span class="toc-text"> 函数作为命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">9.2.</span> <span class="toc-text"> 多个函数的模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#commonjs%E6%A8%A1%E5%9D%97"><span class="toc-number">9.3.</span> <span class="toc-text"> CommonJS模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.4.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89"><span class="toc-number">9.5.</span> <span class="toc-text"> 异步模块定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.</span> <span class="toc-text"> 接口设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%85%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">11.</span> <span class="toc-text"> 浅深拷贝与对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">12.</span> <span class="toc-text"> 作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">13.</span> <span class="toc-text"> 闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#es6%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">14.</span> <span class="toc-text"> ES6类与继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#temp"><span class="toc-number">15.</span> <span class="toc-text"> temp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%8F%B7"><span class="toc-number">16.</span> <span class="toc-text"> 分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web-worker"><span class="toc-number">17.</span> <span class="toc-text"> Web Worker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAworker%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.1.</span> <span class="toc-text"> 创建Worker线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">17.2.</span> <span class="toc-text"> 发送与接收数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.3.</span> <span class="toc-text"> 关闭线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">18.</span> <span class="toc-text"> 定时器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">19.</span> <span class="toc-text"> 浮点数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#url%E8%A7%A3%E7%A0%81"><span class="toc-number">20.</span> <span class="toc-text"> URL解码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xmlhttprequest"><span class="toc-number">21.</span> <span class="toc-text"> XMLHttpRequest</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">21.1.</span> <span class="toc-text"> 同步请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">21.2.</span> <span class="toc-text"> 异步请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">21.3.</span> <span class="toc-text"> 属性和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">21.4.</span> <span class="toc-text"> 安全性与同源策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">22.</span> <span class="toc-text"> 跨域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">23.</span> <span class="toc-text"> 安全性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">24.</span> <span class="toc-text"> 表单</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">25.</span> <span class="toc-text"> 本地存储</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-number">26.</span> <span class="toc-text"> 生成器函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">27.</span> <span class="toc-text"> 异步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#async%E5%BA%93"><span class="toc-number">27.1.</span> <span class="toc-text"> async库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jquery"><span class="toc-number">27.2.</span> <span class="toc-text"> jQuery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">27.3.</span> <span class="toc-text"> Promise</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A8%8B"><span class="toc-number">28.</span> <span class="toc-text"> 基于数据的编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%90%8C%E6%AD%A5%E5%86%99%E6%B3%95"><span class="toc-number">29.</span> <span class="toc-text"> 异步函数的类同步写法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">30.</span> <span class="toc-text"> 异步生成器</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">174</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">learn_js</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/">JavaScript语言</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="数组和字符串"><a class="markdownIt-Anchor" href="#数组和字符串"></a> 数组和字符串</h1>
<p><code>value.x</code>获取value中名为x的属性，这种形式要求x是一个合法变量名，<code>value[x]</code>先计算表达式x的值，将计算结果作为属性的名称。<br />
由于<code>0</code>不是一个合法变量名，所以<code>value.0</code>的写法无效，必须写成<code>value[0]</code></p>
<span id="more"></span>
<p>数组：</p>
<ul>
<li><code>[].length</code>获取长度</li>
<li><code>[].push(&quot;a&quot;, 1)</code>向数组末尾添加值</li>
<li><code>[&quot;a&quot;].pop()</code>删除数组末尾的值并将该值返回</li>
<li><code>[].unshift(&quot;a&quot;)</code>向数组开头添加值</li>
<li><code>[&quot;a&quot;].shift()</code>删除数组开头的值并将该值返回。</li>
<li><code>[1, 2].join(&quot; &quot;)</code>用参数来将数组内容拼接成字符串</li>
<li><code>[&quot;a&quot;, &quot;b&quot;].indexOf(&quot;a&quot;)</code>从前往后查找指定值，如果有返回索引，不存在则返回<code>-1</code></li>
<li><code>[&quot;a&quot;, &quot;b&quot;].lastIndexOf(&quot;a&quot;)</code>从后往前查找指定值，如果有返回索引，不存在返回<code>-1</code></li>
<li><code>[0, 1, 2].slice(start, end)</code>获取索引为<code>[start, end)</code>之间的值，<code>end</code>如果不写则返回索引为<code>[start, arr.length)</code>之间所有的值</li>
<li><code>[&quot;a&quot;].concat([2])</code>用于将参数中数组的元素添加到当前数组的后面。</li>
<li><code>[0, 1, 2].forEach(function(item)&#123;console.log(item);&#125;)</code>对数组中每个元素执行操作，该操作是由传递进来的函数对象指定的。下面是一个示例实现，但区别在于数组的<code>forEach</code>是数组的标准方法，在数组上调用，因此不需要像下面示例那样传递数组本身，只需要传递动作函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    action(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[0, 1, 2].filter(function(item)&#123; return item &gt; 50; &#125;)</code>对数组中每个元素执行判断，如果为true则添加到新数组，该判断是由传递进来的函数对象指定的，该函数对象接受数组中的元素，返回true或false。下面是一个示例实现，但区别在于数组的<code>forEach</code>是数组的标准方法，在数组上调用，因此不需要像下面示例那样传递数组本身，只需要传递判断函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">array, test</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> passed = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(test(array[i])) passed.push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> passed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[0, 1, 2].map(function(item) &#123; return item * 2; &#125;)</code>对数组中每个元素用传递进来的函数映射到一个新值，最后返回所有新值组成的想新数组。新数组长度和输入的数组一样，内容是通过对每个元素调用的函数映射成的新形式。下面是一个示例实现，但区别在于数组的<code>map</code>是数组的标准方法，在数组上调用，因此不需要像下面示例那样传递数组本身，只需要传递映射函数。映射函数可以有第二个参数，表示当前元素的索引。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array, transform</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mapped = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    passed.push(transform(array[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapped;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[0, 1, 2].reduce(combine_func, start)</code>对数组中每个元素进行操作并累计结果。可以把这个过程看作折叠数组。<code>start</code>是初始值，每次将<code>combine</code>某个元素得到的结果与<code>start</code>进行累计，将累计结果作为下一次<code>combine</code>的<code>start</code>。下面是一个示例实现，但区别在于数组的<code>map</code>是数组的标准方法，在数组上调用，因此不需要像下面示例那样传递数组本身，只需要传递合并函数和初始值，如果不给初始值，则用第一个元素作为初始值，然后从第二个元素开始执行合并。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">array, combine, start</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = start;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    current = combine(current, array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[0, 1, 2].every(function(item) &#123; return item &gt; 2 &#125;)</code>，类似<code>&amp;&amp;</code>运算符，只有所有元素调用函数的结果均为true时<code>every</code>才返回true。下面是一个示例实现，但区别在于数组的<code>every</code>是数组的标准方法，在数组上调用，因此不需要像下面示例那样传递数组本身，只需要传递判断函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">every</span>(<span class="params">array, test</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!test(array[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[0, 1, 2].some(function(item) &#123; return item &gt; 2 &#125;)</code>，类似<code>||</code>运算符，只要一个元素调用函数的结果均为true时<code>some</code>就返回true。下面是一个示例实现，但区别在于数组的<code>some</code>是数组的标准方法，在数组上调用，因此不需要像下面示例那样传递数组本身，只需要传递判断函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">some</span>(<span class="params">array, test</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(test(array[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串：</p>
<ul>
<li><code>&quot;a&quot;.length</code>获取长度</li>
<li><code>&quot;a&quot;.toUpperCase()</code>和<code>&quot;a&quot;.toLowerCase()</code>返回字符串的大写或小写副本</li>
<li><code>&quot;abc&quot;.slice(start, end)</code>和数组用法相同</li>
<li><code>&quot;abeceeq&quot;.indexOf(&quot;ee&quot;)</code>和数组用法类似，区别在于尽管字符串的最小单位是1个字符，要搜索的值也可以也可以是连续的多个字符。</li>
<li><code>&quot;abc&quot;.charAt(1)</code>获取特定索引的字符。</li>
<li><code>&quot; abc &quot;.trim()</code>删除字符串开头和结尾的空白符（空格、换行、制表符）</li>
</ul>
<h1 id="math对象"><a class="markdownIt-Anchor" href="#math对象"></a> Math对象</h1>
<ul>
<li><code>Math.max</code></li>
<li><code>Math.min</code></li>
<li><code>Math.sqrt</code></li>
<li><code>Math.sin</code></li>
<li><code>Math.cos</code></li>
<li><code>Math.tan</code></li>
<li><code>Math.acos</code>反余弦</li>
<li><code>Math.asin</code>反正弦</li>
<li><code>Math.atan</code>反正切</li>
<li><code>Math.PI</code>圆周率</li>
<li><code>Math.random</code>返回<code>[0,1)</code>之间的伪随机数<br />
-<code>Math.floor</code>向下取整</li>
<li><code>Math.ceil</code>向上取整</li>
<li><code>Math.round</code>四舍五入</li>
</ul>
<h1 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h1>
<p>JSON是JavaScript Object Notation的缩写，该格式广泛用于数据存储和Web通信。<br />
JSON格式和JavasScript数组与对象非常相似，区别在于属性名必须用双引号引起来，而且只能使用简单数据表达式，不能有函数调用、变量、计算和注释。</p>
<ul>
<li><code>JSON.stringify(o)</code>用于将一个JavaScript数据转换成JSON格式的字符串。</li>
<li><code>JSON.parse(str)</code>用于将一个JSON格式字符串转换为JavaScript数据。</li>
</ul>
<h2 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h2>
<p>如果一个函数操作其他函数，即将其他函数作为参数，或将函数作为返回值，则称其为高阶函数。</p>
<ul>
<li>可以使用高阶函数来新建另一些函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greaterThan</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 返回的函数每次都与这个不变的局部变量n比较</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123; <span class="keyword">return</span> m &gt; n; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> greaterThan10(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(greaterThan10(<span class="number">11</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以用高阶函数修改其他函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noisy</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Calling with&quot;</span>, arg);</span><br><span class="line">    <span class="keyword">var</span> val = f(arg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;called with&quot;</span>, arg, <span class="string">&quot;- got&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">noisy(<span class="built_in">Boolean</span>)(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>还可以用高阶函数实现新的控制流</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unless</span>(<span class="params">test, then</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!test) then();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">times, body</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; times; i++) body(i);</span><br><span class="line">&#125;</span><br><span class="line">repeat(<span class="number">3</span>, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  unless(n % <span class="number">2</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n, <span class="string">&quot;is even&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>内部函数的函数体可以访问其外部环境的变量，这与循环及条件语句中的<code>&#123;&#125;</code>语句块有异曲同工之妙。内部函数与语句块之间的主要区别在于，内部函数中声明的变量不会因为外部函数执行结束而丢失。</p>
<p>找最小值，不使用高阶函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = ancestry[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; ancestry.length; i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> cur = ancestry[i];</span><br><span class="line">  <span class="keyword">if</span>(cur.born &lt; min.born) min = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(min);</span><br></pre></td></tr></table></figure>
<p>使用高阶函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ancestry.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">min, cur</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cur.born &lt; min.born) <span class="keyword">return</span> cur;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> min;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>高阶函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">array, combine, start</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = start;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    current = combine(current, array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数传递"><a class="markdownIt-Anchor" href="#参数传递"></a> 参数传递</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noisy</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">var</span> val = f(arg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;called with&quot;</span>, arg, <span class="string">&quot;- got&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">noisy(<span class="built_in">Boolean</span>)(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在上面的函数中，你可以用<code>arguments.legnth</code>在内部函数知道接收了几个参数，也知道这些参数是什么。为了将参数传递给函数<code>f</code>，调用函数的语法<code>f(arg1, arg2, arg3)</code>必须逐个列出所有参数，这里的参数个数是写死的，但每次希望传递的参数个数是不确定的，所以你没有办法用调用函数的语法来列出所有参数。<br />
可以使用<code>apply</code>方法解决这个问题，该方法接受一个参数数组，然后用这些参数调用所属的函数。第一个参数会被赋值给<code>this</code>，进而模拟对象调用方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transparentWrapping</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定"><a class="markdownIt-Anchor" href="#绑定"></a> 绑定</h2>
<p>每个函数都有一个<code>bind</code>方法，该方法用于创建一个新函数，新函数是原函数相同，区别在于一些参数是被固定的。第一个参数会被赋值给<code>this</code>，进而模拟对象调用方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInSet</span>(<span class="params">set, person</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> set.indexOf(person.name) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ancestry.filter(<span class="function"><span class="keyword">function</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isInSet(theSet, person);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(ancestry.filter(isInSet.bind(<span class="literal">null</span>, theSet)));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInTheSet</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theSet.indexOf(person.name) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ancestry.filter(isInTheSet));                                                                                                                                                                                                                                                                                                                                    </span><br></pre></td></tr></table></figure>
<h1 id="对象和原型"><a class="markdownIt-Anchor" href="#对象和原型"></a> 对象和原型</h1>
<p>每个对象都有一个隐含的原型，原型是一个隐式引用，它链接到一个对象。<br />
当在一个对象自己的属性中找不到某个属性时，会接着在它的原型中查找该属性，如果没有，再查找原型的原型。<br />
空对象的原型是<code>Object.prototype</code><br />
函数和数组也是对象，函数对象的原型是<code>Function.prototype</code>，数组对象的原型是<code>Array.prototype</code><br />
通过<code>Object.getPrototypeOf(o)</code>可以得到对象<code>o</code>的原型。<br />
通过<code>Object.create(p)</code>可以创建一个以<code>p</code>为原型的空对象。</p>
<p>创建对象还可以通过构造函数语法，使用<code>new</code>关键字接一个函数调用，即<code>new Func();</code>。<br />
每个函数都可以是构造函数，“构造函数”指的是这类函数的作用，而不是一种区别于普通函数的类型，构造函数语法<code>new Func(a,b,c)</code>会这样调用函数<code>Func.apply(Object.create(Func.prototype),arguments)</code>，即将构造函数的<code>this</code>设为一个以构造函数的<code>prototype</code>属性为原型的空对象，每个函数都自动有一个<code>prototype</code>属性，该属性默认持有着一个空对象。最后，<br />
如果构造函数没有<code>return</code>语句，则会返回<code>this</code>。<br />
如果有<code>return</code>语句，且<code>return</code>的是一个对象，则返回的就是这个对象。<br />
如果有<code>return</code>语句，且<code>return</code>的不是一个对象，那么<code>return</code>语句会被忽略，等于没有，仍然返回<code>this</code>。</p>
<p>按照惯例，构造函数的名称一般以大写字母开头。</p>
<p>对象的内部属性（不希望外部调用者访问）一般以下划线<code>_</code>开头，和其他语言有语言层面的<code>private</code>属性不同，JavaScript所有属性都是公有的，可以任意访问。所以所谓内部属性只不过是个约定，没有强制作用。</p>
<p>我们可以为对象添加接口，用户只需通过接口来使用对象即可。你的对象中的其他细节则被封装了起来，隐藏在接口之后为用户提供所需功能。<br />
当我们谈论接口的时候，其实不同的对象也可以实现相同的接口，只不过不同的对象提供了不同的内部实现细节罢了，我们把这种特性称之为多态。我们会在编程过程中经常使用到多态这个特性。<br />
如果我们实现的对象之间的差别微乎其微，那么我们可以直接用原型来创建新的类型，而新类型可以通过继承原有类型的原型来实现，并使用新的构造函数来调用原有类型中的构造函数。这样可以得到一个类似于旧类型的新类型，而且我们还可以在原有类型当中添加属性或覆盖属性。</p>
<h2 id="原型污染"><a class="markdownIt-Anchor" href="#原型污染"></a> 原型污染</h2>
<p>for-in循环语句不仅会遍历对象自己的属性，还会在原型中遍历属性。<br />
for-in只遍历可枚举属性。<br />
通过<code>Object.defineProperty(o, &quot;p&quot;, &#123;enumerable: false, value: &quot;hi&quot;&#125;)</code>函数可以在一个对象上定义属性，同时修改属性的特性，例如不可枚举。也可以改变一个对象中已有属性的特性。<br />
调用对象的<code>hasOwnProperty(prop)</code>函数，用于检查对象自己（而非原型）是否包含属性<code>prop</code>。<br />
可以这样for-in来只遍历对象自己的可枚举属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="keyword">if</span>(o.hasOwnProperty(name))&#123;</span><br><span class="line">    <span class="comment">// 此时name一定是对象自己的可枚举属性了。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Object.create(null)</code>可以创建一个没有原型的空对象。</p>
<h2 id="getter和setter"><a class="markdownIt-Anchor" href="#getter和setter"></a> getter和setter</h2>
<p>可以使用get和set，使得读取或修改一个对象中的属性，实际上访问的是一个方法。这样不直接访问值，就可以对传入的值进行一些判断和处理后再赋值，甚至设置为只读，例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pile = &#123;</span><br><span class="line">  elements: [<span class="string">&quot;eggshell&quot;</span>, <span class="string">&quot;orange peel&quot;</span>],</span><br><span class="line">  <span class="keyword">get</span> <span class="title">height</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.elements.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">height</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Ignoring attemp to set height to&quot;</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(pile.height)</span><br></pre></td></tr></table></figure>
<p>如果只定义了get而没有定义set，对这个属性的修改操作将被忽略。<br />
除了在定义字面值对象时定义get和set外，还可以通过<code>Object.defineProperty</code>函数来添加get和set，即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(pile, <span class="string">&quot;height&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.elements.length; &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;Ignoring attemp to set height to&quot;</span>, value); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置所有People对象共享的方法</span></span><br><span class="line">People.prototype.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;People Walk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类调用父类方法完成父类属性的构造</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, no</span>)</span>&#123;</span><br><span class="line">  People.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">  <span class="built_in">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类构造函数的prototype属性设置为以父类构造函数prototype为原型的对象</span></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(People.prototype);</span><br><span class="line"><span class="comment">// 设置原型对象的constructor，这是为了和默认实现保持一致，如果你完全不会用到该属性，不设置也没有影响。</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"><span class="comment">// 在子类构造函数的prototype对象上添加和父类构造函数prototype中同名的方法，这样由于已经找到了该方法，就不会继续向上到父类构造函数prototype中查找。即覆盖父类方法。</span></span><br><span class="line">Student.prototype.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Student Walk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="instanceof"><a class="markdownIt-Anchor" href="#instanceof"></a> instanceof</h2>
<p><code>o instanceof func</code>运算符用于检查构造函数<code>func</code>的prototype属性，是否出现在对象<code>o</code>的原型链上。示例实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">o, func</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(o); prototype != <span class="literal">null</span>; prototype = <span class="built_in">Object</span>.getPrototypeOf(prototype))&#123;</span><br><span class="line">    <span class="keyword">if</span>(prototype == func.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this和作用域"><a class="markdownIt-Anchor" href="#this和作用域"></a> this和作用域</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">World</span>(<span class="params">map, legend</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> grid = <span class="keyword">new</span> Grid(map[<span class="number">0</span>].length, map.length);</span><br><span class="line">  <span class="built_in">this</span>.grid = grid;</span><br><span class="line">  <span class="built_in">this</span>.legend = legend;</span><br><span class="line">  map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">line, y</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这个内部函数的this和函数World的this不同</span></span><br><span class="line">    <span class="comment">// 在这个里面你不能通过this.grid访问到对象的属性</span></span><br><span class="line">    <span class="comment">// 只能通过局部变量grid访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; line.length; x++)</span><br><span class="line">      grid.set(<span class="keyword">new</span> Vector(x,y), elementFromChare(legend, line[x]));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法有几种：</p>
<ol>
<li>在外层函数的内部声明<code>var self = this;</code>然后在内部函数使用局部变量<code>self</code>即可。</li>
<li>使用bind绑定一个this对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  prop: <span class="number">10</span>,</span><br><span class="line">  addPropTo: <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.map(<span class="function"><span class="keyword">function</span>(<span class="params">elt</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.prop + elt;</span><br><span class="line">    &#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>一些内置的高阶函数提供了第二个参数用于传递this</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  prop: <span class="number">10</span>,</span><br><span class="line">  addPropTo: <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.map(<span class="function"><span class="keyword">function</span>(<span class="params">elt</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.prop + elt;</span><br><span class="line">    &#125;, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在自己的高阶函数中，使用<code>call</code>来传递this并调用内部函数。</li>
</ol>
<h1 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h1>
<p>在文件或函数顶部放置字符串<code>&quot;use strict&quot;;</code>就可以启用严格模式。<br />
严格模式下，声明变量不添加<code>var</code>会报错。<br />
如果没有将函数作为方法调用，函数中的<code>this</code>会绑定<code>undefined</code>而不是全局对象<code>window</code></p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<p>异常会沿着调用栈上抛，直到得到处理。如果期间没有被捕获，最终会由JavaScript环境处理（例如浏览器）。默认异常构造器<code>Error</code>有<code>name</code>属性保存异常的名字，<code>message</code>属性保存传递进来的字符串，<code>stack</code>属性保存异常创建时的调用栈信息，即堆栈跟踪信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript对选择性捕获异常没有支持，只能要么捕获所有异常，要么一个都不捕获。<br />
一个解决方案是继承默认异常构造器Error，然后在catch块内使用<code>instanceof</code>来判断是哪一种异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputError</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message;</span><br><span class="line">  <span class="comment">// new Error() 那一刻会生成当前的调用栈信息保存在stack中</span></span><br><span class="line">  <span class="built_in">this</span>.stack = (<span class="keyword">new</span> <span class="built_in">Error</span>()).stack;</span><br><span class="line">&#125;</span><br><span class="line">InputError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line">InputError.prototype.name = <span class="string">&quot;InputError&quot;</span>;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> InputError(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> InputError) <span class="built_in">console</span>.log(<span class="string">&quot;Not a valid direction. Try again.&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h2>
<p>用异常实现断言，即：如果与期望的结果不符，就抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AssertionFailed</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line">AssertionFailed.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">test, message</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!test) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionFailed(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastElement</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  assert(array.length &gt; <span class="number">0</span>, <span class="string">&quot;empty array in lastElement&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> array[array.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h1>
<p>在JavaScript中，正则表达式是一个对象类型，要构造正则表达式对象，有两种办法：</p>
<ol>
<li>使用<code>RegExp</code>构造函数，将模式作为字符串传递，<code>var re1 = new RegExp(&quot;abc&quot;);</code></li>
<li>使用斜杠将模式包围起来，<code>var re2 = /abc/;</code></li>
</ol>
<p>字面量：斜杠需要转义，反斜杠不用<br />
构造式：斜杠不用转义，反斜杠需要</p>
<p>取决于表达式里哪种符号比较多，可以交替使用两种方法；<br />
一个例子是，含有斜杠很多的 URL，则用构造式更为可读；<br />
<code>new RegExp('/a/b/c/d')</code> --&gt; <code>/\/a\/b\/c\/d/</code></p>
<p>正则表达式：</p>
<ul>
<li><code>^</code>和<code>$</code>用于表示输入字符串的开始和结束位置。</li>
<li><code>\b</code>表示单词分界位置，即该位置（两个字符之间地方叫位置）前一个字符和后一个字符其中一个是<code>\w</code>，另一个不是<code>\w</code>或者不存在。其等价于<code>(?=\w)(?&lt;!\w)|(?!\w)(?&lt;=\w)</code>。</li>
<li><code>ab|cd</code>匹配模式ab或模式cd，注意<code>|</code>运算符优先级最低，因此<code>^a|b$</code>等价于<code>(^a)|(b$)</code>。加括号<code>a(c|b)d)</code>可以限制管道运算符的范围。</li>
<li><code>+</code>、<code>*</code>、<code>?</code>、<code>&#123;&#125;</code>默认是贪婪的，即尽可能匹配更多的字符。非贪婪匹配需要加问号，即<code>+?</code>、<code>*?</code>、<code>??</code>、<code>&#123;&#125;?</code>，尽可能匹配少的字符。</li>
<li>正则表达式可以添加选项，<code>g</code>表示全局模式，<code>i</code>表示不区分大小写，<code>m</code>表示多行匹配。当使用构造函数时，选项字符串作为第二个参数传递；当使用斜杠时，选项在结尾的斜杠之后直接书写。</li>
<li><code>&#123;n&#125;</code>表示前面一个字符正好出现n次。</li>
<li><code>&#123;n,&#125;</code>表示前面一个字符出现n或更多次。</li>
<li><code>&#123;n, m&#125;</code>表示前面一个字符出现n到m次。</li>
<li><code>(foo)</code>括号是一个捕获组，它也可以在同一个正则表达式中使用<code>\1</code>、<code>\2</code>等来访问它之前的捕获组。</li>
<li>非捕获括号，如果你需要用括号来调整优先级或者进行分组，但又不想捕获它，可以使用费捕获括号<code>(?:foo)</code>，即在普通括号里加上<code>?:</code></li>
<li>具名捕获组，如果你想为分组起一个名字，而不是仅用诸如<code>\1</code>、<code>\2</code>等位置信息来访问捕获组，可以使用<code>(?&lt;Name&gt;foo)</code>，在match()或exec()方法中通过<code>groups.Name</code>属性可以访问到该捕获组。要在同一个正则表达式中访问之前的具名捕获组，可以用<code>/k&lt;Name&gt;</code></li>
<li>先行断言：<code>x(?=y)</code>匹配一个后面跟着<code>y</code>的<code>x</code>，<code>(?=y)</code>和<code>^</code>一样是用于匹配位置的。断言中也可以用管道运算符，例如<code>Jack(?=Sprat|Frost)</code>。又比如<code>(?=y).</code>先匹配一个位置，该位置后面第一个字符是<code>y</code>，然后从该位置开始匹配一个任意字符，因此匹配的必然是<code>y</code>。</li>
<li>正向否定查找：<code>x(?!y)</code>匹配一个后面不跟着<code>y</code>的<code>x</code>。<code>(?!y)</code>和<code>^</code>一样是用于匹配位置的。一种特殊用法是匹配不包含某个子串的文本，<code>^(?!.*bug)</code>站在开头，后面不跟着任意字符加<code>bug</code>。</li>
<li>后行断言：<code>(?&lt;=y)x</code>匹配前面有一个<code>y</code>的<code>x</code>，<code>(?&lt;=y)</code>和<code>^</code>一样是用于匹配位置的，背后工作过程中它会先找到<code>y</code>然后左移到该位置。</li>
<li>反向否定查找：<code>(?&lt;!y)x</code>匹配前面不是<code>y</code>的<code>x</code>，<code>(?&lt;!y)x</code>和<code>^</code>一样是用于匹配位置的。</li>
<li>模式<code>y</code>表示粘滞匹配，类似<code>g</code>，它也会更新<code>lastIndex</code>进而实现多次匹配。但它会为正则表达式隐式的加上<code>^</code>，显式的<code>^</code>是表示整个文本串的开头，但粘滞匹配模式隐式添加的<code>^</code>表示<code>lastIndex</code>开始的串的开头。<code>let re=/a/g, re2=/a/y, re3=/^a/y; re.exec(&quot;aabb&quot;)</code>。</li>
</ul>
<p>正则表达式对象有下列方法：</p>
<ul>
<li><code>Reg.test(str)</code>：检查字符串<code>str</code>是否包含匹配正则表达式的子串，包含则返回true否则返回false</li>
<li><code>Reg.exec(str)</code>：无法匹配模式返回null，否则返回一个标识匹配字符串信息的对象，该对象包含<code>index</code>属性标识字符串成功匹配的起始位置，<code>0</code>属性表示匹配的全部字符串，<code>1</code>、<code>2</code>属性等表示括号中的分组捕获，<code>1</code>是第一个左圆括号开始到结束，<code>2</code>是第二个左圆括号开始到结束。在全局匹配<code>g</code>的情况下，当成功匹配模式后，会更新正则表达式对象的<code>lastIndex</code>属性，指向匹配字符串后的位置，若无法匹配则将<code>lastIndex</code>置为0。多次调用<code>exec</code>时，会从上一次的<code>lastIndex</code>位置开始查找（注意仅当<code>g</code>模式才有效）。它用于找到全局模式下的所有捕获组，例如<code>re=/\d+/g; re.exec(&quot;123-456-789&quot;)</code>，该方法每次执行只能返回一个捕获组，而下一次调用才会返回下一个捕获组。</li>
</ul>
<p>字符串也有使用正则进行匹配的方法：</p>
<ul>
<li><code>Str.match(Reg)</code>：非<code>g</code>模式下类似<code>Reg.exec</code>，但在<code>g</code>模式下，它返回的是一个数组，该数组的元素是每次调用<code>Reg.exec(Str)</code>后数组0位置的内容（即完全匹配），不会像非全局模式那样返回一个标识匹配字符串信息的对象。</li>
<li><code>Str.replace(Reg, &quot;m $2 $1&quot;)</code>：将匹配正则表达式的串替换为第二个参数中的字符串。如果加上<code>g</code>选项则替换所有匹配项，而不是只替换第一个。替换字符串<code>$2</code>表示第二个圆括号分组，也可以使用具名捕获组<code>$&lt;Name&gt;</code></li>
<li><code>Str.replace(Reg, func(str))</code>：每次匹配时都会调用函数，并以匹配的分组的字符串作为参数，函数需要返回用来替换的字符串。函数也可以有不止一个参数，会将每次匹配的分组<code>$1</code>、<code>$2</code>等传递进去。</li>
<li><code>Str.search(Reg)</code>：返回首先匹配正则表达式的串的起始位置，如果没有则返回-1</li>
</ul>
<h1 id="日期"><a class="markdownIt-Anchor" href="#日期"></a> 日期</h1>
<p>JavaScrip提供了用于表示日期的标准对象类型<code>Date</code>。约定月份从数字0开始，年份、日期、时间等正常表示。</p>
<ul>
<li><code>new Date()</code>：创建一个表示当前日期和时间的对象</li>
<li><code>new Date(2009, 11, 9)</code>创建一个表示指定日期的对象，时间默认为0。</li>
<li><code>new Date(2009, 11, 9, 12, 59, 59, 999);</code>创建一个表示指定日期和时间的对象。</li>
<li><code>new Date(2013, 11, 19).getTime()</code>返回从1970年1月1日至今的毫秒数，如果在1970年之前则是负数。</li>
<li><code>new Date(2013)</code>创建一个表示从1970年1月1日起经过2013毫秒的日期和时间对象。</li>
<li><code>Date.now()</code>返回当前日期和时间对应的毫秒数，等价于<code>new Date().getTime()</code></li>
<li><code>date.getFullYear()</code>返回完整年份</li>
<li><code>date.getMonth()</code>返回月份（从0开始）</li>
<li><code>date.getDate()</code>返回日子</li>
<li><code>date.getHours()</code>返回小时</li>
<li><code>date.getMinutes()</code>返回分钟</li>
<li><code>date.getSeconds()</code>返回秒</li>
</ul>
<h1 id="将字符串作为代码执行"><a class="markdownIt-Anchor" href="#将字符串作为代码执行"></a> 将字符串作为代码执行</h1>
<p>使用eval函数，可以在当前作用域执行代码字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalAndReturnX</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(code);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(evalAndReturnX(<span class="string">&quot;var x = 2&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>另一种办法是使用<code>Function</code>构造函数来解释代码。该函数接受两个参数，第一个参数是要构造的函数的参数字符串，各参数之间以逗号分隔；第二个参数是包含函数体的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;n&quot;</span>, <span class="string">&quot;return n + 1;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(plusOne(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p>或者接受多个参数，最后一个参数是包含函数体的字符串，前面每个参数都是参数字符串。每个参数字符串中的参数以逗号分隔。</p>
<h1 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h1>
<p>大多数现代程序设计语言在全局作用域（任何地方都能访问）和局部作用域（只有函数内部才能访问）之间设定了其他级别的作用域，而JavaScript则没有。<br />
尽管JavaScript没有直接提供语言特性来支持模块，我们可以使用对象来创建可以公开访问的子命名空间，也可以使用函数来创建独立的、私有的模块内部命名空间。<br />
我们应该将自身独立的部分功能放置到独立的文件和模块中，以便于追踪、更新和共享代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> white_space = <span class="regexp">/\s/gi</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 暴露出去的接口，外部是无法访问sum和white_space的</span></span><br><span class="line">    <span class="comment">// 但内部可以</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>A.B.C<br />
修改BUG改C<br />
没有改变现有接口改B<br />
修改了改A</p>
<p>IIFE<br />
Immediately invoked Function Expression<br />
立即执行函数表达式</p>
<h2 id="函数作为命名空间"><a class="markdownIt-Anchor" href="#函数作为命名空间"></a> 函数作为命名空间</h2>
<p>在JavaScript中，我们只能使用函数来创建新的作用域。<br />
第一版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">             <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dayName</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names[number];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法的缺点是<code>names</code>变量被暴露出来了。修改如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names[number];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>把私有变量放在立即执行的一个匿名函数中，该匿名函数返回我们所需的函数。<br />
注意，作为右值的立即执行函数表达式不需要加括号，但作为独立表达式时需要加括号，以与函数定义语句区分开。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="多个函数的模块"><a class="markdownIt-Anchor" href="#多个函数的模块"></a> 多个函数的模块</h2>
<p>当一个模块中需要有多个函数时，上述写法中直接返回函数就不合适了，必须使用一个对象将这两个函数封装起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> weekDay = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123; <span class="keyword">return</span> names[number]; &#125;,</span><br><span class="line">    number: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="keyword">return</span> names.indexOf(name); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">console</span>.log(weekDay.name(weekDay.number(<span class="string">&quot;Sunday&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>为了处理可能的互相调用的情况，更好的写法是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> weekDay = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names[number];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">number</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.indexOf(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    number: number,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>或者为了便于知道哪些函数是暴露出去的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> weekDay = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names[number];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.name = name;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">number</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.indexOf(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.number = number;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exports</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>当代码比较多时，可能需要将函数定义在预先定义的对象中，而不是像上述代码一样每次创建一个空对象再添加函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line">  <span class="built_in">exports</span>.name = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names[number];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">exports</span>.number = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.indexOf(name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">this</span>.weekDay = &#123;&#125;); <span class="comment">// 给全局作用域对象创建一个weekDay对象，非必需</span></span><br><span class="line"><span class="built_in">console</span>.log(weekDay.name(weekDay.number(<span class="string">&quot;Saturday&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>用于持有导出函数的对象叫做接口对象。<br />
依赖关系是一个树状结构，你的脚本依赖于其他诸多模块，而每个这些模块又各自依赖于其他模块。</p>
<h2 id="commonjs模块"><a class="markdownIt-Anchor" href="#commonjs模块"></a> CommonJS模块</h2>
<p>供浏览器使用的JavaScript模块通常使用这种办法来组织代码，模块声明了一个全局变量，并将其包裹在一个函数中，保证其私有的命名空间。但若多个模块恰好使用了相同名字，或开发者想同时加载两个版本的模块时，这种模式就不再适用了。<br />
我们可以换种思路来实现模块，这种模块可以直接调用其他模块的接口对象，而无需访问全局作用域。我们准备构造一个<code>require</code>函数，调用该函数时指定一个模块名称，该函数会加载模块文件，并返回合适的接口对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// readFile是一个从文件中读取字符串的函数</span></span><br><span class="line">  <span class="comment">// 可以考虑用ajax，当然这样必须是在服务器上而不能在本机</span></span><br><span class="line">  <span class="keyword">var</span> code = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;exports&quot;</span>, readFile(name));</span><br><span class="line">  <span class="comment">/* 等价于</span></span><br><span class="line"><span class="comment">    var code = function(exports)&#123;</span></span><br><span class="line"><span class="comment">      文件内容</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">  code(<span class="built_in">exports</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exports</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    另一种实现是 return code(exports)</span></span><br><span class="line"><span class="comment">    但这就要求模块必须有返回语句，而不能仅仅将函数挂在exports对象上</span></span><br><span class="line"><span class="comment">    如果模块有时有返回语句，有时挂在exports对象上，可以这样写</span></span><br><span class="line"><span class="comment">    var moduleVal = code(exports);</span></span><br><span class="line"><span class="comment">    如果没有返回语句返回值是undefined</span></span><br><span class="line"><span class="comment">    return moduleVal || exports;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> weekDay = <span class="built_in">require</span>(<span class="string">&quot;weekDay&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weekDay.name(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>此时的模块文件内部就不需要再编写命名空间函数了，即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">             <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line"><span class="built_in">exports</span>.name = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names[number];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.number = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.indexOf(name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面<code>require</code>函数的简单实现存在一些问题：</p>
<ol>
<li>每次调用<code>require</code>时，该函数都会加载模块。如果有许多模块里也<code>require</code>了相同的依赖，则会有很多不必要的重复调用，浪费大量时间和空间。<br />
要解决这个问题，我们可以将装载后的模块存储在一个对象中，如果重复装载该模块则直接将存储的值返回。</li>
<li>模块只能导出<code>exports</code>（因为require函数为模块封装的函数硬编码了名为exports参数），而无法直接导出其他值。例如一个模块可能只想导出其定义的对象类型的构造函数。<br />
要解决这个问题，我们可以向模块提供另一个<code>module</code>变量，该变量有一个属性<code>exports</code>，<code>reuqire</code>函数使用一个空对象初始化<code>exports</code>属性，而模块如果想导出一个其他值而不一定是对象，则可以覆盖<code>exports</code>属性。<br />
另一种解决方案是将导出的内容放在<code>exports.value</code>中（即<code>exports</code>起到了<code>module</code>的作用，但书写时比较长，例如<code>exports.value.name</code>，所以就用上面的方法）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(name <span class="keyword">in</span> <span class="built_in">require</span>.cache)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>.cache[name];</span><br><span class="line">  <span class="keyword">var</span> code = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;exports, module&quot;</span>, readFile(name));</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;, <span class="built_in">module</span> = &#123;<span class="attr">exports</span>: <span class="built_in">exports</span>&#125;;</span><br><span class="line">  code(<span class="built_in">exports</span>, <span class="built_in">module</span>);</span><br><span class="line">  <span class="built_in">require</span>.cache[name] = <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这种风格的模块被命名为CommonJS模块，在Node.js中的实现和这种类似，但复杂的多。</p>
<p>注意：等号左边永远不要是<code>exports</code>，应该用<code>module.exports</code></p>
<p>如果模块在文件夹内，一个模块引用其他模块时我们希望引用地址是相对于当前文件夹的，而现在的写法只能相对于require函数所在路径。<br />
为此，可以给构造的函数增加第三个参数require，即给每个模块单独创建一个require函数。<br />
同时给require函数增加一个路径参数。每个模块都通过bind绑定模块的路径，得到一个和原来一样只接受一个参数的函数。<br />
？？这是如何保证文件夹路径参数是对的？</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>模块编写者如果要提供公有接口，将函数挂在<code>module.exports</code>对象上，<code>module.exports</code>对象是<code>require</code>函数返回的内容。如果不想返回这个对象，就覆盖<code>module.exports</code>属性。</p>
<p><code>require</code>函数的实现需要注意：<br />
要获取模块的代码文本，通过代码文本构造一个接受<code>exports</code>和<code>module</code>的函数。<br />
创建一个<code>module = &#123;exports: &#123;&#125;&#125;</code>对象，将其作为参数传递给构造的函数，用于模块提供公有API。<br />
返回<code>module.exports</code>。<br />
注意，已经<code>require</code>过的模块返回的内容是相同的，所以不必重复请求，只需要保存起来，只有在找不到模块时才需要去请求。<br />
如果要处理相对路径，即模块编写者在<code>require</code>时使用相对于模块目录的路径，而非相对于<code>require</code>函数定义的路径。</p>
<p><code>require</code>函数接受一个要请求的文件的路径参数，所以<code>require</code>函数知道本次要请求的模块文件所在位置。在<code>require</code>函数中<code>f(module.exports, module)</code>用于执行模块代码，在模块代码中为<code>require</code>传递的路径是相对于模块所在目录的（这个信息已知），如果要让模块代码知道自己的路径，可以通过<code>f</code>的参数传递，例如<code>f(module.exports, module, pwd)</code>，然后就可以根据自己的路径以及相对路径拼起来完整路径。<br />
更好的实现是根据<code>pwd</code>生成不同的<code>require</code>函数，每个模块代码访问到的都是已经绑定了<code>pwd</code>的<code>require</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;get&quot;</span>, path, <span class="literal">false</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="keyword">return</span> xhr.responseText;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">normalizePath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数的作用是将形如/weekday/123/.././a.js的地址</span></span><br><span class="line">    <span class="comment">// 转换为/weekday/a.js</span></span><br><span class="line">    <span class="keyword">var</span> component = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> newComponent = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; component.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(component[i] == <span class="string">&quot;..&quot;</span>) newComponent.pop();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(component[i] == <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> newComponent.push(component[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newComponent.join(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">pwd, relpath</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，bind的写法导致无法访问cache了</span></span><br><span class="line">    <span class="keyword">var</span> fullPath = normalizePath(pwd + relpath);</span><br><span class="line">    <span class="comment">// if(require.cache[fullPath]) return require.cache[fullPath];</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">require</span>.cache[fullPath]) <span class="keyword">return</span> <span class="built_in">require</span>.cache[fullPath].exports;</span><br><span class="line">    <span class="keyword">var</span> code = readFile(fullPath);</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;exports, module, require&quot;</span>, code);</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">    <span class="keyword">let</span> bindRequire = <span class="built_in">require</span>.bind(<span class="literal">null</span>, fullPath.slice(<span class="number">0</span>, fullPath.lastIndexOf(<span class="string">&quot;/&quot;</span>)+<span class="number">1</span>));</span><br><span class="line">    bindRequire.cache = <span class="built_in">require</span>.cache;</span><br><span class="line">    <span class="comment">// require.cache[fullPath] = module.exports; // b.如果这一步先执行就可以解决循环引用</span></span><br><span class="line">    <span class="built_in">require</span>.cache[fullPath] = <span class="built_in">module</span>;</span><br><span class="line">    f(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, bindRequire); <span class="comment">// a.这一步在执行模块的所有代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="comment">// 创建一个没有原型的对象</span></span><br><span class="line">  <span class="built_in">window</span>.require = <span class="built_in">require</span>.bind(<span class="literal">null</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> weekday = <span class="built_in">require</span>(<span class="string">&quot;./weekday/weekday.js&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weekday.name(weekday.number(<span class="string">&quot;Sunday&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>对于循环引用，关键是保证在循环引用那一刻能够拿到缓存。先保存<code>module</code>后执行模块代码就可以解决这个问题，但有一定的限制：</p>
<ul>
<li>模块不能替换<code>module.exports</code>对象。因为a-&gt;b-&gt;c-&gt;a时，c获取到的是还没有完成加载的a的<code>module.exports</code>，它是一个对象。c只能拿到这个对象以及在这个对象上的修改，无法拿到a之后修改的<code>module.exports</code>。</li>
<li>模块必须保证在装载完成后才互相访问接口。如果在之前就访问接口，获取到的<code>module.exports</code>是还没有加载接口的空对象。</li>
</ul>
<p>异步加载依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  本质上是希望填充完codeCache，如果将最终对象直接作为JSON给它呢？</span></span><br><span class="line"><span class="comment">  即将所有依赖代码打包成一个，那么根本不需要异步加载。</span></span><br><span class="line"><span class="comment">  下面的代码可以转变为构建打包的代码，从本地读取文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadModuleAndAllItsDeps</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(path <span class="keyword">in</span> codeCache) &#123; <span class="comment">// 避免无限递归</span></span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  codeCache[path] = <span class="string">&quot;loading&quot;</span>; <span class="comment">// 防止还没请求完代码又有依赖发请求</span></span><br><span class="line">  <span class="comment">// callback何时执行？所有依赖都加载完成。</span></span><br><span class="line">  <span class="comment">// 异步代码本质上是条件，如果满足条件，则执行函数</span></span><br><span class="line">  readFile(path, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123; <span class="comment">// 加载文件path</span></span><br><span class="line">    codeCache[path] = code; <span class="comment">// 缓存path代码</span></span><br><span class="line">    <span class="keyword">var</span> deps = getDeps(code); <span class="comment">// 分析path代码找出所有依赖路径</span></span><br><span class="line">    <span class="keyword">if</span> (deps.length == <span class="number">0</span>) &#123; <span class="comment">// 如果没有依赖直接执行回调</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果有依赖等待所有依赖加载完执行回调</span></span><br><span class="line">      <span class="keyword">var</span> loaded = <span class="number">0</span>; <span class="comment">// 计数依赖加载完成的情况</span></span><br><span class="line">      deps.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">dep</span>)</span>&#123; <span class="comment">// 加载每一个依赖文件</span></span><br><span class="line">        loadModuleAndAllItsDeps(dep, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 此时已加载完成此子依赖</span></span><br><span class="line">          loaded++;</span><br><span class="line">          <span class="comment">// 如果是最后一个子依赖</span></span><br><span class="line">          <span class="keyword">if</span>(loaded == deps.length) &#123;</span><br><span class="line">            callback();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">pwd, relpath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注意，bind的写法导致无法访问cache了</span></span><br><span class="line">  <span class="keyword">var</span> fullPath = normalizePath(pwd + relpath);</span><br><span class="line">  <span class="comment">// if(require.cache[fullPath]) return require.cache[fullPath];</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">require</span>.cache[fullPath]) <span class="keyword">return</span> <span class="built_in">require</span>.cache[fullPath].exports;</span><br><span class="line">  <span class="keyword">var</span> code = codeCache[fullPath];</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;exports, module, require&quot;</span>, code);</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">  <span class="keyword">let</span> bindRequire = <span class="built_in">require</span>.bind(<span class="literal">null</span>, fullPath.slice(<span class="number">0</span>, fullPath.lastIndexOf(<span class="string">&quot;/&quot;</span>)+<span class="number">1</span>));</span><br><span class="line">  bindRequire.cache = <span class="built_in">require</span>.cache;</span><br><span class="line">  <span class="comment">// require.cache[fullPath] = module.exports; // b.如果这一步先执行就可以解决循环引用</span></span><br><span class="line">  <span class="built_in">require</span>.cache[fullPath] = <span class="built_in">module</span>;</span><br><span class="line">  f(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, bindRequire); <span class="comment">// a.这一步在执行模块的所有代码</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> codeCache = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> entry = <span class="string">&quot;a.js&quot;</span> <span class="comment">// 入口文件</span></span><br><span class="line">loadModuleAndAllItsDeps(entry, <span class="built_in">require</span>(entry))</span><br></pre></td></tr></table></figure>
<p>实现了模块系统在浏览器中也无法很好的使用，因为大量小文件加载很慢，即便是异步加载，在加载完成前模块代码也无法工作，这就意味着页面中的交互与事件等很长时间都无法使用。<br />
因此更可用的方法是将代码打包为一个文件，这个文件包括了codeCache和require函数。<br />
vecdor.js中一般是各种第三方库的打包<br />
app.js中一般是自己的代码的打包</p>
<p>ES6中提供了导入导出语法，和使用require实现的异步加载的机制类似。webpack打包时会将这些语句转换为require版本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入a.js的默认导出，放到变量b中</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span> <span class="comment">// 类似require</span></span><br><span class="line"><span class="comment">// 将a.js的具名导出a和b放到变量a和b中，这里无法自定义变量名</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="comment">// 要想自定义变量可以用as</span></span><br><span class="line"><span class="keyword">import</span> &#123; a <span class="keyword">as</span> aa, b <span class="keyword">as</span> bb &#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="comment">// 同时导入默认导出和具名导出</span></span><br><span class="line"><span class="keyword">import</span> c, &#123;a, b&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="comment">// 将foo.js的所有导出导入到foo变量</span></span><br><span class="line"><span class="comment">// 其中foo.default为默认导出，foo.导出名 为具名导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span></span><br><span class="line"><span class="comment">// 如果包提供了ES6版的导出，并且允许跨域则可以</span></span><br><span class="line"><span class="keyword">import</span> jQuery <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/jquery?module&#x27;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  通过import创建的变量相当于用const声明的变量</span></span><br><span class="line"><span class="comment">  实际上它和导出对象是同一个引用，相当于C++的引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 默认导出(唯一的)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125; <span class="comment">// 类似module.exports = &#123;x:1,y:2&#125;</span></span><br><span class="line"><span class="comment">// 具名导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">8</span>; <span class="comment">// 直接声明变量来导出</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; b, c &#125; <span class="comment">// 导出已声明的变量</span></span><br></pre></td></tr></table></figure>
<h2 id="异步模块定义"><a class="markdownIt-Anchor" href="#异步模块定义"></a> 异步模块定义</h2>
<p>当在浏览器中运行脚本时，浏览器不会做其他任何事情，由于每次<code>require</code>都需要从网络获取代码，在加载脚本时网页会很长时间没有响应。<br />
一种解决办法时使用一些工具，将代码中所有<code>require</code>调用替换为实际代码，然后合成一个大文件，网站只需要加载一次这个大文件即可。<br />
另一种解决办法是将你自己的模块放在一个函数中，模块装载器首先在后台装载自身依赖，当其他依赖加载完成后再调用函数初始化模块。<br />
使用模块的方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&quot;weekDay&quot;</span>, <span class="string">&quot;today&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">weekDay, today</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(weekDay.name(today.dayNumber()));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>define</code>的第一个参数是所依赖的模块的名字的数组，第二个参数是一个函数，该函数的每个参数代表一个依赖模块。<code>define</code>函数会在后台装载依赖（如果已经装载过则不再装载），在获取模块文件的同时，网页也可以继续运行。一旦依赖装载完成，<code>define</code>会调用我们指定的函数，并将这些依赖模块作为参数传递给该函数。<br />
由于模块自身也可以依赖其他模块，因此模块也要用<code>define</code>的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">               <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>];</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123; <span class="keyword">return</span> names[number]; &#125;,</span><br><span class="line">    number: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="keyword">return</span> names.indexOf(name); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了展示如何实现简单的<code>define</code>函数，假设有一个<code>backgroundReadFile</code>函数，该函数接受两个参数，第一个参数是文件名，第二个参数是另一个函数。<code>backgroundReadFile</code>函数会加载文件内容，加载完成后立即执行参数中指定的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defineCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> currentMod = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getModule</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(name <span class="keyword">in</span> defineCache) <span class="keyword">return</span> defineCache[name];</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: <span class="literal">null</span>,</span><br><span class="line">                 loaded: <span class="literal">false</span>,</span><br><span class="line">                 onLoad: []&#125;;</span><br><span class="line">  defineCache[name] = <span class="built_in">module</span>;</span><br><span class="line">  backgroundReadFile(name, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 文件加载完成</span></span><br><span class="line">    currentMod = <span class="built_in">module</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;&quot;</span>, code)(); <span class="comment">// 又进入了一个define()</span></span><br><span class="line">    <span class="comment">// 直接执行code代码[内含define()]，用无参数的匿名函数包裹</span></span><br><span class="line">    <span class="comment">// 为什么不用eval？</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">depNames, moduleFunction</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 每次调用define，都保存一次currentMod</span></span><br><span class="line">  <span class="comment">// 之后currentMod虽然在变，但该函数内此前保存成myMod的currentMod不会变。</span></span><br><span class="line">  <span class="keyword">var</span> myMod = currentMod;</span><br><span class="line">  <span class="keyword">var</span> deps = depNames.map(getModule);</span><br><span class="line">  deps.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mod.loaded) mod.onLoad.push(whenDepsLoaded);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">whenDepsLoaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 任何一个模块的loaded不为true则直接退出函数</span></span><br><span class="line">    <span class="comment">// 空列表会返回true</span></span><br><span class="line">    <span class="keyword">if</span>(!deps.every(<span class="function"><span class="title">funciton</span>(<span class="params">m</span>)</span> &#123; <span class="keyword">return</span> m.loaded; &#125;)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 每个模块的loaded都为true</span></span><br><span class="line">    <span class="keyword">var</span> args = deps.map(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123; <span class="keyword">return</span> m.exports; &#125;);</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">exports</span> = moduleFunction.apply(<span class="literal">null</span>, args);</span><br><span class="line">    <span class="keyword">if</span>(myMod) &#123; <span class="comment">// 如果myMod不为null，它就是当前正在加载的那个模块</span></span><br><span class="line">      myMod.exports = <span class="built_in">exports</span>;</span><br><span class="line">      myMod.loaded = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 执行每个onLoad里的whenDepsLoaded</span></span><br><span class="line">      myMod.onLoad.every(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; f(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  whenDepsLoaded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接口设计"><a class="markdownIt-Anchor" href="#接口设计"></a> 接口设计</h1>
<p>模块和对象类型的接口设计是非常细致的任务，我们有很多不同的方法来封装大段功能和代码，但想找出一种合适的封装方式，就需要依靠开发人员的洞察力和远见。<br />
要设计出优秀的接口，最好的办法就是去使用各种各样的接口，这其中有好的设计，也有不好的设计，经验是最好的老师。不要放任设计不好的接口，修正它们，或者将其封装成一个更易于你使用的接口。<br />
可以参照三个准则：</p>
<ul>
<li>可预测性：如果有另一个模块或标准JavaScript环境中的一部分设计与你的实现非常相似，比较好的方式是模仿已有接口来设计你的模块接口。这样对于熟悉旧有模块接口的人来说，可以很快熟悉你的模块接口。</li>
<li>可组合性：在你的接口中，尝试使用最简单的数据结构，尝试使用函数完成单一明确的任务。只要可行，最好将接口设计为纯函数（无副作用如console.log）。例如模块常常提供类似于数组的集合对象，用它们自有接口计算元素数量并提取特定元素。这类对象并不包含map或forEach方法，以及真实数组应该包含的所有函数，这就是一个不好的组合案例，开发人员无法轻松将模块与其他代码组合起来。</li>
<li>层次化接口：在设计复杂功能的接口时，经常会遇到进退两难的情况，比如设计发送电子邮件的接口。一方面，你不想让用户通过接口了解太多细节，他们没必要在发送邮件之前花费20分钟来学习你设计的接口；另一方面，你又不希望隐藏过多细节，人们可以使用你的模块完成复杂功能。此时的解决方案往往是提供两种接口：为复杂状况准备的详细接口，以及为日常使用准备的高层次接口。第二类接口往往可以通过使用第一类接口轻松构建出来。</li>
</ul>
<h1 id="浅深拷贝与对比"><a class="markdownIt-Anchor" href="#浅深拷贝与对比"></a> 浅深拷贝与对比</h1>
<p>浅拷贝：碰见引用类型，直接指向该引用<br />
深拷贝：碰见引用类型，创建一个新的引用类型使它的各属性与前者相等。<br />
浅对比：碰见引用类型，直接判断它们是不是同一个对象<br />
深对比：碰见引用类型，判断它们的各属性值是否相等。</p>
<p><code>Array.includes(val)</code>数组中是否包含某个元素<br />
String.prototype.substring(start, end)，如果任一参数是NaN或负数，则被0替代，如果任一参数大于字符串长度，则被字符串长度替代。<br />
String.prototype.slice(start, end)，如果任一参数是负数，就把替换为该值加上字符串长度。<br />
String.prototype.substr(start, length)</p>
<h1 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h1>
<p>词法作用域（lexical scope）是在书写代码或者说定义时确定的，而动态作用域（dynamic scope）是在运行时确定的。 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用，其作用域链是基于运行时的调用栈的。</p>
<p>对于同一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);	<span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>词法作用域输出2，<br />
动态作用域输出3。</p>
<p>词法作用域(lexical scope)等同于静态作用域(static scope)。所谓的词法作用域其实是指作用域在词法解析阶段既确定了，不会改变。eval 和 with可以产生伪动态作用域的效果（在JS中实际上是将词法环境改变为传递进来的词法环境）。比如 with(o) { console.log(x) } 这个x实际有可能是 o.x 。</p>
<h1 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h1>
<p>闭包本身是允许你在内部作用域得以访问外部作用域变量的特权，并且不一定要以返回函数来表现，但必须由函数包裹。（但当你以函数返回，向外暴露时，就可以使得外部环境访问内部变量）</p>
<p>闭包：函数可以访问他被创建时所处的上下文环境，这被称为闭包。</p>
<p>内部function会close-over外部function的变量直到内部function结束</p>
<p>inner function 可以不用申明、不用传参、直接使用上级作用域里的已存在的变量…同时被使用到的变量生命周期会延续到inner function的生命周期上，并且随其解除引用而销毁。</p>
<h1 id="es6类与继承"><a class="markdownIt-Anchor" href="#es6类与继承"></a> ES6类与继承</h1>
<p><a target="_blank" rel="noopener" href="http://caibaojian.com/es6/class.html">http://caibaojian.com/es6/class.html</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  code = <span class="number">123</span>; <span class="comment">// 实例变量</span></span><br><span class="line">  <span class="keyword">static</span> test = <span class="number">1234</span>; <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="comment">// 自动严格模式</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 只能通过new 调用</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 不加function，自动定义在Person.prototype上面</span></span><br><span class="line">    <span class="comment">// 自动不可枚举</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不加逗号</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123; <span class="comment">// getter方法是定义在对象上的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getClass</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 不能通过实例对象调用</span></span><br><span class="line">    <span class="comment">// 只能通过Person.getClass()调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">no, name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// 如果显式定义了构造函数，必须调父类构造方法，且必须在使用this之前</span></span><br><span class="line">    <span class="built_in">this</span>.no = no;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class被实现为一个函数，类方法被转为原型对象上的方法。</p>
<h1 id="temp"><a class="markdownIt-Anchor" href="#temp"></a> temp</h1>
<p>箭头函数的this是词法作用域<br />
<code>f.bind</code>生成的函数f2，使用new关键字得到的对象其原型是<code>f.prototype</code>而不是<code>f2.prototype</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.children = [];</span><br><span class="line">&#125;</span><br><span class="line">Node.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.startTag + <span class="built_in">this</span>.children.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc, elem</span>)</span>&#123; <span class="keyword">return</span> acc + elem.toString(); &#125;, <span class="string">&quot;&quot;</span>) + <span class="built_in">this</span>.endTag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Table</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Node.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.headerIndex = &#123;&#125;;</span><br><span class="line">  <span class="built_in">this</span>.headerNum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.tbody = <span class="keyword">new</span> TBody();</span><br><span class="line">  <span class="built_in">this</span>.children.push(<span class="built_in">this</span>.tbody);</span><br><span class="line">&#125;</span><br><span class="line">Table.prototype = <span class="built_in">Object</span>.create(Node.prototype);</span><br><span class="line">Table.prototype.constructor = Table;</span><br><span class="line">Table.prototype.startTag = <span class="string">&quot;&lt;table&gt;&quot;</span>;</span><br><span class="line">Table.prototype.endTag = <span class="string">&quot;&lt;/table&gt;&quot;</span>;</span><br><span class="line">Table.prototype.addHeader = <span class="function"><span class="keyword">function</span>(<span class="params">header</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">this</span>.thead) &#123;</span><br><span class="line">    <span class="built_in">this</span>.thead = <span class="keyword">new</span> THead();</span><br><span class="line">    <span class="keyword">let</span> tr = <span class="keyword">new</span> Tr();</span><br><span class="line">    <span class="built_in">this</span>.thead.children.push(tr);</span><br><span class="line">    <span class="built_in">this</span>.children.unshift(<span class="built_in">this</span>.thead);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.headerIndex[header] = <span class="built_in">this</span>.headerNum++;</span><br><span class="line">  <span class="built_in">this</span>.thead.children[<span class="number">0</span>].children.push(<span class="keyword">new</span> Th(header));</span><br><span class="line">&#125;</span><br><span class="line">Table.prototype.getHeaderIndex = <span class="function"><span class="keyword">function</span>(<span class="params">header</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="built_in">this</span>.headerIndex[header];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> index !== <span class="string">&quot;undefined&quot;</span>? index : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Table.prototype.addRow = <span class="function"><span class="keyword">function</span>(<span class="params">tr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.tbody.children.push(tr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">THead</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Node.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">THead.prototype = <span class="built_in">Object</span>.create(Node.prototype);</span><br><span class="line">THead.prototype.constructor = THead;</span><br><span class="line">THead.prototype.startTag = <span class="string">&quot;&lt;thead&gt;&quot;</span>;</span><br><span class="line">THead.prototype.endTag = <span class="string">&quot;&lt;/thead&gt;&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TBody</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Node.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">TBody.prototype = <span class="built_in">Object</span>.create(Node.prototype);</span><br><span class="line">TBody.prototype.constructor = TBody;</span><br><span class="line">TBody.prototype.startTag = <span class="string">&quot;&lt;tbody&gt;&quot;</span>;</span><br><span class="line">TBody.prototype.endTag = <span class="string">&quot;&lt;/tbody&gt;&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Node.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Tr.prototype = <span class="built_in">Object</span>.create(Node.prototype);</span><br><span class="line">Tr.prototype.constructor = Tr;</span><br><span class="line">Tr.prototype.startTag = <span class="string">&quot;&lt;tr&gt;&quot;</span>;</span><br><span class="line">Tr.prototype.endTag = <span class="string">&quot;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">Tr.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">index, elem</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.children[index] = elem;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.children[i])</span><br><span class="line">      <span class="built_in">this</span>.children[i] = <span class="keyword">new</span> Td(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Th</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  Node.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">if</span>(text) <span class="built_in">this</span>.children.push(text);</span><br><span class="line">&#125;</span><br><span class="line">Th.prototype = <span class="built_in">Object</span>.create(Node.prototype);</span><br><span class="line">Th.prototype.constructor = Th;</span><br><span class="line">Th.prototype.startTag = <span class="string">&quot;&lt;th&gt;&quot;</span>;</span><br><span class="line">Th.prototype.endTag = <span class="string">&quot;&lt;/th&gt;&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Td</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  Node.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">if</span>(text) <span class="built_in">this</span>.children.push(text);</span><br><span class="line">&#125;</span><br><span class="line">Td.prototype = <span class="built_in">Object</span>.create(Node.prototype);</span><br><span class="line">Td.prototype.constructor = Td;</span><br><span class="line">Td.prototype.startTag = <span class="string">&quot;&lt;td&gt;&quot;</span>;</span><br><span class="line">Td.prototype.endTag = <span class="string">&quot;&lt;/td&gt;&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objArr2HTML</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> table = <span class="keyword">new</span> Table();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> tr = <span class="keyword">new</span> Tr();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> arr[i])&#123;</span><br><span class="line">      <span class="keyword">let</span> index = table.getHeaderIndex(key);</span><br><span class="line">      <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">        table.addHeader(key);</span><br><span class="line">        index = table.getHeaderIndex(key);</span><br><span class="line">      &#125;</span><br><span class="line">      tr.insert(index, <span class="keyword">new</span> Td(arr[i][key]));</span><br><span class="line">    &#125;</span><br><span class="line">    table.addRow(tr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> table.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>new.target</code>检测构造函数是否是通过new调用的</p>
<p>对于参数前面是不定个，最后固定的，可以这样获取：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArg = args.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw <span class="string">`\\\`</span></span><br></pre></td></tr></table></figure>
<p>会以后面的内容作为参数调用前面的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">13</span></span><br><span class="line">a = <span class="string">`abc<span class="subst">$&#123;x&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<p>花括号语法，类似Shell中的，可以书写表达式</p>
<p>计时器<br />
计时器是以参数字符串来区分的，time方法和timeLog、timeEnd方法中的参数需要一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.time(&quot;answer time&quot;);</span><br><span class="line">alert(&quot;Click to continue&quot;);</span><br><span class="line">console.timeLog(&quot;answer time&quot;);</span><br><span class="line">alert(&quot;Do a bunch of other stuff...&quot;);</span><br><span class="line">console.timeEnd(&quot;answer time&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="分号"><a class="markdownIt-Anchor" href="#分号"></a> 分号</h1>
<p>分号可加可不加，可以按照C与Java的写法加分号，也可以全部不加分号（例外是以下面六个字符开头的情况，可以在这六个字符前面加分号以中断之前的语句）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;(</span><br><span class="line">;[</span><br><span class="line">;&#96;</span><br><span class="line">;+</span><br><span class="line">;-</span><br><span class="line">;&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="web-worker"><a class="markdownIt-Anchor" href="#web-worker"></a> Web Worker</h1>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a>使得可以在与Web应用程序的主执行线程分开的后台线程中运行脚本。这样做的好处是可以在单独的线程中执行费力的处理，从而允许主线程（通常是UI）运行而不会被阻塞/减速。<br />
worker线程中几乎可以做任何事情，但有一些例外：例如，不能从worker线程内部直接操作DOM，也不能使用 window 对象的某些默认方法和属性 。</p>
<h2 id="创建worker线程"><a class="markdownIt-Anchor" href="#创建worker线程"></a> 创建Worker线程</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myWorker = <span class="keyword">new</span> Worker(aURL[,options]);</span><br></pre></td></tr></table></figure>
<p>Worker的构造器接受一个同源URL参数，以及一个可选的选项。<br />
同源URL应该是一个脚本文件，Worker会开启新线程执行脚本文件中的代码。</p>
<h2 id="发送与接收数据"><a class="markdownIt-Anchor" href="#发送与接收数据"></a> 发送与接收数据</h2>
<p>worker线程与主线程之间发送数据需要使用<code>postMessage(msg)</code>函数，接收数据需要监听<code>message</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postMessage(aMessage, transferList)</span><br></pre></td></tr></table></figure>
<p><code>postMessage</code>对象接收一个<code>aMessage</code>参数，即要传递的数据，第二个参数<code>transferList</code>是可选的，它是一个表示需要转移所有权的对象的数组，如果转移了所有权，则给对象在其发送的上下文中将无法再使用，只有发送到的那个线程才可用。只有<code>MessagePort</code>和<code>ArrayBuffer</code>对象可以转移所有权。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程在worker实例上调用，将消息发送给该worker线程</span></span><br><span class="line">worker.postMessage(<span class="string">&quot;Something&quot;</span>);</span><br><span class="line">worker.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 从worker线程接收到消息时要做的事</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Received message &#x27;</span> + e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>事件处理函数接收的事件对象有一个<code>data</code>属性，它包含从worker线程传给主线程的数据。<br />
worker线程要发送和接受数据可以直接使用它自己的全局对象，但注意worker线程的全局对象不是window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">postMessage(<span class="string">&quot;something&quot;</span>);</span><br><span class="line">addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Received message &#x27;</span> + e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意，默认情况下，发送的数据是被拷贝过的数据，因此对于大型数据例如ArrayBuffer，性能是一个问题。此时需要转移所有权。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ab.byteLength); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">if</span>(trans_flag) &#123;</span><br><span class="line">  <span class="comment">// 转移所有权，接下来不能再用</span></span><br><span class="line">  worker.postMessage(ab, [ab]);</span><br><span class="line">  <span class="built_in">console</span>.log(ab.byteLength); <span class="comment">// 0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不转移所有权，传递的是拷贝</span></span><br><span class="line">  worker.postMessage(ab);</span><br><span class="line">  <span class="built_in">console</span>.log(ab.byteLength); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭线程"><a class="markdownIt-Anchor" href="#关闭线程"></a> 关闭线程</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>
<p>在主线程的worker实例上调用<code>terminate()</code>方法可以关闭worker线程。<br />
在worker线程的全局对象上调用<code>close()</code>方法可以关闭自身。<br />
深复制</p>
<h1 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h1>
<ol>
<li>等待若干毫秒后执行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var timeoutID &#x3D; scope.setTimeout(function[, delay, arg1, arg2, ...]);</span><br><span class="line">var timeoutID &#x3D; scope.setTimeout(function[, delay]);</span><br></pre></td></tr></table></figure>
<p>参数<code>function</code>是计时器到期后要执行的函数<br />
参数<code>delay</code>是要等待的时间，若忽略则为0，单位是毫秒。实际延迟时间可能比这个值要长，因为主线程一次只能执行一个代码块，若等待时间已到但主线程仍在忙，则只能等待主线程完成当前任务才能执行<code>function</code><br />
参数<code>arg1</code>、<code>arg2</code>是要传递给参数<code>function</code>所对应函数的参数。<br />
返回一个正整数标识符，用于标识所创建的计时器。可以将该标识符传递给<code>clearTimeout()</code></p>
<ol start="2">
<li>每若干毫秒就执行一次（周期执行）</li>
</ol>
<p>语法和前者一样，区别在于名字是<code>setInterval</code>和<code>clearInterval</code><br />
定时器的间隔是从当前函数运行的开始时间，到下一次运行的开始时间。<br />
如果函数需要的时间比间隔时间更长（例如每5秒查询一次服务器，但服务器响应慢了），最好使用尾递归的<code>setTimeout</code>而不是<code>setInterval</code>，以保证之前的函数一定结束了。<br />
如果在一个定时器的回调函数内又设置了同一个函数的定时器，形成了递归，则一旦间隔嵌套超过5层，浏览器会将运行延迟调整到4ms</p>
<ol start="3">
<li>上一次执行完就执行下一次（周期执行）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// doSomething</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(f, <span class="number">200</span>);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<h1 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h1>
<p>浮点数显示的是近似值，像显示的0.1，实际不是0.1，小数相对容易理解，但对于整数也是如此：<br />
例如<br />
100000000000000011001 - 100000000000000001001<br />
前者显示为<br />
100000000000000020000<br />
后者显示为<br />
100000000000000000000<br />
但实际上前者是<br />
100000000000000016384<br />
后者是<br />
100000000000000000000</p>
<h1 id="url解码"><a class="markdownIt-Anchor" href="#url解码"></a> URL解码</h1>
<p>encodeURI()主要用于整个URI(例如，<a target="_blank" rel="noopener" href="http://www.baidu.com/search">http://www.baidu.com/search</a>  value.html)，而encode-URIComponent()主要用于对URI中的某一段(例如前面URI中的search value.html)进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号:、正斜杠/、问号?和井号#；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p>
<h1 id="xmlhttprequest"><a class="markdownIt-Anchor" href="#xmlhttprequest"></a> XMLHttpRequest</h1>
<p>浏览器端JavaScript发送HTTP请求的接口叫做XMLHttpRequest。这个接口是20世纪90年代微软为IE浏览器开发的，由于当时XML十分流行，微软将根据XML格式来解析响应文档的功能作为卖点，因此XML被添加到了HTTP接口的名字，实际上二者没有太大关系，解析XML只是HTTP请求接口功能的极小一部分。</p>
<h2 id="同步请求"><a class="markdownIt-Anchor" href="#同步请求"></a> 同步请求</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;2020/data.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">req.send(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(req.responseText);</span><br></pre></td></tr></table></figure>
<h2 id="异步请求"><a class="markdownIt-Anchor" href="#异步请求"></a> 异步请求</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;2020/vote&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">req.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// this === req</span></span><br><span class="line">&#125;);</span><br><span class="line">req.send(<span class="string">&quot;foo=bar&amp;lorem=ipsum&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>load</code>事件当请求成功完成（发送HTTP请求并收到响应）时触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  req.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">  req.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.status &lt; <span class="number">400</span>)</span><br><span class="line">      callback(<span class="literal">null</span>, req.responseText);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Request failed: &quot;</span> + req.statusText))</span><br><span class="line">  &#125;);</span><br><span class="line">  req.addEventListener(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Network error&quot;</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">  req.send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aCallback</span>(<span class="params">err, data</span>)</span>; <span class="comment">// 同一时间只传递一个参数，另一个为null</span></span><br></pre></td></tr></table></figure>
<h2 id="属性和方法"><a class="markdownIt-Anchor" href="#属性和方法"></a> 属性和方法</h2>
<ul>
<li><code>XMLHttpRequest.open(method, url[, async = true[, user[, password]]])</code>方法用于初始化一个新创建的请求，或者重新初始化（打断目前的）一个已存在的请求，初始化是指对请求报文进行设置。<code>method</code>是表示HTTP请求方法的字符串，例如<code>&quot;GET&quot;</code>或<code>&quot;POST&quot;</code>。<code>url</code>是请求要发送的地址。<code>async</code>默认为<code>true</code>，指示是否异步请求，如果为<code>false</code>则<code>send()</code>方法在收到响应之前不会返回。<code>user</code>和<code>password</code>用于身份验证，默认为<code>null</code>。</li>
<li><code>XMLHttpRequest.setRequestHeader(header, value)</code>用于设置请求头，每次调用都会将该请求头添加到当前请求报文首部的最后。出于安全原因，某些请求头只能由浏览器设置，而不能使用该方法设置。</li>
<li><code>XMLHttpRequest.send(body = null)</code>方法用于将请求发送到服务器，如果请求是异步的，则此方法在发送请求后会使用事件来传递结果，同时立刻返回。如果请求是同步的，则在收到响应前方法不会返回。参数<code>body</code>默认为<code>null</code>，表示请求的正文。</li>
<li><code>XMLHttpRequest.status</code>返回收到的响应码</li>
<li><code>XMLHttpRequest.statusText</code>返回收到的响应文字</li>
<li><code>XMLHttpRequest.getResponseHeader(header)</code>返回响应报文首部中header对应的值，若不存在则返回<code>null</code>，参数<code>header</code>不区分大小写</li>
<li><code>XMLHttpRequest.getAllResponseHeaders()</code>返回所有以CRLF分隔的响应头组成的字符串，如果没有收到响应则返回<code>null</code>，如果出现网络错误则返回空串。</li>
<li><code>XMLHttpRequest.responseText</code>返回在发送请求之后从服务器接收到的文本。</li>
<li><code>XMLHttpRequest.response</code>返回响应报文的主体，返回的类型取决于<code>responseType</code>属性</li>
<li><code>XMLHttpRequest.responseXML</code>返回一个响应所对应的<code>Document</code>对象</li>
<li><code>XMLHttpRequest.responseType</code>用于指定响应中包含的数据的类型，它的合法值有：<code>&quot;&quot;</code>、<code>&quot;text&quot;</code>都表示文本，<code>&quot;arraybuffer&quot;</code>表示响应是包含二进制数据的ArrayBuffer，<code>&quot;blob&quot;</code>表示响应是包含二进制数据的Blob对象，<code>&quot;document&quot;</code>表示响应是HTML文档或XML文档，<code>json</code>表示响应是一个JSON数据解析出的对象</li>
</ul>
<h2 id="安全性与同源策略"><a class="markdownIt-Anchor" href="#安全性与同源策略"></a> 安全性与同源策略</h2>
<p>在网页脚本中进行HTTP请求引起了安全性问题，控制脚本的人的意图和用电脑访问的人的意图不一致。例如当你访问一个网站时，如果该网站有个脚本向银行网站发送转账请求，那么这个脚本在你的电脑上运行时，银行网站可能会认为是你自己在操作。<br />
网站可以自己防范这种攻击，但是这需要做一些工作，而很多网站没有做到这一点。鉴于此，浏览器禁止脚本对其他域名发送请求来保证安全。这被称为同源策略(Same-origin policy)，即只允许脚本对同源域名进行HTTP请求。</p>
<p>如果两个URL的协议(protocol)、端口(port)和域名(host)都相同，则这两个URL同源。</p>
<p>网站也可以自己设置跨域策略，网页可以禁止向本页面以外的页面发送请求，服务端也可以允许某些域名下的脚本向自己发送请求。</p>
<p>子域名可以通过将<code>document.domain</code>设置为父域名，使得浏览器允许子域名请求父域名。</p>
<p>服务端设置响应头<code>Access-Control-Allow-Origin: *</code>表示允许所有域名下的脚本向自己发送请求。</p>
<p><code>&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;&gt;</code><br />
用于控制用户代理发送HTTP请求时，请求头<code>referrer</code>写什么。<br />
<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy</a></p>
<p>content的值是以下之一<br />
<a target="_blank" rel="noopener" href="https://w3c.github.io/webappsec-referrer-policy/#referrer-policy">https://w3c.github.io/webappsec-referrer-policy/#referrer-policy</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum ReferrerPolicy &#123;</span><br><span class="line">  &quot;&quot;,</span><br><span class="line">  &quot;no-referrer&quot;,</span><br><span class="line">  &quot;no-referrer-when-downgrade&quot;,</span><br><span class="line">  &quot;same-origin&quot;,</span><br><span class="line">  &quot;origin&quot;,</span><br><span class="line">  &quot;strict-origin&quot;,</span><br><span class="line">  &quot;origin-when-cross-origin&quot;,</span><br><span class="line">  &quot;strict-origin-when-cross-origin&quot;,</span><br><span class="line">  &quot;unsafe-url&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="跨域"><a class="markdownIt-Anchor" href="#跨域"></a> 跨域</h1>
<p>CORS和CSP（内容安全策略）<br />
CSP阻止客户端自己发<br />
CORS阻止客户端接收（但可能已经发过去了）<br />
现在的CORS会进行预检查，先发一个预检报文查看服务器是否允许跨域，若允许<br />
预检请求(preflight request)是使用OPTION方法</p>
<p>CORS 和 JSONP<br />
在CORS出现之前最常用的跨域方法就是JSONP，其他的方法在实际中用的很少。</p>
<p>浏览器的同源策略禁止你向不同源发送HTTP请求。<br />
这与src、img等标签无关，这些标签你只能读到加载后的结果，而无法知道原始内容，比较原始代码或者图片某个位置像素点的颜色。即，你信任这些标签引用的地址，所以可以在不知道原始内容的情况下放心加载。</p>
<p>服务器不返回跨域内容是因为它不能信任客户端，用户打开两个网站，其中一个网站很可能在请求另一个网站用户的隐私数据，接着该网站的作者就可以得知这些信息。</p>
<p>浏览器首先发送预检请求，并带上正式请求要使用的方法以及请求头。<br />
服务器回复一个响应报文，告诉浏览器服务器是否允许此客户端跨域访问。<br />
浏览器收到回复，发现服务器允许，再发送请求。</p>
<h1 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h1>
<p>Cross Site Script，又叫XSS</p>
<p>转义可以解决本页面上的显示问题。<br />
而CSP可以彻底解决这个问题，它可以完全阻止该页面向其他域名发送信息，此时即便被XSS攻击，这只影响这个页面。</p>
<h1 id="表单"><a class="markdownIt-Anchor" href="#表单"></a> 表单</h1>
<p>在元素上调用focus()方法来使其获取焦点，调用blur()方法使其失去焦点。</p>
<p>当一个控件放在<code>&lt;form&gt;</code>元素内时，控件会有一个<code>form</code>属性指向包含它的<code>&lt;form&gt;</code>元素。而<code>&lt;form&gt;</code>元素也有一个<code>elements</code>属性保存了所有控件元素，这个属性是类数组对象，既可以按索引访问，也可以按控件的<code>name</code>属性访问。</p>
<p>提交表单触发的是表单<code>&lt;form&gt;</code>的<code>submit</code>事件</p>
<p>textarea.selectionStart：被选择文本的起始索引，或者说是起始光标的位置（值为光标后面第一个字符的索引）<br />
textarea.selectionEnd：被选择文本最后一个字符的下一个位置索引，或者说是结束光标的位置（值为光标后面第一个字符的索引）</p>
<p>当表单域的内容更改时会触发change事件，但不会一输入就调用，而是在内容失去焦点时才调用。如果希望一输入或修改就调用，可以使用input事件</p>
<p>选择框有checked属性，<code>checkbox</code>和<code>radio</code>的<code>value</code>如果不写，都默认为<code>on</code>，对于<code>checkbox</code>来说，选中时提交的内容是<code>name=on</code>，未选中时提交的内容是空，因此它不需要设置<code>value</code>。但<code>radio</code>必须设置<code>value</code>，因为多个<code>radio</code>会有相同的<code>name</code>来分组，要确定选择了哪一个只能依赖<code>value</code>。</p>
<p>下拉框<code>&lt;select&gt;</code>的样式由浏览器控制，不可能自定义使其一致。如果非要展示效果相同，不要使用<code>&lt;select&gt;</code>，用<code>&lt;div&gt;</code>加代码实现<code>&lt;select&gt;</code>的效果（一些现成的库例如<code>select2</code>和<code>chosen</code>）。<br />
<code>&lt;select&gt;</code>元素的<code>value</code>属性指示当前选中的项之一，对于多选的情况，必须遍历<code>options</code>属性（保存所有<code>&lt;option&gt;</code>元素）检查它们的<code>selected</code>属性。</p>
<p><code>&lt;input type=&quot;file&quot;&gt;</code>的<code>value</code>属性只是文件名（虚假路径）<br />
<code>files</code>属性是一个文件数组，存储着每个文件的信息：<code>name</code>文件名、<code>size</code>字节为单位的文件大小、<code>type</code>媒体类型例如<code>text/plain</code>或<code>image/jped</code>，但不包括文件的内容。<br />
由于从硬盘中读取文件是一件耗时的工作，它需要类似<code>XMLHttpRequest</code>的异步接口来处理这个过程，读取文件的接口是<code>FileReader</code>。在此对象上监听<code>load</code>事件，当读取完成时触发该事件。<code>FileReader</code>读取文件的方法有几种：<code>readAsArrayBuffer(file)</code>读取为ArrayBuffer、<code>readAsDataURL(file)</code>读取为Base64形式的字符串、<code>readAsText(file)</code>读取为字符串、<code>readAsBinaryString(file)</code>将每个字节当做ASCII编码的字符读取为字符串（不推荐使用）</p>
<p>轮播图swiper</p>
<h1 id="本地存储"><a class="markdownIt-Anchor" href="#本地存储"></a> 本地存储</h1>
<p>全局变量localStorage用于存储本地数据，数据会一直保存到用户主动删除。localStorage所保存的内容可以在相同域之间共享。<br />
全局变量sessionStorage用于存储本地数据，数据会一直保存到浏览器关闭。sessionStorage所保存的内容可以在相同域之间共享。<br />
setItem(key, value)方法用于将字符串存储到某个key下<br />
getItem(key)方法用于获取指定key的字符串<br />
removeItem(key)方法用于删除</p>
<p>storage事件当其他页面修改了storage时会触发，可以用于同步其他页面的修改。</p>
<h1 id="生成器函数"><a class="markdownIt-Anchor" href="#生成器函数"></a> 生成器函数</h1>
<p><code>for of</code><br />
<code>...</code></p>
<p>生成器和迭代器内部机制类似，保存暂时状态，当调用函数时才执行并返回当前状态，然后计算下一次的状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; n)&#123;</span><br><span class="line">    b = b + a;</span><br><span class="line">    a = b - a;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成器函数需要在<code>function</code>关键字后面加一个<code>*</code>，里面用<code>yield</code>返回。<br />
生成器函数会返回一个生成器，生成器有<code>next()</code>方法来获取下一次执行结果，结果是一个对象，包含所获得数据以及完成标志。<br />
<code>throw(e?)</code>函数会抛出异常而不是返回值。<br />
<code>return(ret)</code>函数使生成器停止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">forof(generator, <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forof</span>(<span class="params">generator, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> generated;</span><br><span class="line">  <span class="keyword">while</span>(!(val = generator.next()).done) &#123;</span><br><span class="line">    f(val.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h1>
<h2 id="async库"><a class="markdownIt-Anchor" href="#async库"></a> async库</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行，一个任务完成了再执行另一个</span></span><br><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">donecb</span>)</span>&#123;donecb(); <span class="comment">// 结束你的工作后调用参数donecb()以提示异步库完成了工作&#125;,</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">donecb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      donecb(); <span class="comment">// 如果你不主动调用donecb()，异步库只能知道此函数完成了</span></span><br><span class="line">      <span class="comment">// 但如果你的工作也是异步执行的，异步库只能知道你设置函数的工作完成了</span></span><br><span class="line">      <span class="comment">// 无法知道你的异步工作有没有完成</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">], callback)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">series</span>(<span class="params">tasks, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">donecb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; tasks.length) &#123;</span><br><span class="line">      tasks[i++](donecb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  donecb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时开始所有任务，所有任务完成时调用cb</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parallel</span>(<span class="params">tasks, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tasks.length == <span class="number">0</span>) &#123;</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> doneNum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">donecb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doneNum++;</span><br><span class="line">    <span class="keyword">if</span>(doneNum == tasks.length) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    tasks[i](donecb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最多并行limit个执行，任何一个执行完了执行下一个，全部完了执行cb</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parallelLitmit</span>(<span class="params">tasks, limit = <span class="number">3</span>, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tasks.length == <span class="number">0</span>) &#123;</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> next = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> finish = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">donecb</span>(<span class="params">first</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!first) finish++;</span><br><span class="line">    <span class="keyword">if</span>(next &lt; tasks.length) &#123;</span><br><span class="line">      tasks[next++](donecb);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(finish == tasks.length) &#123;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">    donecb(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jquery"><a class="markdownIt-Anchor" href="#jquery"></a> jQuery</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行</span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).queue(<span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    done();</span><br><span class="line">  &#125;,<span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 每次queue都会将任务加入队列，只有队列中前一个完成了才处理下一个。</span></span><br></pre></td></tr></table></figure>
<h2 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> Promise</h2>
<p>基于直接的回调函数的异步编程十分难写，需要用大量的回调、try-catch还容易出错，例如外部的try-catch无法捕获内部异步操作的异常。<br />
鉴于此，人们在此基础上尝试了各种抽象来使异步编程更接近同步编程，Promise是其中最成功的一个。<br />
Promise表示一个异步操作，Promise对象可以被传递，在异步操作成功或失败时可以执行特定操作。要让Promise知道异步操作完成了，或者失败了，需要被调用者主动去调用Promise提供的函数resolve和reject。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// Promise接受一个函数，在这个函数执行各种异步操作</span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;get&#x27;</span>, url)</span><br><span class="line">  <span class="comment">// 若成功</span></span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若失败</span></span><br><span class="line">  xhr.error = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不可能执行失败或出错，也可以不提供reject</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise的构造函数会立刻调用传递给它的函数，并且将resolve和reject传递给它，以此初始化Promise对象。</p>
<p>异步操作的结果不能通过返回得到，实际上是通过异步函数自己去主动调用传进来的resolve和reject函数，来通知调用方事情已经完成。<br />
Promise是一个表示异步请求结果的处理对象，它有一个then函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>then函数接受两个函数，第一个用于Promise成功时调用，第二个用于Promise失败时调用。</p>
<p>返回新的Promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;a.json&#x27;</span>).then(<span class="built_in">JSON</span>.parse).then(f1, f2)</span><br><span class="line">p2 = p.then(f1, f2).then(f3, f4)</span><br></pre></td></tr></table></figure>
<h1 id="基于数据的编程"><a class="markdownIt-Anchor" href="#基于数据的编程"></a> 基于数据的编程</h1>
<p>在todomvc这种类型的开发中，一个控件的结果会导致其他各种控件都要更新，如果基于控件编程，处理每一个事件对其他控件的影响，很快代码就会非常混乱。<br />
每个控件展示的结果实际上都是从一组共同的数据得到的，如果每个控件基于数据编程，就不必去处理对其他控件的影响。</p>
<h1 id="异步函数的类同步写法"><a class="markdownIt-Anchor" href="#异步函数的类同步写法"></a> 异步函数的类同步写法</h1>
<p>基于生成器可以将异步函数写成同步函数的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> generator = foo();</span><br><span class="line"><span class="keyword">var</span> generated = generator.next()</span><br><span class="line">generator.value.then(<span class="function">(<span class="params">x</span>)=&gt;</span>&#123; <span class="comment">// 等Promise完成后执行</span></span><br><span class="line">  <span class="comment">// 得到了x</span></span><br><span class="line">  <span class="keyword">var</span> generated = generator.next(x); <span class="comment">// 参数会作为yield的返回值</span></span><br><span class="line">  <span class="comment">// 此时生成器函数中的x得到了Promise的结果</span></span><br><span class="line">  generator.value.then(<span class="function">(<span class="params">y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generated = generator.next(y);</span><br><span class="line">    <span class="comment">// 每一个yield语句都要then</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 包装一下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  generator.value.then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generated = generator.next(v); <span class="comment">// 参数会作为yield的返回值</span></span><br><span class="line">    step();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> generator = generatorFunction();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!generated.done) &#123;</span><br><span class="line">      generator.value.then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> generated = generator.next(v); <span class="comment">// 参数会作为yield的返回值</span></span><br><span class="line">        step();</span><br><span class="line">      &#125;, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> generated = generator.throw(err); <span class="comment">// 参数会作为yield的返回值</span></span><br><span class="line">        step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  step();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generator = generatorFunction();</span><br><span class="line">    generated = generator.next();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!generated.done) &#123;</span><br><span class="line">        generator.value.then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> generated = generator.next(v); <span class="comment">// 参数会作为yield的返回值</span></span><br><span class="line">          step();</span><br><span class="line">        &#125;, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> generated = generator.throw(err);</span><br><span class="line">          step();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(generated.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES规范提供了<code>async function</code>实现上述机制。不支持的地方还是需要用Promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">await</span> getValue(<span class="number">5000</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">await</span> getValue(<span class="number">5000</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 返回Promise</span></span><br></pre></td></tr></table></figure>
<p>首先运行到第一个await，然后等待await后面的异步函数返回结果赋给y，然后运行到下一个await。<br />
不过这种形式无法处理多个异步任务同时执行，要想多个异步任务同时开始等待都完成，可以</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [y, z] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getValue(<span class="number">5000</span>,<span class="number">3</span>), getValue(<span class="number">5000</span>,<span class="number">3</span>)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步生成器"><a class="markdownIt-Anchor" href="#异步生成器"></a> 异步生成器</h1>
<p>与普通生成器函数的区别在于，里面可以用await。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> getValue(<span class="number">5000</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">await</span> getValue(<span class="number">5000</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">await</span> getValue(<span class="number">5000</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">gen = foo();</span><br><span class="line">p1 = gen.next()</span><br><span class="line">p2 = gen.next();</span><br><span class="line">p3 = gen.next();</span><br><span class="line"><span class="comment">// 会立刻返回3个Promise</span></span><br><span class="line"><span class="comment">// 但Promise还没执行完，它会按照顺序</span></span><br><span class="line"><span class="comment">// 先等待第一个await返回执行完Promise</span></span><br><span class="line"><span class="comment">// 再等待第二个await返回执行完Promise</span></span><br><span class="line"><span class="built_in">console</span>.log(p1, p2, p3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">var</span> x <span class="keyword">of</span> foo()</span>)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/learn_js.html">https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/learn_js.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/Eloquent%20Javascript%E4%B9%A0%E9%A2%98.html"><i class="fa fa-chevron-left">  </i><span>Eloquent Javascript习题</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/TypeScript.html"><span>TypeScript</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>