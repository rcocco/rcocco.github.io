<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="8 可执行代码和执行上下文"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>8 可执行代码和执行上下文 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text"> 8 可执行代码与执行上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.</span> <span class="toc-text"> 8.1 词法环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#811-%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 8.1.1 环境记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8111-%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 8.1.1.1 声明式环境记录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#81111-hasbindingn"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text"> 8.1.1.1.1 HasBinding(N)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81112-createmutablebindingn-d"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text"> 8.1.1.1.2 CreateMutableBinding(N, D)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81113-createimmutablebindingn-s"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text"> 8.1.1.1.3 CreateImmutableBinding(N, S)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81114-initializebindingnv"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text"> 8.1.1.1.4 InitializeBinding(N,V)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81115-setmutablebinding-nvs"><span class="toc-number">1.1.1.1.5.</span> <span class="toc-text"> 8.1.1.1.5 SetMutableBinding (N,V,S)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81116-getbindingvaluens"><span class="toc-number">1.1.1.1.6.</span> <span class="toc-text"> 8.1.1.1.6 GetBindingValue(N,S)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81117-deletebinding-n"><span class="toc-number">1.1.1.1.7.</span> <span class="toc-text"> 8.1.1.1.7 DeleteBinding (N)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81118-hasthisbinding"><span class="toc-number">1.1.1.1.8.</span> <span class="toc-text"> 8.1.1.1.8 HasThisBinding ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81119-hassuperbinding"><span class="toc-number">1.1.1.1.9.</span> <span class="toc-text"> 8.1.1.1.9 HasSuperBinding ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#811110-withbaseobject"><span class="toc-number">1.1.1.1.10.</span> <span class="toc-text"> 8.1.1.1.10 WithBaseObject()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8112-%E5%AF%B9%E8%B1%A1%E5%BC%8F%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 8.1.1.2 对象式环境记录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#81121-hasbindingn"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text"> 8.1.1.2.1 HasBinding(N)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81122-createmutablebinding-n-d"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text"> 8.1.1.2.2 CreateMutableBinding (N, D)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81123-createimmutablebinding-n-s"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text"> 8.1.1.2.3 CreateImmutableBinding (N, S)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81124-initializebinding-nv"><span class="toc-number">1.1.1.2.4.</span> <span class="toc-text"> 8.1.1.2.4 InitializeBinding (N,V)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81125-setmutablebinding-nvs"><span class="toc-number">1.1.1.2.5.</span> <span class="toc-text"> 8.1.1.2.5 SetMutableBinding (N,V,S)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81126-getbindingvaluens"><span class="toc-number">1.1.1.2.6.</span> <span class="toc-text"> 8.1.1.2.6 GetBindingValue(N,S)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81127-deletebinding-n"><span class="toc-number">1.1.1.2.7.</span> <span class="toc-text"> 8.1.1.2.7 DeleteBinding (N)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81128-hasthisbinding"><span class="toc-number">1.1.1.2.8.</span> <span class="toc-text"> 8.1.1.2.8 HasThisBinding ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81129-hassuperbinding"><span class="toc-number">1.1.1.2.9.</span> <span class="toc-text"> 8.1.1.2.9 HasSuperBinding ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#811210-withbaseobject"><span class="toc-number">1.1.1.2.10.</span> <span class="toc-text"> 8.1.1.2.10 WithBaseObject()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8113-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.1.3.</span> <span class="toc-text"> 8.1.1.3 函数式环境记录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#81131-bindthisvaluev"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text"> 8.1.1.3.1 BindThisValue(V)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81132-hasthisbinding"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text"> 8.1.1.3.2 HasThisBinding ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81133-hassuperbinding"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text"> 8.1.1.3.3 HasSuperBinding ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81134-getthisbinding"><span class="toc-number">1.1.1.3.4.</span> <span class="toc-text"> 8.1.1.3.4 GetThisBinding ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#81135-getsuperbase"><span class="toc-number">1.1.1.3.5.</span> <span class="toc-text"> 8.1.1.3.5 GetSuperBase ()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8114-%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.1.4.</span> <span class="toc-text"> 8.1.1.4 全局环境记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8115-%E6%A8%A1%E5%9D%97%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.1.5.</span> <span class="toc-text"> 8.1.1.5 模块环境记录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#812-%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 8.1.2 词法环境操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8121-getidentifierreference-lex-name-strict"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 8.1.2.1 GetIdentifierReference (lex, name, strict)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8122-newdeclarativeenvironment-e"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 8.1.2.2 NewDeclarativeEnvironment (E)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8123-newobjectenvironment-o-e"><span class="toc-number">1.1.2.3.</span> <span class="toc-text"> 8.1.2.3 NewObjectEnvironment (O, E)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8124-newfunctionenvironment-f-newtarget"><span class="toc-number">1.1.2.4.</span> <span class="toc-text"> 8.1.2.4 NewFunctionEnvironment ( F, newTarget )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8125-newglobalenvironment-g"><span class="toc-number">1.1.2.5.</span> <span class="toc-text"> 8.1.2.5 NewGlobalEnvironment ( G )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8126-newmoduleenvironment-e"><span class="toc-number">1.1.2.6.</span> <span class="toc-text"> 8.1.2.6 NewModuleEnvironment (E)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-realms"><span class="toc-number">1.2.</span> <span class="toc-text"> 8.2 Realms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.3.</span> <span class="toc-text"> 8.3 执行上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#831-resolvebinding-name-env"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 8.3.1 ResolveBinding ( name, [env] )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%89%E6%8E%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%BB%E6%9C%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text"> 8.4 任务和安排任务的主机操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#841-hostenqueuepromisejob-job-realm"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 8.4.1 HostEnqueuePromiseJob ( job, realm )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text"> 8.6 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E4%BB%A3%E7%90%86%E9%9B%86%E7%BE%A4"><span class="toc-number">1.6.</span> <span class="toc-text"> 8.7 代理集群</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">203</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">8 可执行代码和执行上下文</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/">JavaScript语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/">ES规范</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="8-可执行代码与执行上下文"><a class="markdownIt-Anchor" href="#8-可执行代码与执行上下文"></a> 8 可执行代码与执行上下文</h1>
<h2 id="81-词法环境"><a class="markdownIt-Anchor" href="#81-词法环境"></a> 8.1 词法环境</h2>
<p>词法环境是一种规范类型，用于定义标识符与特定变量和函数在 ECMAScript 代码的词法嵌套结构上关联关系。一个词法环境由一个环境记录和一个可能为空的外部词法环境引用组成。通常一个词法环境与ECMAScript代码的某些特定语法结构相关联，如<code>FunctionDeclaration</code>、<code>BlockStatement</code>或<code>TryStatement</code>的<code>Catch</code>子句，每次计算这些代码时都会创建一个新的词法环境。</p>
<span id="more"></span>
<p>一个环境记录 记录了在其相关的词法环境范围内创建的标识符绑定。它被称为词法环境的<code>EnvironmentRecord</code>。</p>
<p>外部环境引用被用来模拟词汇环境值的逻辑嵌套。一个（内部）词法环境的外部引用，是对逻辑上包含内部词法环境的词法环境 的引用。当然，一个外部词法环境可以有它自己的外部词法环境。一个词法环境可以作为多个内部词法环境的外部环境。例如，如果一个<code>FunctionDeclaration</code>包含两个嵌套的<code>FunctionDeclaration</code>，那么每个嵌套的函数的词法环境的外部词法环境将是包含它们的函数的本次计算的词法环境。</p>
<p>一个全局环境是没有外部环境的词法环境。全局环境的外部环境引用为<code>null</code>。一个全局环境的<code>EnvironmentRecord</code>可以预先填充部分标识符绑定，并且包括一个关联的全局对象，该对象的属性提供了全局环境的一些标识符绑定。随着ECMAScript代码的执行，额外的属性可能会被添加到全局对象中，初始的属性可能会被修改。</p>
<p>模块环境是一个词法环境，它包含了一个模块的顶级声明的绑定。它还包含由模块明确导入的绑定。一个模块环境的外部环境是一个全局环境。</p>
<p>一个函数环境是一个对应于ECMAScript函数对象调用的词法环境。一个函数环境可以建立一个新的<code>this</code>绑定。一个函数环境也捕获了为支持<code>super</code>方法调用的必要状态。</p>
<p>词法环境和环境记录的值纯粹是规范机制，不需要对应ECMAScript实现中的任何特定内容。ECMAScript程序无法直接访问或操作这些值。</p>
<h3 id="811-环境记录"><a class="markdownIt-Anchor" href="#811-环境记录"></a> 8.1.1 环境记录</h3>
<p>本规范中使用了两种主要的环境记录值：声明式环境记录和对象式环境记录。<br />
声明式环境记录用于定义ECMAScript语言语法元素的效果，如<code>FunctionDeclarations</code>、<code>VariableDeclarations</code>和<code>Catch</code>子句，它们直接将标识符绑定与ECMAScript语言值联系在一起。<br />
对象式环境记录用于定义ECMAScript元素的效果，如<code>WithStatement</code>，它将标识符绑定与某些对象的属性联系起来。<br />
全局环境记录和函数环境记录是专门用于脚本全局声明和函数内顶层声明的专用记录。</p>
<p>出于规范目的，环境记录值是Record规范类型的值。可以将环境记录值理解为面向对象中的一个简单继承结构，其中环境记录是一个抽象类，有三个具体实现类：声明式环境记录、对象式环境记录、全局环境记录。函数环境记录和模块环境记录是声明式环境记录的子类。抽象类包括 表16 定义的抽象规范方法，针对每一个具体实现类，每个抽象方法都有不同的具体算法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HasBinding(N)</td>
<td style="text-align:left">判断环境记录是否有对字符串值N的绑定。如果有则返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:left">CreateMutableBinding(N, D)</td>
<td style="text-align:left">在环境记录中创建一个新的但未初始化的可变绑定。字符串值N是绑定的名称。如果可选参数D的值为true，则该绑定在后续操作中可以被删除。</td>
</tr>
<tr>
<td style="text-align:left">CreateImmutableBinding(N, S)</td>
<td style="text-align:left">在环境记录中创建一个新的但未初始化的不可变绑定。字符串值N是绑定的名称。如果S为true，则不管引用该绑定的操作的严格模式设置如何，尝试在其初始化之前访问绑定的值或在其初始化之后对其进行设置都将始终引发异常。S是可选参数，默认为false。</td>
</tr>
<tr>
<td style="text-align:left">InitializeBinding(N,V)</td>
<td style="text-align:left">设置环境记录中已经存在但未初始化的绑定的值。字符串值N是绑定名称的文本。V是绑定的值，该值可以任何ECMAScript语言类型。</td>
</tr>
<tr>
<td style="text-align:left">SetMutableBinding(N,V,S)</td>
<td style="text-align:left">在环境记录中设置一个已经存在的绑定的值。其中字符串N是绑定的名称。V是绑定的值，该值可以任何ECMAScript语言类型。S是一个Boolean类型的标记，当S为true并且该绑定不允许赋值时，则抛出一个 TypeError 异常。</td>
</tr>
<tr>
<td style="text-align:left">GetBindingValue(N,S)</td>
<td style="text-align:left">返回环境记录中一个已经存在的绑定的值。其中字符串N是绑定的名称。S用于标识源自严格模式代码的引用，或者以其他方式要求严格模式引用语义的引用。如果S为true并且该绑定不存在，抛出ReferenceError异常。如果绑定存在但未初始化，则无论S的值如何，都会抛出ReferenceError异常</td>
</tr>
<tr>
<td style="text-align:left">DeleteBinding(N)</td>
<td style="text-align:left">从环境记录中删除一个绑定。其中字符串N是绑定的名称。如果N指定的绑定存在，将其删除并返回true。如果绑定存在但无法删除则返回 false。如果绑定不存在则返回true。</td>
</tr>
<tr>
<td style="text-align:left">HasThisBinding()</td>
<td style="text-align:left">判断环境记录是否建立了<code>this</code>绑定。是则返回true，不是则返回false</td>
</tr>
<tr>
<td style="text-align:left">HasSuperBinding()</td>
<td style="text-align:left">判断环境记录是否建立了<code>super</code>绑定。是则返回true，不是则返回false</td>
</tr>
<tr>
<td style="text-align:left">WithBaseObject()</td>
<td style="text-align:left">如果此环境记录与with语句关联，则返回with对象。否则，返回undefined</td>
</tr>
</tbody>
</table>
<h4 id="8111-声明式环境记录"><a class="markdownIt-Anchor" href="#8111-声明式环境记录"></a> 8.1.1.1 声明式环境记录</h4>
<p>每个声明式环境记录都与一个 ECMAScript 程序作用域相关联，这个作用域包含变量、常量、let、class、模块、import 和（或）函数声明。声明式环境记录绑定了作用域内定义的一系列标识符。</p>
<p>声明式环境记录的具体规范方法的行为由以下算法定义：</p>
<h5 id="81111-hasbindingn"><a class="markdownIt-Anchor" href="#81111-hasbindingn"></a> 8.1.1.1.1 HasBinding(N)</h5>
<p>声明式环境记录的 HasBinding 具体方法用于简单地判断作为参数的标识符是否是当前对象绑定的标识符之一：</p>
<ol>
<li>令<code>envRec</code>为函数调用时对应的声明式环境记录。</li>
<li>如果<code>envRec</code>有一个名称为<code>N</code>的绑定，返回<code>true</code></li>
<li>返回<code>false</code></li>
</ol>
<h5 id="81112-createmutablebindingn-d"><a class="markdownIt-Anchor" href="#81112-createmutablebindingn-d"></a> 8.1.1.1.2 CreateMutableBinding(N, D)</h5>
<p>声明式环境记录的 CreateMutableBinding 具体方法会创建一个名称为 N 的未初始化的绑定。当前环境记录中不能存在 N 的绑定。如果调用时提供了布尔类型的参数 D 且其值为 true，则新建的绑定被标记为可删除。</p>
<ol>
<li>令<code>envRec</code>为函数调用时对应的声明式环境记录。</li>
<li>断言：<code>envRec</code> 不存在 N 的绑定。</li>
<li>在 envRec 中为 N 创建一个可变绑定，并记录它未初始化。如果 D 为 true 则记录新创建的绑定可在后续操作中通过调用 DeleteBinding 删除。</li>
<li>返回<code>NormalCompletion(empty)</code></li>
</ol>
<h5 id="81113-createimmutablebindingn-s"><a class="markdownIt-Anchor" href="#81113-createimmutablebindingn-s"></a> 8.1.1.1.3 CreateImmutableBinding(N, S)</h5>
<p>声明式环境记录的 CreateImmutableBinding 具体方法会创建一个名称为 N 的未初始化的绑定。当前环境记录中不能存在 N 的绑定。如果调用时提供了布尔类型的参数 S 且其值为 true，则新建的绑定被标记为严格绑定。</p>
<ol>
<li>令<code>envRec</code>为函数调用时对应的声明式环境记录。</li>
<li>断言：<code>envRec</code> 不存在 N 的绑定。</li>
<li>在 envRec 中为 N 创建一个可变绑定，并记录它未初始化。如果 S 为 true 则记录新创建的绑定是严格绑定。</li>
<li>返回<code>NormalCompletion(empty)</code></li>
</ol>
<h5 id="81114-initializebindingnv"><a class="markdownIt-Anchor" href="#81114-initializebindingnv"></a> 8.1.1.1.4 InitializeBinding(N,V)</h5>
<p>声明式环境记录项的 InitializeBinding 具体方法用于将当前名称为参数 N 的绑定的值修改为参数 V 指定的值。方法调用时，必须存在 N 未初始化的绑定。</p>
<ol>
<li>令<code>envRec</code>为函数调用时对应的声明式环境记录。</li>
<li>断言：<code>envRec</code> 必须有一个 N 的未初始化绑定。</li>
<li>在<code>envRec</code>中将<code>N</code>的绑定的值设置为<code>V</code>。</li>
<li>在<code>envRec</code>中将<code>N</code>的绑定记录为已初始化。</li>
<li>返回<code>NormalCompletion(empty)</code></li>
</ol>
<h5 id="81115-setmutablebinding-nvs"><a class="markdownIt-Anchor" href="#81115-setmutablebinding-nvs"></a> 8.1.1.1.5 SetMutableBinding (N,V,S)</h5>
<p>pass</p>
<h5 id="81116-getbindingvaluens"><a class="markdownIt-Anchor" href="#81116-getbindingvaluens"></a> 8.1.1.1.6 GetBindingValue(N,S)</h5>
<p>pass</p>
<h5 id="81117-deletebinding-n"><a class="markdownIt-Anchor" href="#81117-deletebinding-n"></a> 8.1.1.1.7 DeleteBinding (N)</h5>
<p>pass</p>
<h5 id="81118-hasthisbinding"><a class="markdownIt-Anchor" href="#81118-hasthisbinding"></a> 8.1.1.1.8 HasThisBinding ()</h5>
<p>pass</p>
<h5 id="81119-hassuperbinding"><a class="markdownIt-Anchor" href="#81119-hassuperbinding"></a> 8.1.1.1.9 HasSuperBinding ()</h5>
<p>pass</p>
<h5 id="811110-withbaseobject"><a class="markdownIt-Anchor" href="#811110-withbaseobject"></a> 8.1.1.1.10 WithBaseObject()</h5>
<p>pass</p>
<h4 id="8112-对象式环境记录"><a class="markdownIt-Anchor" href="#8112-对象式环境记录"></a> 8.1.1.2 对象式环境记录</h4>
<p>每一个对象式环境记录都关联到一个对象，这个对象称为对象式环境纪录的绑定对象。对象式环境记录绑定直接与其绑定对象的属性名称相对应的一组字符串标识符名称。不是以IdentifierName形式出现的字符串属性键不在这组绑定标识符中。绑定对象的自有属性和继承属性都在这组标识符中，而不管属性的 [[Enumerable]] 特性值是什么。由于对象的属性可以动态的增减，因此对象式环境记录项所绑定的标识符集合也会隐式地变化，这是增减绑定对象的属性而产生的副作用。通过以上描述的副作用而建立的绑定被视为可变绑定，即使该绑定对应的属性的 [[Writable]] 特性的值为 false。对象式环境记录没有不可变绑定。</p>
<p>为<code>with</code>语句(13.11)创建的对象式环境记录可以将其绑定对象作为隐式<code>this</code>值，以供函数调用使用。这个功能由与对象式环境记录关联的<code>withEnvironment</code>布尔值控制。默认情况下，对于任何对象式环境记录，<code>withEnvironment</code>均为<code>false</code>。</p>
<p>对象式环境记录的具体规范方法的行为由以下算法定义：</p>
<h5 id="81121-hasbindingn"><a class="markdownIt-Anchor" href="#81121-hasbindingn"></a> 8.1.1.2.1 HasBinding(N)</h5>
<p>pass</p>
<h5 id="81122-createmutablebinding-n-d"><a class="markdownIt-Anchor" href="#81122-createmutablebinding-n-d"></a> 8.1.1.2.2 CreateMutableBinding (N, D)</h5>
<p>pass</p>
<h5 id="81123-createimmutablebinding-n-s"><a class="markdownIt-Anchor" href="#81123-createimmutablebinding-n-s"></a> 8.1.1.2.3 CreateImmutableBinding (N, S)</h5>
<p>pass</p>
<h5 id="81124-initializebinding-nv"><a class="markdownIt-Anchor" href="#81124-initializebinding-nv"></a> 8.1.1.2.4 InitializeBinding (N,V)</h5>
<p>pass</p>
<h5 id="81125-setmutablebinding-nvs"><a class="markdownIt-Anchor" href="#81125-setmutablebinding-nvs"></a> 8.1.1.2.5 SetMutableBinding (N,V,S)</h5>
<p>pass</p>
<h5 id="81126-getbindingvaluens"><a class="markdownIt-Anchor" href="#81126-getbindingvaluens"></a> 8.1.1.2.6 GetBindingValue(N,S)</h5>
<p>pass</p>
<h5 id="81127-deletebinding-n"><a class="markdownIt-Anchor" href="#81127-deletebinding-n"></a> 8.1.1.2.7 DeleteBinding (N)</h5>
<p>pass</p>
<h5 id="81128-hasthisbinding"><a class="markdownIt-Anchor" href="#81128-hasthisbinding"></a> 8.1.1.2.8 HasThisBinding ()</h5>
<p>pass</p>
<h5 id="81129-hassuperbinding"><a class="markdownIt-Anchor" href="#81129-hassuperbinding"></a> 8.1.1.2.9 HasSuperBinding ()</h5>
<p>pass</p>
<h5 id="811210-withbaseobject"><a class="markdownIt-Anchor" href="#811210-withbaseobject"></a> 8.1.1.2.10 WithBaseObject()</h5>
<p>pass</p>
<h4 id="8113-函数式环境记录"><a class="markdownIt-Anchor" href="#8113-函数式环境记录"></a> 8.1.1.3 函数式环境记录</h4>
<p>函数式环境记录是一种声明式环境记录，用来表示函数的顶级作用域，并且如果函数不是<code>ArrowFunction</code>，则提供<code>this</code>绑定。<br />
如果一个函数不是<code>ArrowFunction</code>，并且引用了<code>super</code>，则它的函数式环境记录还将包含用来从函数内部执行<code>super</code>方法调用的状态。</p>
<p>函数式环境记录有表16列出的其他状态字段：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段名</th>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[thisValue]]</td>
<td style="text-align:left"><code>Any</code></td>
<td style="text-align:left">这是此函数调用使用的<code>this</code>值。</td>
</tr>
<tr>
<td style="text-align:left">[[thisBindingStatus]]</td>
<td style="text-align:left"><code>&quot;lexical&quot; | &quot;initialized&quot; | &quot;uninitialized&quot;</code></td>
<td style="text-align:left">如果该值为&quot;lexical&quot;，则为ArrowFunction，并且没有局部this值。</td>
</tr>
<tr>
<td style="text-align:left">[[FunctionObject]]</td>
<td style="text-align:left"><code>Object</code></td>
<td style="text-align:left">函数对象，其调用创建了此环境记录</td>
</tr>
<tr>
<td style="text-align:left">[[HomeObject]]</td>
<td style="text-align:left"><code>Object | undefined</code></td>
<td style="text-align:left">如果关联的函数有<code>super</code>属性访问并且不是<code>ArrowFunction</code>，则[[HomeObject]]是该函数作为方法绑定到的对象。 [[HomeObject]]的默认值是undefined</td>
</tr>
<tr>
<td style="text-align:left">[[NewTarget]]</td>
<td style="text-align:left"><code>Object | undefined</code></td>
<td style="text-align:left">如果此环境记录是通过[[Construct]]内部方法创建的，则[[NewTarget]]是[[Construct]]的newTarget参数的值。 否则，其值是undefined</td>
</tr>
</tbody>
</table>
<p>函数式环境记录支持表15中列出的所有声明式环境记录方法，并且除<code>HasThisBinding</code>和<code>HasSuperBinding</code>外，所有这些方法都具有相同的规范。 此外，函数式环境记录还支持表17中列出的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BindThisValue(V)</td>
<td style="text-align:left">设置[[thisValue]]并记录它已被初始化。</td>
</tr>
<tr>
<td style="text-align:left">GetThisBinding()</td>
<td style="text-align:left">返回此环境记录的<code>this</code>绑定的值。如果<code>this</code>绑定尚未初始化，则抛出ReferenceError</td>
</tr>
<tr>
<td style="text-align:left">GetSuperBase()</td>
<td style="text-align:left">返回作为此环境记录中绑定的<code>super</code>属性访问基础的对象。对象是从此环境记录的[[HomeObject]]字段派生的。值<code>undefined</code>表示<code>super</code>属性访问将产生运行时错误</td>
</tr>
</tbody>
</table>
<p>函数式环境记录的其他具体规范方法的行为由以下算法定义：</p>
<h5 id="81131-bindthisvaluev"><a class="markdownIt-Anchor" href="#81131-bindthisvaluev"></a> 8.1.1.3.1 BindThisValue(V)</h5>
<p>pass</p>
<h5 id="81132-hasthisbinding"><a class="markdownIt-Anchor" href="#81132-hasthisbinding"></a> 8.1.1.3.2 HasThisBinding ()</h5>
<p>pass</p>
<h5 id="81133-hassuperbinding"><a class="markdownIt-Anchor" href="#81133-hassuperbinding"></a> 8.1.1.3.3 HasSuperBinding ()</h5>
<p>pass</p>
<h5 id="81134-getthisbinding"><a class="markdownIt-Anchor" href="#81134-getthisbinding"></a> 8.1.1.3.4 GetThisBinding ()</h5>
<p>pass</p>
<h5 id="81135-getsuperbase"><a class="markdownIt-Anchor" href="#81135-getsuperbase"></a> 8.1.1.3.5 GetSuperBase ()</h5>
<p>pass</p>
<h4 id="8114-全局环境记录"><a class="markdownIt-Anchor" href="#8114-全局环境记录"></a> 8.1.1.4 全局环境记录</h4>
<p>全局环境记录用来表示所有ECMAScript脚本元素共享的最外层作用域，这些元素在一个共同的 realm 中被处理。全局环境记录为内置全局对象（第18节）、全局对象的属性以及脚本中出现的所有顶级声明（13.2.8, 13.2.10）提供绑定。</p>
<p>全局环境记录在逻辑上是一个单一的记录，但它被指定为封装了一个对象式环境记录和一个声明式环境记录的复合体。对象式环境记录的基本对象(base object)是相关Realm记录的全局对象。这个全局对象是全局环境记录的<code>GetThisBinding</code>具体方法返回的值。全局环境记录的对象式环境记录组件包含了所有内置的全局对象（第18节）以及由全局代码中的<code>FunctionDeclaration</code>、<code>GeneratorDeclaration</code>、<code>AsyncFunctionDeclaration</code>、<code>AsyncGeneratorDeclaration</code>或<code>VariableStatement</code>引入的所有绑定。全局代码中所有其他ECMAScript声明的绑定都包含在全局环境记录的声明式环境记录组件中。</p>
<p>属性可以直接在一个全局对象上创建。因此，全局环境记录的对象式环境记录组件可能包含由<code>FunctionDeclaration</code>、<code>GeneratorDeclaration</code>、<code>AsyncFunctionDeclaration</code>、<code>AsyncGeneratorDeclaration</code>或<code>VariableDeclaration</code>声明明确创建的绑定，以及作为全局对象的属性隐式创建的绑定。为了识别哪些绑定是使用声明显式创建的，全局环境记录维护了一个使用其<code>CreateGlobalVarBinding</code>和<code>CreateGlobalFunctionBinding</code>具体方法绑定的名称列表。</p>
<h4 id="8115-模块环境记录"><a class="markdownIt-Anchor" href="#8115-模块环境记录"></a> 8.1.1.5 模块环境记录</h4>
<p>模块环境记录是用于表示ECMAScript模块外部作用域的声明式环境记录。</p>
<h3 id="812-词法环境操作"><a class="markdownIt-Anchor" href="#812-词法环境操作"></a> 8.1.2 词法环境操作</h3>
<p>本规范中，以下抽象操作用于在词法环境上进行操作。</p>
<h4 id="8121-getidentifierreference-lex-name-strict"><a class="markdownIt-Anchor" href="#8121-getidentifierreference-lex-name-strict"></a> 8.1.2.1 GetIdentifierReference (lex, name, strict)</h4>
<p>抽象操作GetIdentifierReference通过一个词法环境lex，一个字符串name和一个布尔标志strict作为参数来调用。 lex的值可以为null。 调用时，将执行以下步骤：</p>
<ol>
<li>如果<code>lex</code>值为<code>null</code>，则返回一个引用类型，其基值(base value)为<code>undefined</code>，引用名(referenced name)为<code>name</code>，严格引用标志(strict reference flag)为<code>strict</code></li>
<li>令<code>envRec</code>为<code>lex</code>的环境记录</li>
<li>令<code>exists</code>为<code>envRec.HasBinding(name)</code></li>
<li><code>ReturnIfAbrupt(exists)</code></li>
<li>如果<code>exists</code>为<code>true</code>，则返回一个引用类型，其基值(base value)为<code>envRec</code>，引用名(referenced name)为<code>name</code>，严格引用标志(strict reference flag)为<code>strict</code></li>
<li>否则：
<ol>
<li>令<code>outer</code>为<code>lex</code>的外部环境引用的值</li>
<li>返回<code>GetIdentifierReference(outer, name, strict)</code></li>
</ol>
</li>
</ol>
<h4 id="8122-newdeclarativeenvironment-e"><a class="markdownIt-Anchor" href="#8122-newdeclarativeenvironment-e"></a> 8.1.2.2 NewDeclarativeEnvironment (E)</h4>
<p>当抽象操作<code>NewDeclarativeEnvironment</code>以一个词法环境(Lexical Environment)作为参数<code>E</code>被调用时，执行以下步骤：</p>
<ol>
<li>令<code>env</code>为一个新的词法环境(Lexical Environment)</li>
<li>令<code>envRec</code>为一个新的不包含任何绑定的声明式环境记录</li>
<li>将<code>env</code>的环境记录设为<code>envRec</code></li>
<li>将<code>env</code>的外部词法环境引用设为<code>E</code></li>
<li>返回<code>env</code></li>
</ol>
<h4 id="8123-newobjectenvironment-o-e"><a class="markdownIt-Anchor" href="#8123-newobjectenvironment-o-e"></a> 8.1.2.3 NewObjectEnvironment (O, E)</h4>
<p>当使用对象O和词法环境E作为参数调用抽象操作NewObjectEnvironment时，将执行以下步骤：</p>
<ol>
<li>令<code>env</code>为一个新的词法环境</li>
<li>令<code>envRec</code>为一个新的对象环境记录，其中包含<code>O</code>作为绑定对象</li>
<li>将<code>env</code>的环境记录设为<code>envRec</code></li>
<li>将<code>env</code>的外部词法环境引用设为<code>E</code></li>
<li>返回<code>env</code></li>
</ol>
<h4 id="8124-newfunctionenvironment-f-newtarget"><a class="markdownIt-Anchor" href="#8124-newfunctionenvironment-f-newtarget"></a> 8.1.2.4 NewFunctionEnvironment ( F, newTarget )</h4>
<p>当使用参数<code>F</code>和<code>newTarget</code>调用抽象操作<code>NewFunctionEnvironment</code>时，将执行以下步骤：</p>
<ol>
<li>断言：<code>F</code>是ECMAScript函数</li>
<li>断言：<code>Type(newTarget)</code>为<code>Undefined</code>或<code>Object</code></li>
<li>令<code>env</code>为新的词法环境</li>
<li>令<code>envRec</code>为不包含绑定的新的函数式环境记录</li>
<li>将<code>envRec.[[FunctionObject]]</code>设为<code>F</code></li>
<li>如果<code>F</code>的<code>[[ThisMode]]</code>内部槽为<code>lexical</code>，将<code>envRec.[[thisBindingStatus]]</code>设为<code>&quot;lexical&quot;</code></li>
<li>否则，将<code>envRec.[[thisBindingStatus]]</code>设为<code>&quot;uninitialized&quot;</code></li>
<li>令<code>home</code>为<code>F</code>的<code>[[HomeObject]]</code>内部槽的值</li>
<li>将<code>envRec.[[HomeObject]]</code>设为<code>home</code></li>
<li>将<code>envRec.[[NewTarget]]</code>设为<code>newTarget</code></li>
<li>将<code>env</code>的环境记录设为<code>envRec</code></li>
<li>将<code>env</code>的外部词法环境引用设为<code>F</code>的<code>[[Environment]]</code>内部槽的值</li>
<li>返回<code>env</code></li>
</ol>
<h4 id="8125-newglobalenvironment-g"><a class="markdownIt-Anchor" href="#8125-newglobalenvironment-g"></a> 8.1.2.5 NewGlobalEnvironment ( G )</h4>
<h4 id="8126-newmoduleenvironment-e"><a class="markdownIt-Anchor" href="#8126-newmoduleenvironment-e"></a> 8.1.2.6 NewModuleEnvironment (E)</h4>
<h2 id="82-realms"><a class="markdownIt-Anchor" href="#82-realms"></a> 8.2 Realms</h2>
<p>在计算之前，所有ECMAScript代码都必须与一个 realm 相关联。从概念上讲，realm 由一组固有对象、一个ECMAScript全局环境、该全局环境作用域内加载的所有ECMAScript代码，以及其他关联状态和资源组成。</p>
<p>在本规范中，realm被表示为 Realm 记录，它具有表22中规定的字段：</p>
<p>表22：Realm记录字段</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段名</th>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Intrinsics]]</td>
<td style="text-align:left">一个记录，其字段名是固有键(intrinsic keys)且值是对象</td>
<td style="text-align:left">与此realm关联的代码使用的固有值</td>
</tr>
<tr>
<td style="text-align:left">[[GlobalObject]]</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">此realm的全局对象</td>
</tr>
<tr>
<td style="text-align:left">[[GlobalEnv]]</td>
<td style="text-align:left">词法环境</td>
<td style="text-align:left">此realm的全局环境</td>
</tr>
<tr>
<td style="text-align:left">[[TemplateMap]]</td>
<td style="text-align:left">记录<code>&#123; [[Site]]: Parse Node, [[Array]]: Object &#125;</code>的列表</td>
<td style="text-align:left">模板对象使用其Realm记录的<code>[[TemplateMap]]</code>为每个realm分别进行规范化。每个<code>[[Site]]</code>值是一个解析节点，它是一个<code>TemplateLiteral</code>。关联的[[Array]]值是相应的模板对象，被传递给一个标签函数。注：一旦一个解析节点变得不可达，相应的<code>[[Array]]</code>也是不可达的，如果一个实现将这对节点从<code>[[TemplateMap]]</code>列表中移除，它将是不可察觉的。</td>
</tr>
<tr>
<td style="text-align:left">[[HostDefined]]</td>
<td style="text-align:left">任何值，默认为<code>undefined</code></td>
<td style="text-align:left">保留给需要将额外信息与Realm记录联系起来的主机环境使用的字段。</td>
</tr>
</tbody>
</table>
<h2 id="83-执行上下文"><a class="markdownIt-Anchor" href="#83-执行上下文"></a> 8.3 执行上下文</h2>
<p>执行上下文是一种规范device，用于 跟踪ECMAScript实现的运行时计算。在任何时间点上，每个代理最多只有一个执行上下文在实际执行代码。这被称为代理的运行中的执行上下文。本规范中所有对运行中的执行上下文的引用都是指<code>surrounding agent</code>的运行中的执行上下文。</p>
<p>执行上下文栈被用来跟踪执行上下文。运行中的执行上下文始终是栈顶元素。每当控制权从与当前运行中的执行上下文相关的可执行代码转移到与该执行上下文无关的可执行代码时，都会创建一个新的执行环境。新创建的执行上下文被压入栈中，成为运行中的执行上下文。</p>
<p>一个执行上下文包含所有用于追踪其关联代码的执行进度所需的特定于实现的状态。 每个执行上下文至少具有表23中列出的状态组件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">组件</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">代码执行状态</td>
<td style="text-align:left">执行，暂停和恢复与此执行上下文关联的代码的计算所需的任何状态。</td>
</tr>
<tr>
<td style="text-align:left">函数</td>
<td style="text-align:left">如果此执行上下文正在计算函数对象的代码，则此组件的值就是该函数对象。如果上下文正在计算脚本或模块的代码，则该值为null。</td>
</tr>
<tr>
<td style="text-align:left">Realm</td>
<td style="text-align:left">关联代码访问ECMAScript资源的Realm记录</td>
</tr>
<tr>
<td style="text-align:left">ScriptOrModule</td>
<td style="text-align:left">相关代码来源的模块记录或脚本记录，如果没有源脚本或模块，例如在<code>InitializeHostDefinedRealm</code>中创建的原始执行上下文，该值为<code>null</code></td>
</tr>
</tbody>
</table>
<p>运行中的执行上下文对代码的计算可以在本规范中定义的不同点暂停。一旦运行中的执行上下文被暂停，不同的执行上下文可以成为运行中的执行上下文并开始计算其代码。在稍后的时间里，被暂停的执行上下文可以再次成为运行中的执行上下文，并在它之前被暂停的地方继续计算其代码。运行中的执行上下文状态的转换通常以堆栈的后进先出方式进行。然而，ECMAScript的一些特性要求运行中的执行上下文的非LIFO转换。</p>
<p>运行中的执行上下文的Realm组件的值被称为当前Realm记录，运行中的执行上下文的函数组件被称为激活的(active)函数对象。</p>
<p>ECMAScript代码的执行上下文具有表24中列出的其他状态组件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">组件</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LexicalEnvironment</td>
<td style="text-align:left">确定一个词法环境对象，用于解析此执行上下文内的代码创建的标识符引用。</td>
</tr>
<tr>
<td style="text-align:left">VariableEnvironment</td>
<td style="text-align:left">确定一个词法环境对象，其环境记录用于保存此执行上下文内的 <code>VariableStatements</code> 语句创建的绑定</td>
</tr>
</tbody>
</table>
<p>一个执行上下文的<code>LexicalEnvironment</code>组件和<code>VariableEnvironment</code>组件总是一个词法环境。</p>
<p>表示生成器对象的计算的执行上下文具有表24中列出的其他状态组件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">组件</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Generator</td>
<td style="text-align:left">此执行上下文正在计算的GeneratorObject</td>
</tr>
</tbody>
</table>
<p>在大多数情况下，只有运行中的执行上下文（执行上下文栈的栈顶元素）会由规范中的算法直接操作。 因此，当不加限定地使用术语<code>LexicalEnvironment</code>和<code>VariableEnvironment</code>时，它们是指运行中的执行上下文的那些组件。</p>
<p>执行上下文纯粹是一种规范机制，不需要与ECMAScript实现的任何特定内容相对应。 ECMAScript代码不可能直接访问或观察一个执行上下文。</p>
<h3 id="831-resolvebinding-name-env"><a class="markdownIt-Anchor" href="#831-resolvebinding-name-env"></a> 8.3.1 ResolveBinding ( name, [env] )</h3>
<p>ResolveBinding抽象操作用于确定作为字符串值传递的<code>name</code>的绑定。 可选参数env可用于显式提供要搜索绑定的词法环境。 在执行ECMAScript代码期间，使用以下算法执行ResolveBinding：</p>
<ol>
<li>如果没有传递<code>env</code>或<code>env</code>为<code>undefined</code>，则
<ol>
<li>令<code>env</code>为运行中的执行上下文的<code>LexicalEnvironment</code></li>
</ol>
</li>
<li>断言：<code>env</code>是词法环境</li>
<li>如果在严格模式代码中包含与要计算的语法产生式相匹配的代码，则令<code>strict</code>为<code>true</code>，否则令<code>strict</code>为<code>false</code></li>
<li>返回<code>GetIdentifierReference(env, name, strict )</code></li>
</ol>
<p>注：ResolveBinding的结果始终是一个Reference值，其引用的name组件等于<code>name</code>参数。</p>
<h2 id="84-任务和安排任务的主机操作"><a class="markdownIt-Anchor" href="#84-任务和安排任务的主机操作"></a> 8.4 任务和安排任务的主机操作</h2>
<p>Job是一个没有参数的抽象闭包，在当前没有其他ECMAScript计算正在进行时，它将启动ECMAScript计算。</p>
<p>Job是由ECMAScript主机环境安排执行的。本规范描述了主机钩子<code>HostEnqueuePromiseJob</code>来安排一种Job；主机环境可以定义其他安排作业的抽象操作。这些操作接受一个Job抽象闭包作为参数，并将其安排在未来某个时间执行。它们的实现必须符合以下要求：</p>
<ul>
<li>在未来的某个时间点，当没有运行中的执行上下文且执行上下文栈为空时，实现必须：
<ol>
<li>将一个执行上下文放push到执行上下文栈。</li>
<li>执行任何实现定义的准备步骤。</li>
<li>调用抽象闭包。</li>
<li>执行任何实现定义的清理步骤。</li>
<li>从执行上下文栈中弹出先前push的执行上下文。</li>
</ol>
</li>
<li>在任何时间点上，只有一个Job可以进行计算。</li>
<li>一旦开始计算一个Job，它必须在任何其它Job的计算开始之前运行完成。</li>
<li>抽象闭包必须返回一个常规完结，实现它自己对错误的处理。</li>
</ul>
<p>注：在调度方面，主机环境并不要求统一对待Job。例如，Web浏览器和Node.js将处理Promise的Job视为比其他Job更高的优先级；未来的功能可能会增加不被如此高优先级对待的Job。</p>
<h3 id="841-hostenqueuepromisejob-job-realm"><a class="markdownIt-Anchor" href="#841-hostenqueuepromisejob-job-realm"></a> 8.4.1 HostEnqueuePromiseJob ( job, realm )</h3>
<p><code>HostEnqueuePromiseJob</code>是一个由主机定义的抽象操作，它将Job抽象闭包<code>job</code>安排在未来某个时间执行。与该算法一起使用的抽象闭包旨在与处理Promise有关，或者以其他方式安排与Promise处理操作同等的优先级。</p>
<p>Realm参数被传递给没有标准要求的主机，它要么是空的，要么是一个Realm。</p>
<p>注：<code>PromiseResolveThenableJobs</code>的 Realm 是对<code>then</code>函数对象调用 <code>GetFunctionRealm</code>的结果。如果处理程序不是<code>undefined</code>，则<code>PromiseReactionJobs</code>的 Realm 是对处理程序调用<code>GetFunctionRealm</code>的结果。否则<code>realm</code>为<code>null</code>。例如，WHATWG HTML规范使用<code>realm</code>来检查运行脚本的能力和准备运行脚本。</p>
<p><code>HostEnqueuePromiseJob</code>的实现必须符合8.4的要求。此外，Job必须按先进先出的顺序安排，Job的运行顺序与安排它们的<code>HostEnqueuePromiseJob</code>调用的顺序相同。</p>
<h2 id="86-代理"><a class="markdownIt-Anchor" href="#86-代理"></a> 8.6 代理</h2>
<p>一个代理包括一组ECMAScript执行上下文、一个执行上下文栈、一个运行中的执行上下文、一个代理记录(Agent Record)和一个执行线程。除了执行线程之外，一个代理的各个组成部分只属于该代理。</p>
<p>一个代理的执行线程，在代理的执行上下文上独立于其他代理执行一项任务(Job)，但一个执行线程可以被多个代理用作执行线程，前提是共享该线程的代理没有一个<code>[[CanBlock]]</code>属性为真的代理记录。</p>
<p>注1：例如，一些Web浏览器在一个浏览器窗口的多个不相关的标签(Tab)中共享一个执行线程。</p>
<p>当代理的执行线程执行作业时，代理是这些作业中代码的周围代理(surrounding agent)。代码使用周围代理来访问代理内持有的规范级执行对象：运行中的执行上下文、执行上下文栈和代理记录的字段。</p>
<h2 id="87-代理集群"><a class="markdownIt-Anchor" href="#87-代理集群"></a> 8.7 代理集群</h2>
<p>一个代理集群是一组最大的代理集合，它可以通过在共享内存上进行操作来通信。</p>
<p>注1：不同代理中的程序可以通过未指定的方式共享内存。至少，<code>SharedArrayBuffer</code>对象的backing memory可以在集群中的代理之间共享。<br />
可能有的代理可以通过消息传递进行通信，但不能共享内存；它们从不在同一个代理集群中。</p>
<p>每个代理只属于一个代理集群。</p>
<p>注2：一个集群中的代理不需要在某个特定的时间点上都活着。如果代理A创建了另一个代理B，之后A终止，B创建了代理C，如果A可以与B分享一些内存，B可以与C分享一些内存，那么这三个代理就在同一个集群中。</p>
<p>一个集群内的所有代理的代理记录中<code>[[LittleEndian]]</code>属性必须有相同的值。</p>
<p>注3：如果一个代理集群内的不同代理有不同的<code>[[LittleEndian]]</code>值，那么就很难使用共享内存来处理多字节数据。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/ES规范/8 可执行代码和执行上下文.html">https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/ES规范/8 可执行代码和执行上下文.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/7%20%E6%8A%BD%E8%B1%A1%E6%93%8D%E4%BD%9C.html"><i class="fa fa-chevron-left">  </i><span>7 抽象操作</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/9%20%E6%99%AE%E9%80%9A%E5%92%8C%E5%A5%87%E5%BC%82%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA.html"><span>9 普通和奇异对象行为</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>