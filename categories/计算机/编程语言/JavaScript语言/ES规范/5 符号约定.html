<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="5 符号约定"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>5 符号约定 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%AC%A6%E5%8F%B7%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.</span> <span class="toc-text"> 5 符号约定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%8F%A5%E6%B3%95%E5%92%8C%E8%AF%8D%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text"> 5.1 句法和词法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#511-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 5.1.1 上下文无关文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#512-%E8%AF%8D%E6%B3%95%E5%92%8Cregexp%E7%9A%84%E6%96%87%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 5.1.2 词法和RegExp的文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 5.1.3 数字字符串文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#514-%E5%8F%A5%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 5.1.4 句法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#515-%E6%96%87%E6%B3%95%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 5.1.5 文法符号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#opt"><span class="toc-number">1.1.5.1.</span> <span class="toc-text"> opt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E4%BE%A7parameters"><span class="toc-number">1.1.5.2.</span> <span class="toc-text"> 左侧[parameters]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E4%BE%A7parameters"><span class="toc-number">1.1.5.3.</span> <span class="toc-text"> 右侧[parameters]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E4%BE%A7parameters-2"><span class="toc-number">1.1.5.4.</span> <span class="toc-text"> 右侧[?parameters]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E4%BE%A7~parameter"><span class="toc-number">1.1.5.5.</span> <span class="toc-text"> 右侧[+~parameter]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E7%AE%97%E6%B3%95%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.2.</span> <span class="toc-text"> 5.2 算法约定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#523-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 5.2.3 运行时语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5231-%E9%9A%90%E5%BC%8F%E5%AE%8C%E7%BB%93%E8%AE%B0%E5%BD%95%E5%80%BC"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 5.2.3.1 隐式完结记录值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5232-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text"> 5.2.3.2 抛出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5233-returnifabrupt"><span class="toc-number">1.2.1.3.</span> <span class="toc-text"> 5.2.3.3 ReturnIfAbrupt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5234-returnifabrupt%E7%BC%A9%E5%86%99"><span class="toc-number">1.2.1.4.</span> <span class="toc-text"> 5.2.3.4 ReturnIfAbrupt缩写</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">188</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">5 符号约定</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/">JavaScript语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/">ES规范</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="5-符号约定"><a class="markdownIt-Anchor" href="#5-符号约定"></a> 5 符号约定</h1>
<h2 id="51-句法和词法"><a class="markdownIt-Anchor" href="#51-句法和词法"></a> 5.1 句法和词法</h2>
<h3 id="511-上下文无关文法"><a class="markdownIt-Anchor" href="#511-上下文无关文法"></a> 5.1.1 上下文无关文法</h3>
<p>一个上下文无关文法由一定数量的产生式组成。每个产生式的左边部分（产生式通常以冒号分隔左右部分）是一个被称为非终结符的抽象符号，右边部分是零或多个非终结符和终结符的序列。任何文法，它的终结符都来自指定的字母集。</p>
<span id="more"></span>
<p>链产生式(chain production)是一种右边部分恰好有一个非终结符跟着零个或多个终结符的产生式。</p>
<p>从一个由单个重要的非终结符（叫做目标符goal symbol）组成的句子开始，给定的上下文无关文法就表示一种语言，即：将产生式右边部分的每个非终结符，替换成左边部分是该非终结符的产生式的右边部分，如此反复替换就得到了可能的终结符序列集合（可能是无限的）。</p>
<h3 id="512-词法和regexp的文法"><a class="markdownIt-Anchor" href="#512-词法和regexp的文法"></a> 5.1.2 词法和RegExp的文法</h3>
<p>第11章给出了 ECMAScript 的词法。此文法的终结符Unicode 代码单元符合第10.1章定义的 SourceCharacter 的规则。它定义了一套产生式，从目标符 InputElementDiv ，InputElementTemplateTail 、 InputElementRegExp 或InputElementRegExpOrTemplateTail 开始，描述了如何将这样的代码点序列转换成一个输入元素序列。</p>
<p>空白字符和注释之外的输入元素构成 ECMAScript 句法的终结符，它们被称为 ECMAScript 的 Token。这些 Token 是，ECMAScript 语言的保留字、标识符、字面量、标点符号。此外，行终止符虽然不被视为 Token，但会成为输入元素流的一部分，用于指导自动插入分号的处理（11.9）。空白字符和单行注释会被简单地丢弃，不会出现在句法的输入元素流中。如果一个多行注释（即形式为<code>/*...*/</code>的注释，不管是否跨越多行）不包含行终止符也会简单地丢弃，但如果一个多行注释包含一个或多个行终止符，那么，注释会被替换为一个行终止符，成为句法的输入元素流的一部分。</p>
<p>21.2.1 给出了 ECMAScript 的 正则文法。此文法的终结符代码点也由 SourceCharacter 定义。它定义了一套产生式，从目标符 Pattern 起始，描述了如何将这样的代码点序列翻译成一个正则表达式模式。</p>
<p>词法和正则文法的产生式使用两个冒号<code>::</code>来分隔。词法和正则的文法共享某些产生式。</p>
<h3 id="513-数字字符串文法"><a class="markdownIt-Anchor" href="#513-数字字符串文法"></a> 5.1.3 数字字符串文法</h3>
<p>另一种文法用于将字符串转换为数字值。此文法与词法中与数字字面值有关的部分类似，并且它有作为终结符的SourceCharacter。此文法出现在 7.1.3.1 。</p>
<p>数字字符串文法的产生式使用三个冒号<code>:::</code>来分隔。</p>
<h3 id="514-句法"><a class="markdownIt-Anchor" href="#514-句法"></a> 5.1.4 句法</h3>
<p>第 11、12、13、14 和 15 章给出了 ECMAScript 的句法。词法定义的 ECMAScript Token 是此文法的终结符（5.1.2）。它定义了一组起始于两个可替代的目标符<code>Script</code>和<code>Module</code>的产生式，描述了怎样的 Token 序列才能形成句法上正确的 ECMAScript 程序独立组件。</p>
<p>当将代码点流被解析为 ECMAScript 脚本(Script)或模块(Module)时，首先通过反复应用词法将其转换为输入元素流，这个输入元素流紧接着会通过一次应用句法来解析。当输入元素流没有更多 Token 时，如果 Token 不能解析为目标非终结符（Script或Module）的单一实例，那么输入流在句法上存在错误。</p>
<p>句法的产生式使用一个冒号<code>:</code>来分隔。</p>
<p>第 12、13、14 和 15 章给出的句法，并不能完全说明一个正确的 ECMAScript 脚本或模块能接受的 Token 序列。某些额外的 Token 序列也被接受，即某些特殊位置（如行结束符前）加入分号可以被文法接受。此外，如果在某些“尴尬”的位置出现了行结束符，则文法描述的某些 Token 序列不被接受。</p>
<p>在某些情况下，为了避免歧义，句法使用通用的产生式，这些产生式允许token序列不形成有效的ECMAScript脚本或模块。 例如，此技术用于对象字面值和对象解构(destructuring)模式。 在这种情况下，提供了更具限制性的补充语法，该语法进一步限制了可接受的token序列。 在某些上下文，当明确指定时，将使用补充语法的目标符再次解析与此类产生式相对应的输入元素。 当输入元素流没有更多 Token 时，如果通过cover语法分析的输入元素流中的token不能被解析为相应补充目标符的单个实例，则输入流在句法上存在错误。</p>
<h3 id="515-文法符号"><a class="markdownIt-Anchor" href="#515-文法符号"></a> 5.1.5 文法符号</h3>
<p>词法、正则表达式文法、数字字符串文法的终结符使用等宽字体显示，无论是在语法的产生式中还是在整个规范中，只要文本直接涉及到这样的终结符。这些将完全按照书面形式出现在脚本中。 以此方式指定的所有终结符代码点应理解为Basic Latin范围中的适当Unicode代码点，而不是其他Unicode范围中任何外观相似的代码点。</p>
<p>非终结符以斜体显示。一个非终结符（也叫产生式）的定义由非终结符的名称后跟一个或多个冒号给出。（冒号的数量表示产生式所属的文法。）非终结符的右侧有一个或多个替代项跟在下一行。 例如，句法定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WhileStatement :</span><br><span class="line">	while ( Expression ) Statement</span><br></pre></td></tr></table></figure>
<p>表示这个非终结符 WhileStatement 代表 token <code>while</code>，后跟左括号token，然后跟着 Expression，再后跟右括号token，最后跟 Statement。这里出现的 Expression 和 Statement 本身是非终结符。另一个例子，句法定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArgumentList :</span><br><span class="line">	AssignmentExpression</span><br><span class="line">	ArgumentList , AssignmentExpression</span><br></pre></td></tr></table></figure>
<p>表示这个 ArgumentList 可以代表一个 AssignmentExpression，或者一个 ArgumentList后跟一个逗号以及一个 AssignmentExpression。这个 ArgumentList 的定义是递归的，也就是说，它定义它自身。其结果是，一个 ArgumentList 可能包含用逗号隔开的任意正数个参数，每个参数表达式是一个 AssignmentExpression。非终结符这种递归定义是很普遍的。</p>
<h4 id="opt"><a class="markdownIt-Anchor" href="#opt"></a> opt</h4>
<p>终结符或非终结符可能会出现后缀下标<code>opt</code>，表示它是可选符号。包含可选符号的替代项实际上表示两个右边部分，一个是省略可选元素的，另一个是包含可选元素的。这意味着：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VariableDeclaration :</span><br><span class="line">	BindingIdentifier Initializer&#123;opt&#125;</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VariableDeclaration :</span><br><span class="line">	BindingIdentifier</span><br><span class="line">	BindingIdentifier Initializer</span><br></pre></td></tr></table></figure>
<p>并且</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IterationStatement :</span><br><span class="line">	for ( LexicalDeclaration Expression&#123;opt&#125; ; Expression&#123;opt&#125; ) Statement</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IterationStatement :</span><br><span class="line">	for ( LexicalDeclaration ; Expression&#123;opt&#125; ) Statement</span><br><span class="line">	for ( LexicalDeclaration Expression ; Expression&#123;opt&#125; ) Statement</span><br></pre></td></tr></table></figure>
<p>它又是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IterationStatement :</span><br><span class="line">	for ( LexicalDeclaration ; ) Statement</span><br><span class="line">	for ( LexicalDeclaration ; Expression ) Statement</span><br><span class="line">	for ( LexicalDeclaration Expression ; ) Statement</span><br><span class="line">	for ( LexicalDeclaration Expression ; Expression ) Statement</span><br></pre></td></tr></table></figure>
<p>因此，在这个例子中，非终结符 IterationStatement 右侧实际上有 4 个替代项。</p>
<h4 id="左侧parameters"><a class="markdownIt-Anchor" href="#左侧parameters"></a> 左侧[parameters]</h4>
<p>可以通过形如<code>[parameters]</code>的下标记号对产生式进行参数化，该记号可能出现在产生式所定义的非终结符的后缀。<code>parameters</code>可以是单个名称，也可以是逗号分隔的名称列表。 参数化产生式是一组产生式的简写形式，它是附在参数化的非终结符后面的，所有参数名称前面跟一个下划线的所有组合。 这意味着：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StatementList[Return] :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StatementList :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br><span class="line">StatementList_Return :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>并且</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StatementList[Return, In] :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StatementList :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br><span class="line">StatementList_Return :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br><span class="line">StatementList_In :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br><span class="line">StatementList_Return_In :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>多个参数可生成组合数量（幂集）的产生式，但并非所有的产生式都必须在完整的文法中引用。</p>
<h4 id="右侧parameters"><a class="markdownIt-Anchor" href="#右侧parameters"></a> 右侧[parameters]</h4>
<p>也可以对产生式右边部分的非终结符引用进行参数化。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StatementList :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement[In]</span><br></pre></td></tr></table></figure>
<p>相对于（没有不包括参数的情况？）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StatementList :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement_In</span><br></pre></td></tr></table></figure>
<p>非终结符引用可能同时具有参数列表和<code>opt</code>后缀，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VariableDeclaration :</span><br><span class="line">	BindingIdentifier Initializer[In]&#123;opt&#125;</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VariableDeclaration :</span><br><span class="line">	BindingIdentifier</span><br><span class="line">	BindingIdentifier Initializer_In</span><br></pre></td></tr></table></figure>
<h4 id="右侧parameters-2"><a class="markdownIt-Anchor" href="#右侧parameters-2"></a> 右侧[?parameters]</h4>
<p>在右边部分非终结符引用的参数名称前添加<code>?</code>号，会使得参数值取决于当前产生式左边部分符号上参数名称的出现与否。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VariableDeclaration[In] :</span><br><span class="line">	BindingIdentifier Initializer[?In]</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VariableDeclaration :</span><br><span class="line">	BindingIdentifier Initializer</span><br><span class="line">VariableDeclaration_In :</span><br><span class="line">	BindingIdentifier Initializer_In</span><br></pre></td></tr></table></figure>
<h4 id="右侧~parameter"><a class="markdownIt-Anchor" href="#右侧~parameter"></a> 右侧[+~parameter]</h4>
<p>如果右侧替代项以<code>[+parameter]</code>为前缀，则仅当命名参数用于引用产生式非终结符时，该替代项才可用。如果右侧替代项以<code>[~parameter]</code>为前缀，则仅当命名参数没有用于引用产生式非终结符时，该替代项才可用。这意味着：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StatementList[Return] :</span><br><span class="line">	[+Return] ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StatementList :</span><br><span class="line">	ExpressionStatement</span><br><span class="line">StatementList_Return :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>并且</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StatementList[Return] :</span><br><span class="line">	[~Return] ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>是下面的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StatementList :</span><br><span class="line">	ReturnStatement</span><br><span class="line">	ExpressionStatement</span><br><span class="line">StatementList_Return :</span><br><span class="line">	ExpressionStatement</span><br></pre></td></tr></table></figure>
<p>如果文法定义的冒号后面出现文字 “one of”，它们表示下面行中的每个终结符都是替代定义。例如，ECMAScript的词法包含产生式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NonZeroDigit :: one of</span><br><span class="line">	1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>这只是以下内容的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NonZeroDigit ::</span><br><span class="line">	1</span><br><span class="line">	2</span><br><span class="line">	3</span><br><span class="line">	4</span><br><span class="line">	5</span><br><span class="line">	6</span><br><span class="line">	7</span><br><span class="line">	8</span><br><span class="line">	9</span><br></pre></td></tr></table></figure>
<p>如果短语<code>[empty]</code>出现在产生式右边，则表示产生式右边既不包含终结符也不包含非终结符。</p>
<p>如果短语<code>[lookahead ∉ set]</code>出现在产生式右边，则表示：紧跟其后的输入token序列不能是给定集合的元素（如果紧随其后的输入 token 序列是给定集合的元素，则不使用该产生式） 该集合可以写成用逗号分隔的列表，该列表是用大括号括起来的一个或两个元素终结符序列。 为了方便起见，该集合也可以写为非终结符，在这种情况下，它表示该非终结符可以扩展到的所有终结符的集合。 如果集合由单个终结符组成，则可以使用短语<code>[lookahead ≠ terminal]</code>。<br />
例如，给定以下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DecimalDigit :: one of</span><br><span class="line">	0 1 2 3 4 5 6 7 8 9</span><br><span class="line">DecimalDigits ::</span><br><span class="line">	DecimalDigit</span><br><span class="line">	DecimalDigits DecimalDigit</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LookaheadExample ::</span><br><span class="line">	n [lookahead ∉ &#123;1, 3, 5, 7, 9&#125;] DecimalDigits</span><br><span class="line">	DecimalDigit [lookahead ∉ DecimalDigit]</span><br></pre></td></tr></table></figure>
<p>匹配字母n后跟一个或多个十进制数字，且第一个数字是偶数。或者匹配一个十进制数字，后面不能跟着另一个十进制数字。</p>
<p>如果短语<code>[no LineTerminator here]</code>出现在句法产生式的右侧，它表示该产生式是一个受限的产生式：如果输入流中的行终结符出现在指定位置，则不能使用该产生式。例如，产生式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThrowStatement :</span><br><span class="line">	throw [no LineTerminator here] Expression ;</span><br></pre></td></tr></table></figure>
<p>表示如果脚本中的行终结符出现在<code>throw</code>token和<code>Expression</code>之间，则不能使用该产生式。</p>
<p>行终结符除了禁止出现在受限的产生式，可以在输入元素流的任何两个连续 Token 之间出现任意次数，而不会影响脚本的句法可接受性。</p>
<p>当词法或数字字符串文法的产生式中的替代项以多代码点token的形式出现，它表示组成这样token的代码点序列。</p>
<p>产生式右侧可以通过使用短语<code>but not</code>跟着要排除的扩展来指定不允许某些扩展。 例如，产生式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Identifier ::</span><br><span class="line">	IdentifierName but not ReservedWord</span><br></pre></td></tr></table></figure>
<p>表示非终结符Identifier可以由任何可以替换IdentifierName的代码点序列替换，前提是相同的代码点序列不能替换ReservedWord。</p>
<p>最后，对于实际上不可能列出全部替代项的某些非终结符，我们用无衬线字体写出描述性的短语来描述它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SourceCharacter ::</span><br><span class="line">	any Unicode code point</span><br></pre></td></tr></table></figure>
<h2 id="52-算法约定"><a class="markdownIt-Anchor" href="#52-算法约定"></a> 5.2 算法约定</h2>
<p>规范通常使用编号列表来指定算法中的步骤。 这些算法用于精确指定ECMAScript语言构造所需的语义。 该算法无意暗示使用任何特定的实现技术。 实际上，可能有更有效的算法可用于实现给定功能。</p>
<p>可以对算法进行显式参数化，在这种情况下，必须提供参数的名称和用法作为算法定义的一部分。 为了便于在本规范的多个部分中使用它们，某些算法（称为抽象操作）以参数化功能形式进行命名和编写，以便可以从其他算法中按名称进行引用。 通常使用功能性应用程序样式（例如<code>operationName(arg1, arg2)</code>）来引用抽象操作。 一些抽象操作被视为类似<code>class</code>的规范说明抽象的多态调度方法。 通常使用诸如<code>someValue.operationName(arg1, arg2)</code>之类的方法应用程序样式来引用此类类似于方法的抽象操作。</p>
<p>算法可以与ECMAScript语法之一的产生式相关联。 具有多个替代定义的产生式通常会对每个备选方案使用不同的算法。 当算法与语法产生式关联时，它可以引用产生替代项的终结符和非终结符，就像它们是算法的参数一样。 当以这种方式使用时，非终止符号指的是在解析源文本时匹配的实际替代定义。</p>
<p>当算法与替代产生式相关联时，通常会在没有任何“ []”语法注释的情况下显示替代项。 这样的注释应该只影响替代的句法识别，而对替代的关联语义没有影响。</p>
<p>除非另有明确说明，否则所有产生式链对于可能应用于该产生式左侧非终结符的每种算法都有一个隐式定义。 隐式定义只是将具有相同参数（如果有）的相同算法名称重新应用于产生式链的唯一右侧非终结符，然后返回结果。 例如，假设有一个产生式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Block :</span><br><span class="line">      &#123; StatementList &#125;</span><br></pre></td></tr></table></figure>
<p>但没有为该产生式明确指定相应的计算算法。 如果在某种算法中存在以下形式的陈述：“返回<code>Block</code>的计算结果”，则隐含存在以下形式的计算算法：</p>
<ul>
<li>返回<code>StatementList</code>的计算结果</li>
</ul>
<p>为了表达清楚，可以将算法步骤细分为连续的子步骤。 子步骤是缩进的，它们本身可以进一步分为缩进的子步骤。 大纲编号约定用于标识子步骤，其中第一级子步骤标记为小写字母字符，第二级子步骤标记为小写罗马数字。 如果需要三个以上的级别，这些规则将使用数字标签重复到第四个级别。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Top-level step</span><br><span class="line">    a. Substep.</span><br><span class="line">    b. Substep.</span><br><span class="line">        i. Subsubstep.</span><br><span class="line">            1. Subsubsubstep</span><br><span class="line">                a. Subsubsubsubstep</span><br><span class="line">                    i. Subsubsubsubsubstep</span><br></pre></td></tr></table></figure>
<p>步骤或子步骤可以写为条件子步骤的“ if”谓词。 在这种情况下，仅当谓词为true时才应用子步骤。 如果某个步骤或子步骤以单词“ else”开头，则该谓词是先前的“ if”谓词步骤在相同级别上的取反。</p>
<p>一个步骤可以指定其子步骤的迭代应用。</p>
<p>以<code>Assert:</code>开始的步骤断言了其算法的不变条件。 此类断言用于创建显式的算法不变量，否则它们将是隐式的。 这样的断言不增加任何附加的语义要求，因此不需要由实现来检查。 它们仅用于阐明算法。</p>
<p>本章后面定义的数学运算（如加，减，否定，乘法，除法和数学函数）应始终理解为对数学实数计算精确的数学结果，除非另有说明，否则不包括无穷大且不包括 区别于正零的负零。 该标准中对浮点算术建模的算法在必要时包括显式步骤，以处理无限性和带符号的零并执行舍入。 如果将数学运算或函数应用于浮点数，则应将其理解为应用于该浮点数表示的确切数学值； 这样的浮点数必须是有限的，如果它是+0或-0，则相应的数学值就是0。</p>
<p>数学函数<code>abs(x)</code>产生x的绝对值，如果x为负（小于零），则为-x，否则为x本身。</p>
<p>如果x为正数，则数学函数<code>sign(x)</code>生成1，如果x为负数，则生成-1。 对于x为零的情况，本标准不使用符号函数。</p>
<p>数学函数<code>min(x1, x2, ..., xn)</code>产生从<code>x1</code>到<code>xn</code>的数学上的最小值。数学函数<code>max(x1, x2, ..., xn)</code>产生从<code>x1</code>到<code>xn</code>的数学上的最大值。这些数学函数的定义域和值域包括正无穷和负无穷。</p>
<p>记号<code>x modulo y</code>（y必须是非零有限值）计算出一个与<code>y</code>相同符号（或0）的值<code>k</code>，使得<code>abs(k) &lt; abs(y)</code>并且对于某个整数<code>q</code>有<code>x-k=q*y</code></p>
<p>数学函数<code>floor(x)</code>产生一个不大于x的最大值（接近正无穷）<br />
注意：<code>floor(x)=x-(x modulo 1)</code></p>
<h3 id="523-运行时语义"><a class="markdownIt-Anchor" href="#523-运行时语义"></a> 5.2.3 运行时语义</h3>
<p>指定了必须在运行时调用的语义的算法，称为运行时语义。运行时语义是由抽象操作或面向语法的操作来定义的。这种算法总是返回一个完结记录。</p>
<h4 id="5231-隐式完结记录值"><a class="markdownIt-Anchor" href="#5231-隐式完结记录值"></a> 5.2.3.1 隐式完结记录值</h4>
<p>本规范的算法经常隐含地返回<code>[[Type]]</code>为<code>normal</code>的完成记录。除非从上下文中可以看出，否则返回一个不是完结记录的值的算法语句，例如</p>
<ol>
<li>返回<code>&quot;Infinity&quot;</code></li>
</ol>
<p>意味着</p>
<ol>
<li>返回<code>NormalCompletion(&quot;Infinity&quot;)</code></li>
</ol>
<p>然而，如果 &quot;return &quot;语句的值表达式是一个完结记录构造字面值，那么将返回产生的完结记录。如果值表达式是对一个抽象操作的调用，&quot;return &quot;语句只是返回由抽象操作产生的完结记录。</p>
<p>抽象操作 <code>Completion(completionRecord)</code> 被用来强调正在返回先前计算的完结记录。<code>Completion</code>抽象操作需要一个参数：<code>completionRecord</code>，并执行以下步骤：</p>
<ol>
<li>断言：<code>completionRecord</code>是完结记录</li>
<li>将<code>completionRecord</code>作为此抽象操作的完结记录返回</li>
</ol>
<p>算法步骤中没有值的&quot;return&quot; 语句意味着：</p>
<ol>
<li>返回<code>NormalCompletion(undefined)</code></li>
</ol>
<p>在没有明确要求完整的完结记录值的上下文中，对完结记录值的任何引用都等同于对完结记录值的[[Value]]字段的明确引用，除非完结记录是非常规完结。</p>
<h4 id="5232-抛出异常"><a class="markdownIt-Anchor" href="#5232-抛出异常"></a> 5.2.3.2 抛出异常</h4>
<p>算法步骤中抛出异常，例如</p>
<ol>
<li>抛出 TypeError 异常</li>
</ol>
<p>意味着：</p>
<ol>
<li>返回<code>ThrowCompletion(一个新创建的TypeError对象)</code></li>
</ol>
<h4 id="5233-returnifabrupt"><a class="markdownIt-Anchor" href="#5233-returnifabrupt"></a> 5.2.3.3 ReturnIfAbrupt</h4>
<p>算法步骤中：</p>
<ol>
<li><code>ReturnIfAbrupt(argument)</code></li>
</ol>
<p>意味着：</p>
<ol>
<li>如果<code>argument</code>是非常规完结，返回<code>argument</code></li>
<li>否则如果<code>argument</code>是完结记录，将<code>argument</code>设为<code>argument.[[Value]]</code></li>
</ol>
<p>算法步骤</p>
<ol>
<li><code>ReturnIfAbrupt(AbstractOperation())</code></li>
</ol>
<p>意味着：</p>
<ol>
<li>令<code>hygienicTemp</code>为<code>AbstractOperation()</code></li>
<li>如果<code>hygienicTemp</code>是非常规完结，返回<code>hygienicTemp</code></li>
<li>否则如果<code>hygienicTemp</code>是完结记录，将<code>hygienicTemp</code>设为<code>hygienicTemp.[[Value]]</code></li>
</ol>
<p>其中<code>hygienicTemp</code>是临时的，只在与<code>ReturnIfAbrupt</code>有关的步骤中可见。</p>
<p>算法步骤：</p>
<ol>
<li>令<code>result</code>为<code>AbstractOperation(ReturnIfAbrupt(argument))</code></li>
</ol>
<p>意味着：</p>
<ol>
<li>如果<code>argument</code>是非常规完结，返回<code>argument</code></li>
<li>如果<code>argument</code>是完结记录，将<code>argument</code>设为<code>argument.[[Value]]</code></li>
<li>令<code>result</code>为<code>AbstractOperation(argument)</code></li>
</ol>
<h4 id="5234-returnifabrupt缩写"><a class="markdownIt-Anchor" href="#5234-returnifabrupt缩写"></a> 5.2.3.4 ReturnIfAbrupt缩写</h4>
<p>抽象操作和语法导向操作的调用，如果前缀为<code>?</code>表示<code>ReturnIfAbrupt</code>应该被应用到产生的完成记录。例如，步骤：</p>
<ol>
<li>? <code>OperationName()</code></li>
</ol>
<p>等价于以下步骤：</p>
<ol>
<li><code>ReturnIfAbrupt(OperationName())</code></li>
</ol>
<p>类似的，对于方法应用风格来说，步骤：</p>
<ol>
<li>? <code>someValue.OperationName()</code></li>
</ol>
<p>等价于：</p>
<ol>
<li><code>ReturnIfAbrupt(someValue.OperationName())</code></li>
</ol>
<p>类似地，前缀<code>!</code>用来表示抽象或语法导向的操作的后续调用将永远不会返回一个非常规完结，由此产生的完结记录的<code>[[Value]]</code>字段应该被用来代替操作的返回值。例如步骤：</p>
<ol>
<li>令<code>val</code>为! <code>OperationName()</code></li>
</ol>
<p>等价于以下步骤：</p>
<ol>
<li>令<code>val</code>为<code>OperationName()</code></li>
<li>断言：<code>val</code>永远不是非常规完结</li>
<li>如果<code>val</code>是完结记录，将<code>val</code>设为<code>val.[[Value]]</code></li>
</ol>
<p>用于运行时语义的语法导向操作通过在操作的调用前放置 <code>!</code> 或 <code>?</code> 来使用这个缩写。</p>
<ol>
<li>执行! <code>NonTerminal</code>的<code>SyntaxDirectedOperation</code></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/ES规范/5 符号约定.html">https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/ES规范/5 符号约定.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/4%20%E6%A6%82%E8%BF%B0.html"><i class="fa fa-chevron-left">  </i><span>4 概述</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/6%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC.html"><span>6 数据类型和值</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>