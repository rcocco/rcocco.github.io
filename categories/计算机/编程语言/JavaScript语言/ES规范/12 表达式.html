<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="12 表达式"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>12 表达式 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text"> 12 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E6%A0%87%E8%AF%86%E7%AC%A6identifiers"><span class="toc-number">1.1.</span> <span class="toc-text"> 12.1 标识符(Identifiers)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1211-%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E6%97%A9%E6%9C%9F%E9%94%99%E8%AF%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 12.1.1 静态语义:早期错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1215-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 12.1.5 运行时语义:绑定初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1216-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 12.1.6 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E5%9F%BA%E6%9C%AC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> 12.2 基本表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1222-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 12.2.2 this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12221-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 12.2.2.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1223-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 12.2.3 标识符引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1224-%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 12.2.4 字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1225-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 12.2.5 数组初始化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1226-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 12.2.6 对象初始化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12268-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.5.1.</span> <span class="toc-text"> 12.2.6.8 运行时语义:计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12269-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89propertydefinitionevaluation"><span class="toc-number">1.2.5.2.</span> <span class="toc-text"> 12.2.6.9 运行时语义:PropertyDefinitionEvaluation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1229-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.2.6.</span> <span class="toc-text"> 12.2.9 模板字面值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12291-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89-templatestrings"><span class="toc-number">1.2.6.1.</span> <span class="toc-text"> 12.2.9.1 运行时语义: TemplateStrings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12292-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89-argumentlistevaluation"><span class="toc-number">1.2.6.2.</span> <span class="toc-text"> 12.2.9.2 运行时语义: ArgumentListEvaluation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12293-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89-gettemplateobject-templateliteral"><span class="toc-number">1.2.6.3.</span> <span class="toc-text"> 12.2.9.3 运行时语义: GetTemplateObject ( templateLiteral )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text"> 12.3 左侧表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1232-%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 12.3.2 属性访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1233-new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 12.3.3 new操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12331-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.2.1.</span> <span class="toc-text"> 12.3.3.1 运行时语义:计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#123311-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89evaluatenewconstructproduction-arguments"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text"> 12.3.3.1.1 运行时语义:EvaluateNew(constructProduction, arguments)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1234-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 12.3.4 函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12341-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.3.1.</span> <span class="toc-text"> 12.3.4.1 运行时语义:计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12343-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89evaluatedirectcall-func-thisvalue-arguments-tailposition"><span class="toc-number">1.3.3.2.</span> <span class="toc-text"> 12.3.4.3 运行时语义:EvaluateDirectCall( func, thisValue, arguments, tailPosition )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1235-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 12.3.5 super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12351-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.4.1.</span> <span class="toc-text"> 12.3.5.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1236-%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 12.3.6 参数列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12361-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89argumentlistevaluation"><span class="toc-number">1.3.5.1.</span> <span class="toc-text"> 12.3.6.1 运行时语义:ArgumentListEvaluation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1239-%E5%8F%AF%E9%80%89%E9%93%BE"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 12.3.9 可选链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13391-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.6.1.</span> <span class="toc-text"> 13.3.9.1 运行时语义:计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13392-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89chainevaluation"><span class="toc-number">1.3.6.2.</span> <span class="toc-text"> 13.3.9.2 运行时语义:ChainEvaluation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12311-%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 12.3.11 标签模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#123111-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.7.1.</span> <span class="toc-text"> 12.3.11.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12312-meta%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.8.</span> <span class="toc-text"> 12.3.12 Meta属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#123121-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.8.1.</span> <span class="toc-text"> 12.3.12.1 运行时语义:计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E6%9B%B4%E6%96%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text"> 12.4 更新表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1244-%E5%90%8E%E7%BC%80%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 12.4.4 后缀递增运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12441-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 12.4.4.1 运行时语义:计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text"> 12.5 一元运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1254-delete%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 12.5.4 delete运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12542-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.1.1.</span> <span class="toc-text"> 12.5.4.2 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1255-void%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 12.5.5 void运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12551-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.2.1.</span> <span class="toc-text"> 12.5.5.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1256-typeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 12.5.6 typeof 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12561-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.3.1.</span> <span class="toc-text"> 12.5.6.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1257-%E5%89%8D%E7%BC%80%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 12.5.7 前缀递增运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12571-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.4.1.</span> <span class="toc-text"> 12.5.7.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1259-%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 12.5.9 一元+运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12591-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.5.1.</span> <span class="toc-text"> 12.5.9.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12510-%E4%B8%80%E5%85%83-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.6.</span> <span class="toc-text"> 12.5.10 一元-运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#125101-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.6.1.</span> <span class="toc-text"> 12.5.10.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12511-%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97~"><span class="toc-number">1.5.7.</span> <span class="toc-text"> 12.5.11 按位取反运算(~)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#125111-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.7.1.</span> <span class="toc-text"> 12.5.11.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12512-%E9%80%BB%E8%BE%91%E9%9D%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.8.</span> <span class="toc-text"> 12.5.12 逻辑非运算符(!)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#125121-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.8.1.</span> <span class="toc-text"> 12.5.12.1 运行时语义:计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#126-%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text"> 12.6 指数运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1263-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 12.6.3 运行时语义:计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12734-%E5%BA%94%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.1.1.</span> <span class="toc-text"> 12.7.3.4 应用**运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#126-%E4%B9%98%E6%80%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text"> 12.6 乘性运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1263-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97-2"><span class="toc-number">1.7.1.</span> <span class="toc-text"> 12.6.3 运行时语义:计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12631-%E5%BA%94%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.1.1.</span> <span class="toc-text"> 12.6.3.1 应用*运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12632-%E5%BA%94%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.1.2.</span> <span class="toc-text"> 12.6.3.2 应用&#x2F;运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12633-%E5%BA%94%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.1.3.</span> <span class="toc-text"> 12.6.3.3 应用%运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127-%E5%8A%A0%E6%80%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text"> 12.7 加性运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1273-%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 12.7.3 加法运算符(+)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12731-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.8.1.1.</span> <span class="toc-text"> 12.7.3.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1274-%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6-"><span class="toc-number">1.8.2.</span> <span class="toc-text"> 12.7.4 减法运算符(-)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12741-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.8.2.1.</span> <span class="toc-text"> 12.7.4.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1275-%E5%AF%B9%E6%95%B0%E5%AD%97%E5%BA%94%E7%94%A8%E5%8A%A0%E6%80%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.3.</span> <span class="toc-text"> 12.7.5 对数字应用加性运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.</span> <span class="toc-text"> 12.8 移位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1283-%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.1.</span> <span class="toc-text"> 12.8.3 左移运算符(&lt;&lt;)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12831-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.1.1.</span> <span class="toc-text"> 12.8.3.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1284-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.2.</span> <span class="toc-text"> 12.8.4 有符号右移运算符(&gt;&gt;)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12841-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.2.1.</span> <span class="toc-text"> 12.8.4.1 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1285-%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.3.</span> <span class="toc-text"> 12.8.5 无符号右移运算符(&gt;&gt;&gt;)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12851-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.3.1.</span> <span class="toc-text"> 12.8.5.1 运行时语义:计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.10.</span> <span class="toc-text"> 12.9 关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1293-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89-%E8%AE%A1%E7%AE%97"><span class="toc-number">1.10.1.</span> <span class="toc-text"> 12.9.3 运行时语义: 计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1294-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89-instanceofoperatoro-c"><span class="toc-number">1.10.2.</span> <span class="toc-text"> 12.9.4 运行时语义: InstanceofOperator(O, C)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1210-%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.11.</span> <span class="toc-text"> 12.10 相等运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12103-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.11.1.</span> <span class="toc-text"> 12.10.3 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1211-%E4%BA%8C%E5%85%83%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.12.</span> <span class="toc-text"> 12.11 二元位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12113-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89-%E8%AE%A1%E7%AE%97"><span class="toc-number">1.12.1.</span> <span class="toc-text"> 12.11.3 运行时语义: 计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1212-%E4%BA%8C%E5%85%83%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.13.</span> <span class="toc-text"> 12.12 二元逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12123-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89-%E8%AE%A1%E7%AE%97"><span class="toc-number">1.13.1.</span> <span class="toc-text"> 12.12.3 运行时语义: 计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1213-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.14.</span> <span class="toc-text"> 12.13 条件运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12133-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.14.1.</span> <span class="toc-text"> 12.13.3 运行时语义:计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1214-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.15.</span> <span class="toc-text"> 12.14 赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12144-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.15.1.</span> <span class="toc-text"> 12.14.4 运行时语义:计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12145-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.15.2.</span> <span class="toc-text"> 12.14.5 解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#121451-%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E6%97%A9%E6%9C%9F%E9%94%99%E8%AF%AF"><span class="toc-number">1.15.2.1.</span> <span class="toc-text"> 12.14.5.1 静态语义:早期错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#121452-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89destructuringassignmentevaluation"><span class="toc-number">1.15.2.2.</span> <span class="toc-text"> 12.14.5.2 运行时语义:DestructuringAssignmentEvaluation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#121453-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89iteratordestructuringassignmentevaluation"><span class="toc-number">1.15.2.3.</span> <span class="toc-text"> 12.14.5.3 运行时语义:IteratorDestructuringAssignmentEvaluation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#121454-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89keyeddestructuringassignmentevaluation"><span class="toc-number">1.15.2.4.</span> <span class="toc-text"> 12.14.5.4 运行时语义:KeyedDestructuringAssignmentEvaluation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1215-%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.16.</span> <span class="toc-text"> 12.15 逗号运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12153-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.16.1.</span> <span class="toc-text"> 12.15.3 运行时语义:计算</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">172</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">12 表达式</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/">JavaScript语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/">ES规范</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="12-表达式"><a class="markdownIt-Anchor" href="#12-表达式"></a> 12 表达式</h1>
<h2 id="121-标识符identifiers"><a class="markdownIt-Anchor" href="#121-标识符identifiers"></a> 12.1 标识符(Identifiers)</h2>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IdentifierReference[Yield] :</span><br><span class="line">	Identifier</span><br><span class="line">	[~Yield] yield</span><br><span class="line"></span><br><span class="line">BindingIdentifier[Yield] :</span><br><span class="line">	Identifier</span><br><span class="line">	[~Yield] yield</span><br><span class="line"></span><br><span class="line">LabelIdentifier[Yield] :</span><br><span class="line">	Identifier</span><br><span class="line">	[~Yield] yield</span><br><span class="line"></span><br><span class="line">Identifier :</span><br><span class="line">	IdentifierName but not ReservedWord</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="1211-静态语义早期错误"><a class="markdownIt-Anchor" href="#1211-静态语义早期错误"></a> 12.1.1 静态语义:早期错误</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BindingIdentifier : Identifier</span><br></pre></td></tr></table></figure>
<h3 id="1215-运行时语义绑定初始化"><a class="markdownIt-Anchor" href="#1215-运行时语义绑定初始化"></a> 12.1.5 运行时语义:绑定初始化</h3>
<p>接受参数<code>value</code>和<code>environment</code>。<br />
参见：13.3.3.5 和 13.7.5.9</p>
<p>注意：为<code>environment</code>传递<code>undefined</code>，表示应该使用<code>PutValue</code>操作来赋予初始化值。var语句和某些非严格函数的形式参数列表就是这种情况（请参见9.2.12）。在那些情况下，计算初始化语句(initializer)之前，词法绑定会提升和预初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BindingIdentifier : Identifier</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>name</code>为<code>Identifier</code>的字符串值</li>
<li>返回<code>InitializeBoundName( name, value, environment)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BindingIdentifier : yield</span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>InitializeBoundName(&quot;yield&quot;, value, environment)</code></li>
</ol>
<h3 id="1216-运行时语义计算"><a class="markdownIt-Anchor" href="#1216-运行时语义计算"></a> 12.1.6 运行时语义:计算</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IdentifierReference : Identifier</span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>ResolveBinding(StringValue of Identifier)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IdentifierReference : <span class="keyword">yield</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>ResolveBinding(&quot;yield&quot;)</code></li>
</ol>
<p>注1：计算<code>IdentifierReference</code>的结果始终是Reference类型的值。</p>
<h2 id="122-基本表达式"><a class="markdownIt-Anchor" href="#122-基本表达式"></a> 12.2 基本表达式</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PrimaryExpression[Yield, Await]:</span><br><span class="line">    this</span><br><span class="line">    IdentifierReference[?Yield, ?Await]</span><br><span class="line">    Literal</span><br><span class="line">    ArrayLiteral[?Yield, ?Await]</span><br><span class="line">    ObjectLiteral[?Yield, ?Await]</span><br><span class="line">    FunctionExpression</span><br><span class="line">    ClassExpression[?Yield, ?Await]</span><br><span class="line">    GeneratorExpression</span><br><span class="line">    AsyncFunctionExpression</span><br><span class="line">    AsyncGeneratorExpression</span><br><span class="line">    RegularExpressionLiteral</span><br><span class="line">    TemplateLiteral[?Yield, ?Await, ~Tagged]</span><br><span class="line">    CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</span><br><span class="line"></span><br><span class="line">CoverParenthesizedExpressionAndArrowParameterList[Yield, Await]:</span><br><span class="line">    (Expression[+In, ?Yield, ?Await])</span><br><span class="line">    (Expression[+In, ?Yield, ?Await],)</span><br><span class="line">    ()</span><br><span class="line">    (...BindingIdentifier[?Yield, ?Await])</span><br><span class="line">    (...BindingPattern[?Yield, ?Await])</span><br><span class="line">    (Expression[+In, ?Yield, ?Await],...BindingIdentifier[?Yield, ?Await])</span><br><span class="line">    (Expression[+In, ?Yield, ?Await],...BindingPattern[?Yield, ?Await])</span><br></pre></td></tr></table></figure>
<p>补充语法<br />
当处理下面的产生式时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimaryExpression[Yield, Await]:</span><br><span class="line">    CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</span><br></pre></td></tr></table></figure>
<p>使用以下语法完善<code>CoverParenthesizedExpressionAndArrowParameterList</code>的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParenthesizedExpression[Yield, Await]:</span><br><span class="line">    (Expression[+In, ?Yield, ?Await])</span><br></pre></td></tr></table></figure>
<h3 id="1222-this关键字"><a class="markdownIt-Anchor" href="#1222-this关键字"></a> 12.2.2 this关键字</h3>
<h4 id="12221-运行时语义计算"><a class="markdownIt-Anchor" href="#12221-运行时语义计算"></a> 12.2.2.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrimaryExpression : <span class="built_in">this</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>ResolveThisBinding( )</code></li>
</ol>
<h3 id="1223-标识符引用"><a class="markdownIt-Anchor" href="#1223-标识符引用"></a> 12.2.3 标识符引用</h3>
<p>见12.1的IdentifierReference</p>
<h3 id="1224-字面值"><a class="markdownIt-Anchor" href="#1224-字面值"></a> 12.2.4 字面值</h3>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Literal:</span><br><span class="line">    NullLiteral</span><br><span class="line">    BooleanLiteral</span><br><span class="line">    NumericLiteral</span><br><span class="line">    StringLiteral</span><br></pre></td></tr></table></figure>
<h3 id="1225-数组初始化器"><a class="markdownIt-Anchor" href="#1225-数组初始化器"></a> 12.2.5 数组初始化器</h3>
<h3 id="1226-对象初始化器"><a class="markdownIt-Anchor" href="#1226-对象初始化器"></a> 12.2.6 对象初始化器</h3>
<p>注意：对象初始化器是一种描述对象初始化的表达式，以类似于字面值的形式编写。 它是用花括号括起来的零对或多对属性键和关联值的列表。这些值不必是字面值，每次计算对象初始化器时都计算这些值。</p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ObjectLiteral[Yield] :</span><br><span class="line">	&#123; &#125;</span><br><span class="line">	&#123; PropertyDefinitionList[?Yield] &#125;</span><br><span class="line">	&#123; PropertyDefinitionList[?Yield] , &#125;</span><br><span class="line"></span><br><span class="line">PropertyDefinitionList[Yield] :</span><br><span class="line">	PropertyDefinition[?Yield]</span><br><span class="line">	PropertyDefinitionList[?Yield] , PropertyDefinition[?Yield]</span><br><span class="line"></span><br><span class="line">PropertyDefinition[Yield] :</span><br><span class="line">	IdentifierReference[?Yield]</span><br><span class="line">	CoverInitializedName[?Yield]</span><br><span class="line">	PropertyName[?Yield] : AssignmentExpression[In, ?Yield]</span><br><span class="line">	MethodDefinition[?Yield]</span><br><span class="line">	... AssignmentExpression</span><br><span class="line"></span><br><span class="line">PropertyName[Yield] :</span><br><span class="line">	LiteralPropertyName</span><br><span class="line">	ComputedPropertyName[?Yield]</span><br><span class="line"></span><br><span class="line">LiteralPropertyName :</span><br><span class="line">	IdentifierName</span><br><span class="line">	StringLiteral</span><br><span class="line">	NumericLiteral</span><br><span class="line"></span><br><span class="line">ComputedPropertyName[Yield] :</span><br><span class="line">	[ AssignmentExpression[In, ?Yield] ]</span><br><span class="line"></span><br><span class="line">CoverInitializedName[Yield] :</span><br><span class="line">	IdentifierReference[?Yield] Initializer[In, ?Yield]</span><br><span class="line"></span><br><span class="line">Initializer[In, Yield] :</span><br><span class="line">	&#x3D; AssignmentExpression[?In, ?Yield]</span><br></pre></td></tr></table></figure>
<p>注意2：<code>MethodDefinition</code>在 14.3 节定义。</p>
<p>注意3：在某些情况下，ObjectLiteral为了更严格的辅助语法而用作覆盖语法。CoverInitializedName产生式对于完全覆盖这些辅助语法是必需的。 但是，在通常需要实际ObjectLiteral的正常情况下，使用这种产生方式会导致早期的语法错误。</p>
<h4 id="12268-运行时语义计算"><a class="markdownIt-Anchor" href="#12268-运行时语义计算"></a> 12.2.6.8 运行时语义:计算</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectLiteral : &#123; &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>ObjectCreate(%ObjectPrototype%)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectLiteral :</span><br><span class="line">	&#123; PropertyDefinitionList &#125;</span><br><span class="line">	&#123; PropertyDefinitionList , &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>obj</code>为<code>ObjectCreate(%ObjectPrototype%)</code></li>
<li>令<code>status</code>为使用参数<code>obj</code>和<code>true</code>执行<code>PropertyDefinitionList</code>的<code>PropertyDefinitionEvaluation</code>的结果</li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回<code>obj</code></li>
</ol>
<h4 id="12269-运行时语义propertydefinitionevaluation"><a class="markdownIt-Anchor" href="#12269-运行时语义propertydefinitionevaluation"></a> 12.2.6.9 运行时语义:PropertyDefinitionEvaluation</h4>
<p>接受参数<code>object</code>和<code>enumerable</code><br />
参见：14.3.9, 14.4.13, B.3.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PropertyDefinition : IdentifierReference</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>propName</code>为<code>IdentifierReference</code>的<code>StringValue</code></li>
<li>令<code>exprValue</code>为计算<code>IdentifierReference</code>的结果</li>
<li><code>ReturnIfAbrupt(exprValue)</code></li>
<li>令<code>propValue</code>为<code>GetValue(exprValue)</code></li>
<li><code>ReturnIfAbrupt(propValue)</code></li>
<li>断言：<code>enumerable</code>为<code>true</code></li>
<li>返回<code>CreateDataPropertyOrThrow(object, propName, propValue)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PropertyDefinition: ... AssignmentExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>exprValue</code>为计算<code>AssignmentExpression</code>的结果</li>
<li>令<code>fromValue</code>为<code>GetValue(exprValue)</code></li>
<li>令<code>excludedNames</code>为一个新的空列表</li>
<li>返回<code>CopyDataProperties(object, fromValue, excludedNames)</code></li>
</ol>
<h3 id="1229-模板字面值"><a class="markdownIt-Anchor" href="#1229-模板字面值"></a> 12.2.9 模板字面值</h3>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TemplateLiteral[Yield] :</span><br><span class="line">	NoSubstitutionTemplate</span><br><span class="line">	TemplateHead Expression[In, ?Yield] TemplateSpans[?Yield]</span><br><span class="line"></span><br><span class="line">TemplateSpans[Yield] :</span><br><span class="line">	TemplateTail</span><br><span class="line">	TemplateMiddleList[?Yield] TemplateTail</span><br><span class="line"></span><br><span class="line">TemplateMiddleList[Yield] :</span><br><span class="line">	TemplateMiddle Expression[In, ?Yield]</span><br><span class="line">	TemplateMiddleList[?Yield] TemplateMiddle Expression[In, ?Yield]</span><br></pre></td></tr></table></figure>
<h4 id="12291-运行时语义-templatestrings"><a class="markdownIt-Anchor" href="#12291-运行时语义-templatestrings"></a> 12.2.9.1 运行时语义: TemplateStrings</h4>
<p>带有参数<code>raw</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateLiteral : NoSubstitutionTemplate</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>raw</code>为<code>false</code>，则令<code>string</code>为<code>NoSubstitutionTemplate</code>的TV</li>
<li>否则，令<code>string</code>为<code>NoSubstitutionTemplate</code>的TRV</li>
<li>返回一个List，它包含单个元素<code>string</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateLiteral : TemplateHead Expression TemplateSpans</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>raw</code>为<code>false</code>，则令<code>head</code>为<code>TemplateHead</code>的TV</li>
<li>否则，令<code>head</code>为<code>TemplateHead</code>的TRV</li>
<li>令<code>tail</code>为<code>TemplateSpans</code>的<code>TemplateStrings</code>，参数为<code>raw</code></li>
<li>返回一个List，它包含<code>head</code>后跟<code>tail</code>中按顺序的元素</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateSpans : TemplateTail</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>raw</code>为<code>false</code>，则令<code>tail</code>为<code>TemplateTail</code>的TV</li>
<li>否则，令<code>tail</code>为<code>TemplateTail</code>的TRV</li>
<li>返回一个List，它包含单个元素<code>tail</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateSpans : TemplateMiddleList TemplateTail</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>middle</code>为<code>TemplateMiddleList</code>的<code>TemplateStrings</code>，带有参数<code>raw</code></li>
<li>如果<code>raw</code>为<code>false</code>，则令<code>tail</code>为<code>TemplateTail</code>的TV</li>
<li>否则，令<code>tail</code>为<code>TemplateTail</code>的TRV</li>
<li>返回一个List，它包含按顺序排列的<code>middle</code>和<code>tail</code>元素。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateMiddleList : TemplateMiddle Expression</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>raw</code>为<code>false</code>，则令<code>string</code>为<code>TemplateMiddle</code>的TV</li>
<li>否则，令<code>string</code>为<code>TemplateMiddle</code>的TRV</li>
<li>返回一个List，它包含单个元素<code>string</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>front</code>为<code>TemplateMiddleList</code>的<code>TemplateStrings</code>，带有参数<code>raw</code></li>
<li>如果<code>raw</code>为<code>false</code>，则令<code>last</code>为<code>TemplateMiddle</code>的TV</li>
<li>否则，令<code>last</code>为<code>TemplateMiddle</code>的TRV</li>
<li>将<code>last</code>作为作为一个元素添加到List<code>front</code>中</li>
<li>返回<code>front</code></li>
</ol>
<h4 id="12292-运行时语义-argumentlistevaluation"><a class="markdownIt-Anchor" href="#12292-运行时语义-argumentlistevaluation"></a> 12.2.9.2 运行时语义: ArgumentListEvaluation</h4>
<p>另请参阅：12.3.6.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateLiteral : NoSubstitutionTemplate</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>templateLiteral</code>为此<code>TemplateLiteral</code></li>
<li>令<code>siteObj</code>为<code>GetTemplateObject(templateLiteral)</code></li>
<li>返回一个List，它只包含一个元素<code>siteObj</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TemplateLiteral : TemplateHead Expression TemplateSpans</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>templateLiteral</code>为此<code>TemplateLiteral</code></li>
<li>令<code>siteObj</code>为<code>GetTemplateObject(templateLiteral)</code></li>
<li>令<code>firstSub</code>为计算<code>Expression</code>的结果</li>
<li><code>ReturnIfAbrupt(firstSub)</code></li>
<li>令<code>restSub</code>为<code>TemplateSpans</code>的<code>SubstitutionEvaluation</code></li>
<li><code>ReturnIfAbrupt(restSub)</code></li>
<li>断言：<code>restSub</code>是一个List</li>
<li>按顺序返回一个List，它的第一个元素是<code>siteObj</code>，第二个元素是<code>firstSub</code>，其后继元素是<code>restSub</code>的元素。 <code>restSub</code>可能不包含任何元素。</li>
</ol>
<h4 id="12293-运行时语义-gettemplateobject-templateliteral"><a class="markdownIt-Anchor" href="#12293-运行时语义-gettemplateobject-templateliteral"></a> 12.2.9.3 运行时语义: GetTemplateObject ( templateLiteral )</h4>
<p>使用产生式 templateLiteral 作为参数调用抽象操作GetTemplateObject。 它执行以下步骤：</p>
<ol>
<li>令<code>rawStrings</code>为<code>templateLiteral</code>的<code>TemplateStrings</code>，参数为<code>true</code></li>
<li>令<code>ctx</code>为运行中的执行上下文</li>
<li>令<code>realm</code>为<code>ctx</code>的Realm</li>
<li>令<code>templateRegistry</code>为<code>realm.[[templateMap]]</code></li>
<li>对<code>templateRegistry</code>中的每个元素<code>e</code>，执行：
<ol>
<li>如果<code>e.[[strings]]</code>和<code>rawStrings</code>包含相同顺序的相同值，则返回<code>e.[[array]]</code></li>
</ol>
</li>
<li>令<code>cookedStrings</code>为<code>templateLiteral</code>的<code>TemplateStrings</code>，参数为<code>false</code></li>
<li>令<code>count</code>为列表<code>cookedStrings</code>中的元素数量</li>
<li>令<code>template</code>为<code>ArrayCreate(count)</code></li>
<li>令<code>rawObj</code>为<code>ArrayCreate(count)</code></li>
<li>令<code>index</code>为<code>0</code></li>
<li>只要<code>index &lt; count</code>就重复执行：
<ol>
<li>令<code>prop</code>为<code>ToString(index)</code></li>
<li>令<code>cookedValue</code>为字符串值<code>cookedStrings[index]</code></li>
<li>调用<code>template.[[DefineOwnProperty]](prop, PropertyDescriptor&#123;[[Value]]: cookedValue, [[Enumerable]]: true, [[Writable]]: false, [[Configurable]]: false&#125;)</code></li>
<li>令<code>rawValue</code>为字符串值<code>rawStrings[index]</code></li>
<li>调用<code>rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor&#123;[[Value]]: rawValue, [[Enumerable]]: true, [[Writable]]: false, [[Configurable]]: false&#125;)</code></li>
<li>令<code>index</code>为<code>index+1</code></li>
</ol>
</li>
<li>执行<code>SetIntegrityLevel(rawObj, &quot;frozen&quot;)</code></li>
<li>调用<code>template.[[DefineOwnProperty]](&quot;raw&quot;, PropertyDescriptor&#123;[[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false&#125;)</code></li>
<li>执行<code>SetIntegrityLevel(template, &quot;frozen&quot;)</code></li>
<li>将<code>Record&#123;[[strings]]: rawStrings, [[array]]: template&#125;</code>添加到<code>templateRegistry</code></li>
<li>返回<code>template</code></li>
</ol>
<h2 id="123-左侧表达式"><a class="markdownIt-Anchor" href="#123-左侧表达式"></a> 12.3 左侧表达式</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">MemberExpression[Yield] :</span><br><span class="line">	PrimaryExpression[?Yield]</span><br><span class="line">	MemberExpression[?Yield] [ Expression[In, ?Yield] ]</span><br><span class="line">	MemberExpression[?Yield] . IdentifierName</span><br><span class="line">	MemberExpression[?Yield] TemplateLiteral[?Yield]</span><br><span class="line">	SuperProperty[?Yield]</span><br><span class="line">	MetaProperty</span><br><span class="line">	new MemberExpression[?Yield] Arguments[?Yield]</span><br><span class="line"></span><br><span class="line">SuperProperty[Yield] :</span><br><span class="line">	super [ Expression[In, ?Yield] ]</span><br><span class="line">	super . IdentifierName</span><br><span class="line"></span><br><span class="line">MetaProperty :</span><br><span class="line">	NewTarget</span><br><span class="line">	ImportMeta</span><br><span class="line"></span><br><span class="line">NewTarget :</span><br><span class="line">	new . target</span><br><span class="line"></span><br><span class="line">ImportMeta:</span><br><span class="line">    import . meta</span><br><span class="line"></span><br><span class="line">NewExpression[Yield] :</span><br><span class="line">	MemberExpression[?Yield]</span><br><span class="line">	new NewExpression[?Yield]</span><br><span class="line"></span><br><span class="line">CallExpression[Yield] :</span><br><span class="line">    CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]</span><br><span class="line">	SuperCall[?Yield, ?Await]</span><br><span class="line">	ImportCall[?Yield, ?Await]</span><br><span class="line">	CallExpression[?Yield] Arguments[?Yield]</span><br><span class="line">	CallExpression[?Yield] [ Expression[In, ?Yield] ]</span><br><span class="line">	CallExpression[?Yield] . IdentifierName</span><br><span class="line">	CallExpression[?Yield] TemplateLiteral[?Yield]</span><br><span class="line"></span><br><span class="line">SuperCall[Yield] :</span><br><span class="line">	super Arguments[?Yield]</span><br><span class="line"></span><br><span class="line">ImportCall[Yield, Await]:</span><br><span class="line">    import(AssignmentExpression[+In, ?Yield, ?Await])</span><br><span class="line"></span><br><span class="line">Arguments[Yield] :</span><br><span class="line">	( )</span><br><span class="line">	( ArgumentList[?Yield] )</span><br><span class="line">	( ArgumentList[?Yield, ?Await] , )</span><br><span class="line"></span><br><span class="line">ArgumentList[Yield] :</span><br><span class="line">	AssignmentExpression[In, ?Yield]</span><br><span class="line">	... AssignmentExpression[In, ?Yield]</span><br><span class="line">	ArgumentList[?Yield] , AssignmentExpression[In, ?Yield]</span><br><span class="line">	ArgumentList[?Yield] , ... AssignmentExpression[In, ?Yield]</span><br><span class="line"></span><br><span class="line">OptionalExpression[Yield, Await]:</span><br><span class="line">    MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]</span><br><span class="line">    CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]</span><br><span class="line">    OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]</span><br><span class="line"></span><br><span class="line">OptionalChain[Yield, Await]:</span><br><span class="line">    ?. Arguments[?Yield, ?Await]</span><br><span class="line">    ?. [ Expression[+In, ?Yield, ?Await] ]</span><br><span class="line">    ?. IdentifierName</span><br><span class="line">    OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]</span><br><span class="line">    OptionalChain[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]</span><br><span class="line">    OptionalChain[?Yield, ?Await] . IdentifierName</span><br><span class="line"></span><br><span class="line">LeftHandSideExpression[Yield] :</span><br><span class="line">	NewExpression[?Yield]</span><br><span class="line">	CallExpression[?Yield]</span><br><span class="line">	OptionalExpression[?Yield, ?Await]</span><br></pre></td></tr></table></figure>
<p>补充语法<br />
当处理下面的产生式时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CallExpression:</span><br><span class="line">    CoverCallExpressionAndAsyncArrowHead</span><br></pre></td></tr></table></figure>
<p>使用以下语法完善<code>CoverCallExpressionAndAsyncArrowHead</code>的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CallMemberExpression[Yield, Await]:</span><br><span class="line">    MemberExpression[?Yield, ?Await]Arguments[?Yield, ?Await]</span><br></pre></td></tr></table></figure>
<h3 id="1232-属性访问"><a class="markdownIt-Anchor" href="#1232-属性访问"></a> 12.3.2 属性访问</h3>
<p>注：属性通过名字来访问，可以使用点表示法，也可以使用中括号表示法。</p>
<p>点表示法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MemberExpression . IdentifierName</span><br><span class="line">CallExpression . IdentifierName</span><br></pre></td></tr></table></figure>
<p>中括号表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MemberExpression [ Expression ]</span><br><span class="line">CallExpression [ Expression ]</span><br></pre></td></tr></table></figure>
<p>点表示法会被转换为下面的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MemberExpression . IdentifierName</span><br><span class="line">MemberExpression [ &lt;identifier-name-string&gt; ]</span><br></pre></td></tr></table></figure>
<p>同理，下面两者的行为是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CallExpression . IdentifierName</span><br><span class="line">CallExpression [ &lt;identifier-name-string&gt; ]</span><br></pre></td></tr></table></figure>
<p>这里<code>&lt;identifier-name-string&gt;</code>是计算<code>IdentifierName</code>的<code>StringValue</code>的结果</p>
<h3 id="1233-new操作符"><a class="markdownIt-Anchor" href="#1233-new操作符"></a> 12.3.3 new操作符</h3>
<h4 id="12331-运行时语义计算"><a class="markdownIt-Anchor" href="#12331-运行时语义计算"></a> 12.3.3.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewExpression : <span class="keyword">new</span> NewExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>EvaluateNew(NewExpression, empty)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemberExpression : <span class="keyword">new</span> MemberExpression Arguments</span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>EvaluateNew(MemberExpression, Arguments)</code></li>
</ol>
<h5 id="123311-运行时语义evaluatenewconstructproduction-arguments"><a class="markdownIt-Anchor" href="#123311-运行时语义evaluatenewconstructproduction-arguments"></a> 12.3.3.1.1 运行时语义:EvaluateNew(constructProduction, arguments)</h5>
<p>抽象操作<code>EvaluateNew</code>接受参数<code>ConstructProduction</code>和<code>arguments</code>，并执行以下步骤：</p>
<ol>
<li>断言：<code>constructProduction</code>是<code>NewExpression</code>或<code>MemberExpression</code></li>
<li>断言：<code>arguments</code>是<code>empty</code>或<code>Arguments</code>产生式</li>
<li>令<code>ref</code>为计算<code>constructProduction</code>的结果</li>
<li>令<code>constructor</code>为<code>GetValue(ref)</code></li>
<li><code>ReturnIfAbrupt(constructor)</code></li>
<li>如果<code>arguments</code>为<code>empty</code>，令<code>argList</code>为一个空列表</li>
<li>否则：
<ol>
<li>令<code>argList</code>为<code>arguments</code>的<code>ArgumentListEvaluation</code></li>
<li><code>ReturnIfAbrupt(argList)</code></li>
</ol>
</li>
<li>如果<code>IsConstructor (constructor)</code>为<code>false</code>，抛出 TypeError 异常</li>
<li>返回<code>Construct(constructor, argList)</code></li>
</ol>
<h3 id="1234-函数调用"><a class="markdownIt-Anchor" href="#1234-函数调用"></a> 12.3.4 函数调用</h3>
<h4 id="12341-运行时语义计算"><a class="markdownIt-Anchor" href="#12341-运行时语义计算"></a> 12.3.4.1 运行时语义:计算</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallExpression : MemberExpression Arguments</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>ref</code>为计算<code>MemberExpression</code>的结果</li>
<li>令<code>func</code>为<code>GetValue(ref)</code></li>
<li><code>ReturnIfAbrupt(func)</code></li>
<li>如果<code>Type(ref)</code>为引用，并且<code>IsPropertyReference(ref)</code>为<code>false</code>，且<code>GetReferencedName(ref)</code>为<code>&quot;eval&quot;</code>，则：
<ol>
<li>如果<code>SameValue(func, %eval%)</code>为<code>true</code>，则
<ol>
<li>令<code>argList</code>为<code>ArgumentListEvaluation(Arguments)</code></li>
<li><code>ReturnIfAbrupt(argList)</code></li>
<li>如果<code>argList</code>没有元素，返回<code>undefined</code></li>
<li>令<code>evalText</code>为<code>argList</code>的第一个元素</li>
<li>如果与此<code>CallExpression</code>匹配的源代码为严格模式代码，令<code>strictCaller</code>为<code>true</code>，否则令<code>strictCaller</code>为<code>false</code></li>
<li>令<code>evalRealm</code>运行中的执行上下文的<code>Realm</code></li>
<li>返回<code>PerformEval(evalText, evalRealm, strictCaller, true)</code></li>
</ol>
</li>
</ol>
</li>
<li>如果<code>Type(ref)</code>为引用，则
<ol>
<li>如果<code>IsPropertyReference(ref)</code>为<code>true</code>，则令<code>thisValue</code>为<code>GetThisValue(ref)</code></li>
<li>否则，<code>ref</code>的基值是一个环境记录
<ol>
<li>令<code>refEnv</code>为<code>GetBase(ref)</code></li>
<li>令<code>thisValue</code>为<code>refEnv.WithBaseObject()</code></li>
</ol>
</li>
</ol>
</li>
<li>否则<code>Type(ref)</code>不是引用：
<ol>
<li>令<code>thisValue</code>为<code>undefined</code></li>
</ol>
</li>
<li>令<code>thisCall</code>为此<code>CallExpression</code></li>
<li>令<code>tailCall</code>为<code>IsInTailPosition(thisCall)</code>(见 14.6.1)</li>
<li>返回<code>EvaluateDirectCall(func, thisValue, Arguments, tailCall)</code></li>
</ol>
<p>执行4.1.7步的<code>CallExpression</code>计算是直接<code>eval</code>(direct eval)</p>
<h4 id="12343-运行时语义evaluatedirectcall-func-thisvalue-arguments-tailposition"><a class="markdownIt-Anchor" href="#12343-运行时语义evaluatedirectcall-func-thisvalue-arguments-tailposition"></a> 12.3.4.3 运行时语义:EvaluateDirectCall( func, thisValue, arguments, tailPosition )</h4>
<p>抽象操作<code>EvaluateDirectCall</code>接受值<code>func</code>，值<code>thisValue</code>，句法产生式<code>arguments</code>和布尔值<code>tailPosition</code>作为参数。 它执行以下步骤：</p>
<ol>
<li>令<code>argList</code>为<code>ArgumentListEvaluation(arguments)</code></li>
<li><code>ReturnIfAbrupt(argList)</code></li>
<li>如果<code>Type(func)</code>不是<code>Object</code>，抛出 TypeError 异常</li>
<li>如果<code>IsCallable(func)</code>为<code>false</code>，抛出 TypeError 异常</li>
<li>如果<code>tailPosition</code>为<code>true</code>，执行<code>PrepareForTailCall()</code></li>
<li>令<code>result</code>为<code>Call(func, thisValue, argList)</code></li>
<li>断言：如果<code>tailPosition</code>为<code>true</code>，则上述调用不会在此处返回，而是继续计算，就好像已经发生了以下返回一样。</li>
<li>断言：如果<code>result</code>不是非常规完结，则<code>Type(result)</code>是ECMAScript语言类型</li>
<li>返回<code>result</code></li>
</ol>
<h3 id="1235-super关键字"><a class="markdownIt-Anchor" href="#1235-super关键字"></a> 12.3.5 super关键字</h3>
<h4 id="12351-运行时语义计算"><a class="markdownIt-Anchor" href="#12351-运行时语义计算"></a> 12.3.5.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperProperty : <span class="built_in">super</span> [ Expression ]</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>propertyNameReference</code>为计算<code>Expression</code>的结果</li>
<li>令<code>propertyNameValue</code>为<code>GetValue(propertyNameReference)</code></li>
<li>令<code>propertyKey</code>为<code>ToPropertyKey(propertyNameValue)</code></li>
<li><code>ReturnIfAbrupt(propertyKey)</code></li>
<li>如果与句法产生式匹配的代码在严格模式进行计算，令<code>strict</code>为<code>true</code>，否则令<code>strict</code>为<code>false</code></li>
<li>返回<code>MakeSuperPropertyReference(propertyKey, strict)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperProperty : <span class="built_in">super</span> . IdentifierName</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>propertyKey</code>为<code>IdentifierName</code>的<code>StringValue</code></li>
<li>如果与句法产生式匹配的代码在严格模式进行计算，令<code>strict</code>为<code>true</code>，否则令<code>strict</code>为<code>false</code></li>
<li>返回<code>MakeSuperPropertyReference(propertyKey, strict)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperCall : <span class="built_in">super</span> Arguments</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>newTarget</code>为<code>GetNewTarget()</code></li>
<li>如果<code>newTarget</code>为<code>undefined</code>，抛出 ReferenceError 异常</li>
<li>令<code>func</code>为<code>GetSuperConstructor()</code></li>
<li><code>ReturnIfAbrupt(func)</code></li>
<li>令<code>argList</code>为<code>Arguments</code>的<code>ArgumentListEvaluation</code></li>
<li><code>ReturnIfAbrupt(argList)</code></li>
<li>令<code>result</code>为<code>Construct(func, argList, newTarget)</code></li>
<li><code>ReturnIfAbrupt(result)</code></li>
<li>令<code>thisER</code>为<code>GetThisEnvironment( )</code></li>
<li>返回<code>thisER.BindThisValue(result)</code></li>
</ol>
<h3 id="1236-参数列表"><a class="markdownIt-Anchor" href="#1236-参数列表"></a> 12.3.6 参数列表</h3>
<p>注：参数列表的计算会产生一个列表值（见 6.2.1）</p>
<h4 id="12361-运行时语义argumentlistevaluation"><a class="markdownIt-Anchor" href="#12361-运行时语义argumentlistevaluation"></a> 12.3.6.1 运行时语义:ArgumentListEvaluation</h4>
<p>参见 12.2.9.2</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arguments : ( )</span><br></pre></td></tr></table></figure>
<ol>
<li>返回一个空列表</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentList : AssignmentExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>ref</code>为计算<code>AssignmentExpression</code>的结果</li>
<li>令<code>arg</code>为<code>GetValue(ref)</code></li>
<li><code>ReturnIfAbrupt(arg)</code></li>
<li>返回一个只有一个元素<code>arg</code>的列表</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentList : ... AssignmentExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>list</code>为一个空列表</li>
<li>令<code>spreadRef</code>为计算<code>AssignmentExpression</code>的结果</li>
<li>令<code>spreadObj</code>为<code>GetValue(spreadRef)</code></li>
<li>令<code>iterator</code>为<code>GetIterator(spreadObj)</code></li>
<li><code>ReturnIfAbrupt(iterator)</code></li>
<li>重复：
<ol>
<li>令<code>next</code>为<code>IteratorStep(iterator)</code></li>
<li><code>ReturnIfAbrupt(next)</code></li>
<li>如果<code>next</code>为<code>false</code>，返回<code>list</code></li>
<li>令<code>nextArg</code>为<code>IteratorValue(next)</code></li>
<li><code>ReturnIfAbrupt(nextArg)</code></li>
<li>将<code>nextArg</code>作为最后一个元素添加到<code>list</code></li>
</ol>
</li>
</ol>
<h3 id="1239-可选链"><a class="markdownIt-Anchor" href="#1239-可选链"></a> 12.3.9 可选链</h3>
<p>可选链是一个或多个属性访问和函数调用的链，其中第一个以Token<code>?</code>开头。</p>
<h4 id="13391-运行时语义计算"><a class="markdownIt-Anchor" href="#13391-运行时语义计算"></a> 13.3.9.1 运行时语义:计算</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OptionalExpression:</span><br><span class="line">    MemberExpression OptionalChain</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>baseReference</code>为计算<code>MemberExpression</code>的结果</li>
<li>令<code>baseValue</code>为? <code>GetValue(baseReference)</code></li>
<li>如果<code>baseValue</code>是<code>undefined</code>或<code>null</code>，则返回<code>undefined</code></li>
<li>返回使用参数<code>baseValue</code>和<code>baseReference</code>执行<code>OptionalChain</code>的<code>ChainEvaluation</code>的结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OptionalExpression:</span><br><span class="line">    OptionalExpression OptionalChain</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>baseReference</code>为计算<code>OptionalExpression</code>的结果</li>
<li>令<code>baseValue</code>为? <code>GetValue(baseReference)</code></li>
<li>如果<code>baseValue</code>是<code>undefined</code>或<code>null</code>，则返回<code>undefined</code></li>
<li>返回使用参数<code>baseValue</code>和<code>baseReference</code>执行<code>OptionalChain</code>的<code>ChainEvaluation</code>的结果</li>
</ol>
<h4 id="13392-运行时语义chainevaluation"><a class="markdownIt-Anchor" href="#13392-运行时语义chainevaluation"></a> 13.3.9.2 运行时语义:ChainEvaluation</h4>
<p>接受参数<code>baseValue</code>和<code>baseReference</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OptionalChain:</span><br><span class="line">    ?. Arguments</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>thisChain</code>为此<code>OptionalChain</code></li>
<li>令<code>tailCall</code>为<code>IsInTailPosition(thisChain)</code></li>
<li>返回 ? <code>EvaluateCall(baseValue, baseReference, Arguments, tailCall)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OptionalChain:</span><br><span class="line">    OptionalChain Arguments</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>optionalChain</code>为<code>OptionalChain</code></li>
<li>令<code>newReference</code>为带有参数<code>baseValue</code>和<code>baseReference</code>的<code>optionalChain</code>的? <code>ChainEvaluation</code></li>
<li>令<code>newValue</code>为? <code>GetValue(newReference)</code></li>
<li>令<code>thisChain</code>为此<code>OptionalChain</code></li>
<li>令<code>tailCall</code>为<code>IsInTailPosition(thisChain)</code></li>
<li>返回? <code>EvaluateCall(newValue, newReference, Arguments, tailCall)</code></li>
</ol>
<h3 id="12311-标签模板"><a class="markdownIt-Anchor" href="#12311-标签模板"></a> 12.3.11 标签模板</h3>
<p>带标签的模板(tagged template)是一个函数调用，其中调用的参数是从TemplateLiteral（12.2.9）派生的。 实际参数包括模板对象（12.2.9.3）和计算表达式（嵌入在TemplateLiteral中的）产生的值。</p>
<h4 id="123111-运行时语义计算"><a class="markdownIt-Anchor" href="#123111-运行时语义计算"></a> 12.3.11.1 运行时语义:计算</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemberExpression : MemberExpression TemplateLiteral</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>tagRef</code>为计算<code>MemberExpression</code>的结果</li>
<li>令<code>thisCall</code>为此<code>MemberExpression</code></li>
<li>令<code>tailCall</code>为<code>IsInTailPosition(thisCall)</code>（参见14.6.1）</li>
<li>返回<code>EvaluateCall(tagRef, TemplateLiteral, tailCall)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallExpression : CallExpression TemplateLiteral</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>tagRef</code>为计算<code>CallExpression</code>的结果</li>
<li>令<code>thisCall</code>为此<code>CallExpression</code></li>
<li>令<code>tailCall</code>为<code>IsInTailPosition(thisCall)</code>（参见14.6.1）</li>
<li>返回<code>EvaluateCall(tagRef, TemplateLiteral, tailCall)</code></li>
</ol>
<h3 id="12312-meta属性"><a class="markdownIt-Anchor" href="#12312-meta属性"></a> 12.3.12 Meta属性</h3>
<h4 id="123121-运行时语义计算"><a class="markdownIt-Anchor" href="#123121-运行时语义计算"></a> 12.3.12.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewTarget : <span class="keyword">new</span> . target</span><br></pre></td></tr></table></figure>
<ol>
<li>返回<code>GetNewTarget()</code></li>
</ol>
<h2 id="124-更新表达式"><a class="markdownIt-Anchor" href="#124-更新表达式"></a> 12.4 更新表达式</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UpdateExpression[Yield, Await]:</span><br><span class="line">    LeftHandSideExpression[?Yield, ?Await]</span><br><span class="line">    LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++</span><br><span class="line">    LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --</span><br><span class="line">    ++ UnaryExpression[?Yield, ?Await]</span><br><span class="line">    -- UnaryExpression[?Yield, ?Await]</span><br></pre></td></tr></table></figure>
<h3 id="1244-后缀递增运算符"><a class="markdownIt-Anchor" href="#1244-后缀递增运算符"></a> 12.4.4 后缀递增运算符</h3>
<h4 id="12441-运行时语义计算"><a class="markdownIt-Anchor" href="#12441-运行时语义计算"></a> 12.4.4.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostfixExpression : LeftHandSideExpression ++</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lhs</code>为计算<code>LeftHandSideExpression</code>的结果</li>
<li>令<code>oldValue</code>为<code>ToNumber(GetValue(lhs))</code></li>
<li><code>ReturnIfAbrupt(oldValue)</code></li>
<li>令<code>newValue</code>为<code>oldValue</code>加<code>1</code>得到的结果，使用与<code>+</code>运算符相同的规则（请参见12.7.5）。</li>
<li>令<code>status</code>为<code>PutValue(lhs, newValue)</code></li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回<code>oldValue</code></li>
</ol>
<h2 id="125-一元运算符"><a class="markdownIt-Anchor" href="#125-一元运算符"></a> 12.5 一元运算符</h2>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression[Yield] :</span><br><span class="line">	UpdateExpression[?Yield, ?Await]</span><br><span class="line">	<span class="keyword">delete</span> UnaryExpression[?Yield]</span><br><span class="line">	<span class="keyword">void</span> UnaryExpression[?Yield]</span><br><span class="line">	<span class="keyword">typeof</span> UnaryExpression[?Yield]</span><br><span class="line">	+ UnaryExpression[?Yield]</span><br><span class="line">	- UnaryExpression[?Yield]</span><br><span class="line">	~ UnaryExpression[?Yield]</span><br><span class="line">	! UnaryExpression[?Yield]</span><br></pre></td></tr></table></figure>
<h3 id="1254-delete运算符"><a class="markdownIt-Anchor" href="#1254-delete运算符"></a> 12.5.4 delete运算符</h3>
<h4 id="12542-运行时语义计算"><a class="markdownIt-Anchor" href="#12542-运行时语义计算"></a> 12.5.4.2 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : <span class="keyword">delete</span> UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>ref</code>为计算<code>UnaryExpression</code>的结果</li>
<li><code>ReturnIfAbrupt(ref)</code></li>
<li>如果<code>Type(ref)</code>不是引用，返回<code>true</code></li>
<li>如果<code>IsUnresolvableReference(ref)</code>为<code>true</code>，则：
<ol>
<li>断言：<code>IsStrictReference(ref)</code>为<code>false</code></li>
<li>返回<code>true</code></li>
</ol>
</li>
<li>如果<code>IsPropertyReference(ref)</code>为<code>true</code>，则：
<ol>
<li>如果<code>IsSuperReference(ref)</code>，抛出ReferenceError异常</li>
<li>令<code>baseObj</code>为<code>ToObject(GetBase(ref))</code></li>
<li>断言：<code>baseObj</code>不是非常规完结</li>
<li>令<code>deleteStatus</code>为<code>baseObj.[[Delete]](GetReferencedName(ref))</code></li>
<li><code>ReturnIfAbrupt(deleteStatus)</code></li>
<li>如果<code>deleteStatus</code>为<code>false</code>，并且<code>IsStrictReference(ref)</code>为<code>true</code>，抛出TypeError异常</li>
<li>返回<code>deleteStatus</code></li>
</ol>
</li>
<li>否则<code>ref</code>是一个环境记录绑定的引用：
<ol>
<li>令<code>bindings</code>为<code>GetBase(ref)</code></li>
<li>返回<code>bindings.DeleteBinding(GetReferencedName(ref))</code></li>
</ol>
</li>
</ol>
<p>注意：当delete运算符出现在严格模式代码中时，如果其UnaryExpression是对变量，函数参数或函数名称的直接引用，则将引发SyntaxError异常。 此外，如果delete运算符出现在严格模式代码中，并且要删除的属性具有特性<code>&#123; [[Configurable]]: false &#125;</code>，则会引发TypeError异常。</p>
<h3 id="1255-void运算符"><a class="markdownIt-Anchor" href="#1255-void运算符"></a> 12.5.5 void运算符</h3>
<h4 id="12551-运行时语义计算"><a class="markdownIt-Anchor" href="#12551-运行时语义计算"></a> 12.5.5.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : <span class="keyword">void</span> UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>expr</code>为计算<code>UnaryExpression</code>的结果</li>
<li>令<code>status</code>为<code>GetValue(expr)</code></li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回<code>undefined</code></li>
</ol>
<p>注意：即使不使用GetValue，也必须调用它，因为它可能会有明显的副作用。</p>
<h3 id="1256-typeof-运算符"><a class="markdownIt-Anchor" href="#1256-typeof-运算符"></a> 12.5.6 typeof 运算符</h3>
<h4 id="12561-运行时语义计算"><a class="markdownIt-Anchor" href="#12561-运行时语义计算"></a> 12.5.6.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : <span class="keyword">typeof</span> UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>val</code>为计算<code>UnaryExpression</code>的结果</li>
<li>如果<code>Type(val)</code>是引用，则
<ol>
<li>如果<code>IsUnresolvableReference(val)</code>为<code>true</code>，返回<code>&quot;undefined&quot;</code></li>
</ol>
</li>
<li>令<code>val</code>为<code>GetValue(val)</code></li>
<li><code>ReturnIfAbrupt(val)</code></li>
<li>根据表35返回一个字符串</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">val的类型</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Undefined</td>
<td style="text-align:left">“undefined”</td>
</tr>
<tr>
<td style="text-align:left">Null</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">“boolean”</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">“number”</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">“string”</td>
</tr>
<tr>
<td style="text-align:left">Symbol</td>
<td style="text-align:left">“symbol”</td>
</tr>
<tr>
<td style="text-align:left">Object (ordinary但没有实现[[Call]])</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">Object (standard exotic但没有实现[[Call]])</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">Object (实现了[[Call]])</td>
<td style="text-align:left">“function”</td>
</tr>
<tr>
<td style="text-align:left">Object (non-standard exotic但没有实现[[Call]])</td>
<td style="text-align:left">由实现定义，但不能是&quot;undefined&quot;, “boolean”, “function”, “number”, “symbol&quot;或&quot;string”</td>
</tr>
</tbody>
</table>
<p>注意：不建议为non-standard exotic对象定义新的<code>typeof</code>结果值。 如果可能，应将<code>&quot;object&quot;</code>用于此类对象。</p>
<h3 id="1257-前缀递增运算符"><a class="markdownIt-Anchor" href="#1257-前缀递增运算符"></a> 12.5.7 前缀递增运算符</h3>
<h4 id="12571-运行时语义计算"><a class="markdownIt-Anchor" href="#12571-运行时语义计算"></a> 12.5.7.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : ++ UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>expr</code>为计算<code>UnaryExpression</code>的结果</li>
<li>令<code>oldValue</code>为<code>ToNumber(GetValue(expr))</code></li>
<li><code>ReturnIfAbrupt(oldValue)</code></li>
<li>令<code>newValue</code>为<code>oldValue</code>加<code>1</code>得到的结果，使用与<code>+</code>运算符相同的规则（请参见12.7.5）。</li>
<li>令<code>status</code>为<code>PutValue(expr, newValue)</code></li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回<code>newValue</code></li>
</ol>
<h3 id="1259-一元运算符"><a class="markdownIt-Anchor" href="#1259-一元运算符"></a> 12.5.9 一元+运算符</h3>
<p>注意：一元<code>+</code>运算符将其操作数转换为<code>Number</code>类型。</p>
<h4 id="12591-运行时语义计算"><a class="markdownIt-Anchor" href="#12591-运行时语义计算"></a> 12.5.9.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : + UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>expr</code>为计算<code>UnaryExpression</code>的结果</li>
<li>返回<code>ToNumber(GetValue(expr))</code></li>
</ol>
<h3 id="12510-一元-运算符"><a class="markdownIt-Anchor" href="#12510-一元-运算符"></a> 12.5.10 一元-运算符</h3>
<p>注意：一元<code>-</code>运算符将其操作数转换为<code>Number</code>类型，然后取负。 对<code>+0</code>取负产生<code>-0</code>，对<code>-0</code>取负产生<code>+0</code>。</p>
<h4 id="125101-运行时语义计算"><a class="markdownIt-Anchor" href="#125101-运行时语义计算"></a> 12.5.10.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : - UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>expr</code>为计算<code>UnaryExpression</code>的结果</li>
<li>令<code>oldValue</code>为<code>ToNumber(GetValue(expr))</code></li>
<li><code>ReturnIfAbrupt(oldValue)</code></li>
<li>如果<code>oldValue</code>为<code>NaN</code>，返回<code>NaN</code></li>
<li>返回对<code>oldValue</code>取负的结果； 也就是说，计算一个具有相同模但符号相反的<code>Number</code>。</li>
</ol>
<h3 id="12511-按位取反运算~"><a class="markdownIt-Anchor" href="#12511-按位取反运算~"></a> 12.5.11 按位取反运算(~)</h3>
<h4 id="125111-运行时语义计算"><a class="markdownIt-Anchor" href="#125111-运行时语义计算"></a> 12.5.11.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : ~ UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>expr</code>为计算<code>UnaryExpression</code>的结果</li>
<li>令<code>oldValue</code>为<code>ToInt32(GetValue(expr))</code></li>
<li><code>ReturnIfAbrupt(oldValue)</code></li>
<li>返回对<code>oldValue</code>应用按位取反的结果。 结果是一个32位有符号整数。</li>
</ol>
<h3 id="12512-逻辑非运算符"><a class="markdownIt-Anchor" href="#12512-逻辑非运算符"></a> 12.5.12 逻辑非运算符(!)</h3>
<h4 id="125121-运行时语义计算"><a class="markdownIt-Anchor" href="#125121-运行时语义计算"></a> 12.5.12.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExpression : ! UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>expr</code>为计算<code>UnaryExpression</code>的结果</li>
<li>令<code>oldValue</code>为<code>ToBoolean(GetValue(expr))</code></li>
<li><code>ReturnIfAbrupt(oldValue)</code></li>
<li>如果<code>oldValue</code>为<code>true</code>，返回<code>false</code></li>
<li>返回<code>true</code></li>
</ol>
<h2 id="126-指数运算符"><a class="markdownIt-Anchor" href="#126-指数运算符"></a> 12.6 指数运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExponentiationExpression[Yield]:</span><br><span class="line">	UnaryExpression[?Yield]</span><br><span class="line">	UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]</span><br></pre></td></tr></table></figure>
<h3 id="1263-运行时语义计算"><a class="markdownIt-Anchor" href="#1263-运行时语义计算"></a> 12.6.3 运行时语义:计算</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExponentiationExpression : UpdateExpression ** ExponentiationExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>left</code>为计算<code>UpdateExpression</code>的结果</li>
<li>令<code>leftValue</code>为<code>GetValue(left)</code></li>
<li>令<code>right</code>为计算<code>ExponentiationExpression</code>的结果</li>
<li>令<code>rightValue</code>为<code>GetValue(right)</code></li>
<li>令<code>base</code>为<code>ToNumber(leftValue)</code></li>
<li>令<code>exponent</code>为<code>ToNumber(rightValue)</code></li>
<li>返回将12.7.3.4中指定的<code>**</code>运算符应用到<code>base</code>和<code>exponent</code>的结果。</li>
</ol>
<h4 id="12734-应用运算符"><a class="markdownIt-Anchor" href="#12734-应用运算符"></a> 12.7.3.4 应用**运算符</h4>
<p>返回一个与实现有关的<code>base</code>的<code>exponent</code>次幂的结果的近似值。</p>
<ul>
<li>如果<code>exponent</code>为<code>NaN</code>，结果为<code>NaN</code></li>
<li>如果<code>exponent</code>为<code>+0</code>，结果为1，即使<code>base</code>为<code>NaN</code></li>
<li>如果<code>exponent</code>为<code>-0</code>，结果为1，即使<code>base</code>为<code>NaN</code></li>
<li>如果<code>base</code>为<code>NaN</code>并且<code>exponent</code>为非零，结果为<code>NaN</code></li>
<li>如果<code>abs(base) &gt; 1</code>并且<code>exponent</code>为<code>+∞</code>，结果为<code>+∞</code></li>
<li>如果<code>abs(base) &gt; 1</code>并且<code>exponent</code>为<code>-∞</code>，结果为<code>+0</code></li>
<li>如果<code>abs(base)</code>为<code>1</code>并且<code>exponent</code>为<code>+∞</code>，结果为<code>NaN</code></li>
<li>如果<code>abs(base)</code>为<code>1</code>并且<code>exponent</code>为<code>-∞</code>，结果为<code>NaN</code></li>
<li>如果<code>abs(base) &lt; 1</code>并且<code>exponent</code>为<code>+∞</code>，结果为<code>+0</code></li>
<li>如果<code>abs(base) &lt; 1</code>并且<code>exponent</code>为<code>-∞</code>，结果为<code>+∞</code></li>
<li>如果<code>base</code>为<code>+∞</code>并且<code>exponent &gt; 0</code>，结果为<code>+∞</code></li>
<li>如果<code>base</code>为<code>+∞</code>并且<code>exponent &lt; 0</code>，结果为<code>+0</code></li>
<li>如果<code>base</code>为<code>-∞</code>并且<code>exponent &gt; 0</code>并且<code>exponent</code>是奇数，结果为<code>-∞</code></li>
<li>如果<code>base</code>为<code>-∞</code>并且<code>exponent &gt; 0</code>并且<code>exponent</code>不是奇数，结果为<code>+∞</code></li>
<li>如果<code>base</code>为<code>-∞</code>并且<code>exponent &lt; 0</code>并且<code>exponent</code>是奇数，结果为<code>-0</code></li>
<li>如果<code>base</code>为<code>-∞</code>并且<code>exponent &lt; 0</code>并且<code>exponent</code>不是奇数，结果为<code>+0</code></li>
<li>如果<code>base</code>为<code>+0</code>并且<code>exponent &gt; 0</code>，结果为<code>+0</code></li>
<li>如果<code>base</code>为<code>+0</code>并且<code>exponent &lt; 0</code>，结果为<code>+∞</code></li>
<li>如果<code>base</code>为<code>-0</code>并且<code>exponent &gt; 0</code>并且<code>exponent</code>是奇数，结果为<code>-0</code></li>
<li>如果<code>base</code>为<code>-0</code>并且<code>exponent &gt; 0</code>并且<code>exponent</code>不是奇数，结果为<code>+0</code></li>
<li>如果<code>base</code>为<code>-0</code>并且<code>exponent &lt; 0</code>并且<code>exponent</code>是奇数，结果为<code>-∞</code></li>
<li>如果<code>base</code>为<code>-0</code>并且<code>exponent &lt; 0</code>并且<code>exponent</code>不是奇数，结果为<code>+∞</code></li>
<li>如果<code>base &lt; 0</code>并且<code>base</code>为有限值并且<code>exponent</code>为有限值并且<code>exponent</code>不是整数，结果为<code>NaN</code></li>
</ul>
<p>注意：当<code>base</code>为<code>1</code>或<code>-1</code>，并且<code>exponent</code>为<code>+Infinity</code>或<code>-Infinity</code>时，<code>base ** exponent</code>的结果与IEEE 754-2008不同。ECMAScript的第一版为此操作指定了<code>NaN</code>结果，而IEEE 754-2008的更高版本则指定了<code>1</code>。出于兼容性原因，保留了历史ECMAScript行为。</p>
<h2 id="126-乘性运算符"><a class="markdownIt-Anchor" href="#126-乘性运算符"></a> 12.6 乘性运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MultiplicativeExpression[Yield] :</span><br><span class="line">	UnaryExpression[?Yield]</span><br><span class="line">	MultiplicativeExpression[?Yield] MultiplicativeOperator UnaryExpression[?Yield]</span><br><span class="line"></span><br><span class="line">MultiplicativeOperator : one of</span><br><span class="line">	* &#x2F; %</span><br></pre></td></tr></table></figure>
<h3 id="1263-运行时语义计算-2"><a class="markdownIt-Anchor" href="#1263-运行时语义计算-2"></a> 12.6.3 运行时语义:计算</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator UnaryExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>left</code>为计算<code>MultiplicativeExpression</code>的结果</li>
<li>令<code>leftValue</code>为<code>GetValue(left)</code></li>
<li><code>ReturnIfAbrupt(leftValue)</code></li>
<li>令<code>right</code>为计算<code>UnaryExpression</code>的结果</li>
<li>令<code>rightValue</code>为<code>GetValue(right)</code></li>
<li>令<code>lnum</code>为<code>ToNumber(leftValue)</code></li>
<li><code>ReturnIfAbrupt(lnum)</code></li>
<li>令<code>rnum</code>为<code>ToNumber(rightValue)</code></li>
<li><code>ReturnIfAbrupt(rnum)</code></li>
<li>返回对<code>lnum</code>和<code>rnum</code>应用12.6.3.1, 12.6.3.2 或 12.6.3.3中指定的<code>MultiplicativeOperator (*, /, or %)</code>的结果</li>
</ol>
<h4 id="12631-应用运算符"><a class="markdownIt-Anchor" href="#12631-应用运算符"></a> 12.6.3.1 应用*运算符</h4>
<p><code>* MultiplicativeOperator</code>执行乘法，产生其操作数的乘积。 乘法是可交换的。 由于有限的精度，乘法在ECMAScript中并不总是可结合的。</p>
<p>浮点乘法的结果受IEEE 754-2008二进制双精度算法的规则支配：</p>
<ol>
<li>如果任一操作数为NaN，则结果为NaN。</li>
<li>如果两个操作数具有相同的符号，则结果的符号为正；如果两个操作数具有不同的符号，则结果为负。</li>
<li>无穷大乘以零会导致NaN。</li>
<li>无穷大与无穷大相乘会导致无穷大。 符号由上面已经陈述的规则确定。</li>
<li>无穷大与非零有限值的乘积导致有符号无穷大。 符号由上面已经陈述的规则确定。</li>
<li>在其余情况下，不涉及无穷大或NaN时，将使用IEEE 754-2008最近舍入模式计算乘积并将其舍入为最接近的可表示值。 如果模太大而无法表示，那么结果将是无穷大的适当符号。 如果模太小而无法表示，则结果为适当符号的零。 ECMAScript语言需要支持IEEE 754-2008定义的渐进式下溢。</li>
</ol>
<h4 id="12632-应用运算符"><a class="markdownIt-Anchor" href="#12632-应用运算符"></a> 12.6.3.2 应用/运算符</h4>
<p><code>/ MultiplicativeOperator</code>执行除法，产生其操作数的商。 左边的操作数是被除数，右边的操作数是除数。 ECMAScript不执行整数除法。 所有除法运算的操作数和结果均为双精度浮点数。 除法结果由IEEE 754-2008算法的规范确定：</p>
<ol>
<li>如果任一操作数为NaN，则结果为NaN。</li>
<li>如果两个操作数具有相同的符号，则结果的符号为正；如果两个操作数具有不同的符号，则结果为负。</li>
<li>无穷大除以无穷大会得到NaN。</li>
<li>无穷大除以零会导致无穷大。符号由上述规则确定。</li>
<li>无穷大除以非零有限值会导致有符号无穷大。符号由上述规则确定。</li>
<li>有限值除以无穷大将得出零。符号由上述规则确定。</li>
<li>将零除以零会产生NaN；将零除以任何其他有限值将得出零，其符号由上述规则确定。</li>
<li>非零有限值除以零会导致有符号无穷大。该标志由上述规则确定。</li>
<li>在其余情况下，既不涉及无穷大，也不涉及零，也不涉及NaN，则使用IEEE 754-2008舍入到最接近模式计算商并舍入到最接近的可表示值。如果模太大而无法表示，则操作会溢出；结果就是适当符号的无穷大。如果模太小而无法表示，则操作会下溢，并且结果为适当符号的零。 ECMAScript语言需要支持IEEE 754-2008定义的渐进式下溢。</li>
</ol>
<h4 id="12633-应用运算符"><a class="markdownIt-Anchor" href="#12633-应用运算符"></a> 12.6.3.3 应用%运算符</h4>
<p><code>% MultiplicativeOperator</code>从隐含的除法运算中得到余数； 左操作数是被除数，右操作数是除数。</p>
<p>注意：在C和C++中，取余运算符仅接受整数操作数。 在ECMAScript中，它也接受浮点操作数。</p>
<p>由％运算符计算的浮点余数运算的结果与IEEE 754-2008定义的“余数”运算不同。 IEEE 754-2008“余数”运算从舍入除法而不是截断除法计算余数，因此其行为与通常的整数余数运算符的行为不相似。 相反，ECMAScript语言在浮点运算上定义了％，其行为类似于Java整数余数运算符； 可以将其与C库函数fmod进行比较。</p>
<p>ECMAScript浮点余数运算的结果由IEEE算术规则确定：</p>
<ol>
<li>如果任一操作数为NaN，则结果为NaN。</li>
<li>结果的符号等于被除数的符号。</li>
<li>如果被除数是无穷大，或者除数是零，或者两者都是，则结果为NaN。</li>
<li>如果被除数是有限的，并且除数是无穷大，则结果等于被除数。</li>
<li>如果被除数为零，并且除数为非零且有限，则结果与被除数相同。</li>
<li>在其余情况下，既不涉及无穷大，也不涉及零，也不涉及NaN，则被除数n和除数d的浮点余数r由数学关系<code>r = n − (d × q)</code>定义，其中q 是一个整数，仅当n / d为负时才为负，而只有当n / d为正时才为正，并且其大小应尽可能大，而不会超过n和d的真数学商。 使用IEEE 754-2008最近舍入模式计算r并舍入到最接近的可表示值。</li>
</ol>
<h2 id="127-加性运算符"><a class="markdownIt-Anchor" href="#127-加性运算符"></a> 12.7 加性运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AdditiveExpression[Yield] :</span><br><span class="line">	MultiplicativeExpression[?Yield]</span><br><span class="line">	AdditiveExpression[?Yield] + MultiplicativeExpression[?Yield]</span><br><span class="line">	AdditiveExpression[?Yield] - MultiplicativeExpression[?Yield]</span><br></pre></td></tr></table></figure>
<h3 id="1273-加法运算符"><a class="markdownIt-Anchor" href="#1273-加法运算符"></a> 12.7.3 加法运算符(+)</h3>
<p>加法运算符执行字符串连接或数字加法。</p>
<h4 id="12731-运行时语义计算"><a class="markdownIt-Anchor" href="#12731-运行时语义计算"></a> 12.7.3.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdditiveExpression : AdditiveExpression + MultiplicativeExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>AdditiveExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>MultiplicativeExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>lprim</code>为<code>ToPrimitive(lval)</code></li>
<li><code>ReturnIfAbrupt(lprim)</code></li>
<li>令<code>rprim</code>为<code>ToPrimitive(rval)</code></li>
<li><code>ReturnIfAbrupt(rprim)</code></li>
<li>如果<code>Type(lprim)</code>为<code>String</code>或者<code>Type(rprim)</code>为<code>String</code>，则
<ol>
<li>令<code>lstr</code>为<code>ToString(lprim)</code></li>
<li><code>ReturnIfAbrupt(lstr)</code></li>
<li>令<code>rstr</code>为<code>ToString(rprim)</code></li>
<li><code>ReturnIfAbrupt(rstr)</code></li>
<li>返回由<code>lstr</code>和<code>rstr</code>连接而成的字符串</li>
</ol>
</li>
<li>令<code>lnum</code>为<code>ToNumber(lprim)</code></li>
<li><code>ReturnIfAbrupt(lnum)</code></li>
<li>令<code>rnum</code>为<code>ToNumber(rprim)</code></li>
<li><code>ReturnIfAbrupt(rnum)</code></li>
<li>返回对<code>lnum</code>和<code>rnum</code>应用加法运算符的结果。参见12.7.5下面的注。</li>
</ol>
<p>注1：在第7步和第9步中对ToPrimitive的调用中未提供任何提示。除Date对象外，所有标准对象在处理时将其当做提示<code>Number</code>。 Date对象在处理时当做提示<code>String</code>。奇异对象可能以其他方式处理缺失的提示。</p>
<p>注2：步骤11与抽象关系比较算法（7.2.11）的步骤5不同，它使用逻辑或运算而不是逻辑与运算。</p>
<h3 id="1274-减法运算符-"><a class="markdownIt-Anchor" href="#1274-减法运算符-"></a> 12.7.4 减法运算符(-)</h3>
<h4 id="12741-运行时语义计算"><a class="markdownIt-Anchor" href="#12741-运行时语义计算"></a> 12.7.4.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdditiveExpression : AdditiveExpression - MultiplicativeExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>AdditiveExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>MultiplicativeExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>lnum</code>为<code>ToNumber(lval)</code></li>
<li><code>ReturnIfAbrupt(lnum)</code></li>
<li>令<code>rnum</code>为<code>ToNumber(rval)</code></li>
<li><code>ReturnIfAbrupt(rnum)</code></li>
<li>返回对<code>lnum</code>和<code>rnum</code>应用减法运算符的结果。参见12.7.5下面的注。</li>
</ol>
<h3 id="1275-对数字应用加性运算符"><a class="markdownIt-Anchor" href="#1275-对数字应用加性运算符"></a> 12.7.5 对数字应用加性运算符</h3>
<p>当将<code>+</code>运算符应用于两个数字类型的操作数时，它们将执行加法运算，从而产生操作数之和。 <code>-</code>运算符执行减法运算，产生两个数字操作数的差。</p>
<p>加法是可交换的运算，但并不总是可结合的。</p>
<p>加法的结果使用IEEE 754-2008二进制双精度算法的规则确定：</p>
<ul>
<li>如果任一操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>两个相反符号的无穷大之和为<code>NaN</code></li>
<li>两个相同符号的无穷大之和为该符号的无穷大。</li>
<li>无穷大与有限值之和等于该符号的无穷大</li>
<li>两个负零之和为<code>-0</code>。两个正零或两个符号相反的零的和为<code>+0</code></li>
<li>零和非零有限值之和等于该非零操作数</li>
<li>模相同符号相反的两个非零有限值的和为<code>+0</code></li>
<li>在其余情况下，既不涉及无穷大，也不涉及零，也不涉及NaN，并且操作数具有相同的符号或有不同的模，则使用IEEE 754-2008最近舍入计算出和并舍入到最接近的可表示值。如果模太大而无法表示，则操作会溢出，结果将是适当符号的无穷大。 ECMAScript语言需要支持IEEE 754-2008定义的渐进式下溢。</li>
</ul>
<p>注：当<code>-</code>运算符应用于两个数字类型的操作数时，将执行减法运算，从而产生其操作数之差； 左边的操作数是被减数，右边的操作数是减数。 给定数字操作数a和b，<code>a-b</code>永远与<code>a+(-b)</code>的结果相同</p>
<h2 id="128-移位运算符"><a class="markdownIt-Anchor" href="#128-移位运算符"></a> 12.8 移位运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShiftExpression[Yield] :</span><br><span class="line">	AdditiveExpression[?Yield]</span><br><span class="line">	ShiftExpression[?Yield] &lt;&lt; AdditiveExpression[?Yield]</span><br><span class="line">	ShiftExpression[?Yield] &gt;&gt; AdditiveExpression[?Yield]</span><br><span class="line">	ShiftExpression[?Yield] &gt;&gt;&gt; AdditiveExpression[?Yield]</span><br></pre></td></tr></table></figure>
<h3 id="1283-左移运算符"><a class="markdownIt-Anchor" href="#1283-左移运算符"></a> 12.8.3 左移运算符(&lt;&lt;)</h3>
<p>注意：在左侧操作数上按右侧操作数指定的量执行左移运算。</p>
<h4 id="12831-运行时语义计算"><a class="markdownIt-Anchor" href="#12831-运行时语义计算"></a> 12.8.3.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShiftExpression : ShiftExpression &lt;&lt; AdditiveExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>AdditiveExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>lnum</code>为<code>ToInt32(lval)</code></li>
<li><code>ReturnIfAbrupt(lnum)</code></li>
<li>令<code>rnum</code>为<code>ToUint32(rval)</code></li>
<li><code>ReturnIfAbrupt(rnum)</code></li>
<li>令<code>shiftCount</code>为截取<code>rnum</code>最低<code>5</code>位（<code>rnum module 32</code>）的结果，即计算<code>rnum &amp; 0x1F</code></li>
<li>返回将<code>lnum</code>左移<code>shiftCount</code>位得到的结果。此结果是32位有符号整数。</li>
</ol>
<h3 id="1284-有符号右移运算符"><a class="markdownIt-Anchor" href="#1284-有符号右移运算符"></a> 12.8.4 有符号右移运算符(&gt;&gt;)</h3>
<p>注意：在左侧操作数上按右侧操作数指定的量执行符号填充的右移运算。</p>
<h4 id="12841-运行时语义计算"><a class="markdownIt-Anchor" href="#12841-运行时语义计算"></a> 12.8.4.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShiftExpression : ShiftExpression &gt;&gt; AdditiveExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>AdditiveExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>lnum</code>为<code>ToInt32(lval)</code></li>
<li><code>ReturnIfAbrupt(lnum)</code></li>
<li>令<code>rnum</code>为<code>ToUint32(rval)</code></li>
<li><code>ReturnIfAbrupt(rnum)</code></li>
<li>令<code>shiftCount</code>为截取<code>rnum</code>最低<code>5</code>位（<code>rnum module 32</code>）的结果，即计算<code>rnum &amp; 0x1F</code></li>
<li>返回将<code>lnum</code>进行符号扩展右移<code>shiftCount</code>位得到的结果。最高有效位被传播。结果是32位有符号整数。</li>
</ol>
<h3 id="1285-无符号右移运算符"><a class="markdownIt-Anchor" href="#1285-无符号右移运算符"></a> 12.8.5 无符号右移运算符(&gt;&gt;&gt;)</h3>
<p>注意：在左侧操作数上按右侧操作数指定的量执行<code>0</code>填充的右移运算。</p>
<h4 id="12851-运行时语义计算"><a class="markdownIt-Anchor" href="#12851-运行时语义计算"></a> 12.8.5.1 运行时语义:计算</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShiftExpression : ShiftExpression &gt;&gt;&gt; AdditiveExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>AdditiveExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>lnum</code>为<code>ToUInt32(lval)</code></li>
<li><code>ReturnIfAbrupt(lnum)</code></li>
<li>令<code>rnum</code>为<code>ToUint32(rval)</code></li>
<li><code>ReturnIfAbrupt(rnum)</code></li>
<li>令<code>shiftCount</code>为截取<code>rnum</code>最低<code>5</code>位（<code>rnum module 32</code>）的结果，即计算<code>rnum &amp; 0x1F</code></li>
<li>返回将<code>lnum</code>进行<code>0</code>填充右移<code>shiftCount</code>位得到的结果。腾空的位使用<code>0</code>填充。结果是32位无符号整数。</li>
</ol>
<h2 id="129-关系运算符"><a class="markdownIt-Anchor" href="#129-关系运算符"></a> 12.9 关系运算符</h2>
<p>注意：计算关系运算符的结果始终是布尔类型，反映了运算符命名的关系是否在它的两个操作数之间成立。</p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RelationalExpression[In, Yield] :</span><br><span class="line">	ShiftExpression[?Yield]</span><br><span class="line">	RelationalExpression[?In, ?Yield] &lt; ShiftExpression[?Yield]</span><br><span class="line">	RelationalExpression[?In, ?Yield] &gt; ShiftExpression[?Yield]</span><br><span class="line">	RelationalExpression[?In, ?Yield] &lt;&#x3D; ShiftExpression[? Yield]</span><br><span class="line">	RelationalExpression[?In, ?Yield] &gt;&#x3D; ShiftExpression[?Yield]</span><br><span class="line">	RelationalExpression[?In, ?Yield] instanceof ShiftExpression[?Yield]</span><br><span class="line">	[+In] RelationalExpression[In, ?Yield] in ShiftExpression[?Yield]</span><br></pre></td></tr></table></figure>
<p>注意：为了避免将关系表达式中的<code>in</code>运算符与for语句中的<code>in</code>运算符混淆，需要使用<code>[In]</code>语法参数。</p>
<h3 id="1293-运行时语义-计算"><a class="markdownIt-Anchor" href="#1293-运行时语义-计算"></a> 12.9.3 运行时语义: 计算</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RelationalExpression : RelationalExpression &lt; ShiftExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li>令<code>r</code>为执行抽象关系比较<code>lval &lt; rval</code>的结果（见7.2.11）</li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>如果<code>r</code>为<code>undefined</code>，返回<code>false</code>，否则，返回<code>r</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RelationalExpression : RelationalExpression &gt; ShiftExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li>令<code>r</code>为使用参数<code>LeftFirst = false</code>执行抽象关系比较<code>rval &lt; lval</code>的结果</li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>如果<code>r</code>为<code>undefined</code>，返回<code>false</code>，否则，返回<code>r</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RelationalExpression : RelationalExpression &lt;= ShiftExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li>令<code>r</code>为使用参数<code>LeftFirst = false</code>执行抽象关系比较<code>rval &lt; lval</code>的结果</li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>如果<code>r</code>为<code>true</code>或<code>undefined</code>，返回<code>false</code>，否则，返回<code>true</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RelationalExpression : RelationalExpression &gt;= ShiftExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li>令<code>r</code>为执行抽象关系比较<code>lval &lt; rval</code>的结果</li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>如果<code>r</code>为<code>true</code>或<code>undefined</code>，返回<code>false</code>，否则，返回<code>true</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RelationalExpression : RelationalExpression instanceof ShiftExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>返回<code>InstanceofOperator(lval, rval)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RelationalExpression : RelationalExpression <span class="keyword">in</span> ShiftExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>ShiftExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>如果<code>Type(rval)</code>不是<code>Object</code>，抛出 TypeError 异常</li>
<li>返回<code>HasProperty(rval, ToPropertyKey(lval))</code></li>
</ol>
<h3 id="1294-运行时语义-instanceofoperatoro-c"><a class="markdownIt-Anchor" href="#1294-运行时语义-instanceofoperatoro-c"></a> 12.9.4 运行时语义: InstanceofOperator(O, C)</h3>
<p>抽象操作InstanceofOperator(O，C)实现了通用算法，该算法用于确定对象<code>O</code>是否从构造函数<code>C</code>定义的继承路径继承。此抽象操作执行以下步骤：</p>
<ol>
<li>如果<code>Type(C)</code>不是<code>Object</code>，抛出<code>TypeError</code>异常</li>
<li>令<code>instOfHandler</code>为<code>GetMethod(C,@@hasInstance)</code></li>
<li><code>ReturnIfAbrupt(instOfHandler)</code></li>
<li>如果<code>instOfHandler</code>不是<code>undefined</code>，则返回<code>ToBoolean(Call(instOfHandler, C, «O»))</code></li>
<li>如果<code>IsCallable(C)</code>为<code>false</code>，抛出<code>TypeError</code>异常</li>
<li>返回<code>OrdinaryHasInstance(C, O)</code></li>
</ol>
<p>注意：步骤5和6提供了与ECMAScript以前版本的兼容性，以前版本未使用<code>@@hasInstance</code>方法来定义<code>instanceof</code>操作符的语义。如果函数对象未定义或继承<code>@@hasInstance</code>，则它将使用默认的<code>instanceof</code>语义。</p>
<h2 id="1210-相等运算符"><a class="markdownIt-Anchor" href="#1210-相等运算符"></a> 12.10 相等运算符</h2>
<p>注：计算相等运算符的结果始终是布尔类型，反映了该运算符命名的关系是否在其两个操作数之间成立。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EqualityExpression[In, Yield] :</span><br><span class="line">	RelationalExpression[?In, ?Yield]</span><br><span class="line">	EqualityExpression[?In, ?Yield] == RelationalExpression[?In, ?Yield]</span><br><span class="line">	EqualityExpression[?In, ?Yield] != RelationalExpression[?In, ?Yield]</span><br><span class="line">	EqualityExpression[?In, ?Yield] === RelationalExpression[?In, ?Yield]</span><br><span class="line">	EqualityExpression[?In, ?Yield] !== RelationalExpression[?In, ?Yield]</span><br></pre></td></tr></table></figure>
<h3 id="12103-运行时语义计算"><a class="markdownIt-Anchor" href="#12103-运行时语义计算"></a> 12.10.3 运行时语义:计算</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EqualityExpression : EqualityExpression == RelationalExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>EqualityExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>返回执行抽象相等比较<code>rval == lval</code>的结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EqualityExpression : EqualityExpression != RelationalExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>EqualityExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>r</code>为执行抽象相等比较<code>rval == lval</code>的结果</li>
<li>如果<code>r</code>为<code>true</code>，返回<code>false</code>，否则返回<code>true</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EqualityExpression : EqualityExpression === RelationalExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>EqualityExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>返回执行严格相等比较<code>rval == lval</code>的结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EqualityExpression : EqualityExpression !== RelationalExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>EqualityExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>RelationalExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>r</code>为执行严格相等比较<code>rval == lval</code>的结果</li>
<li>如果<code>r</code>为<code>true</code>，返回<code>false</code>，否则返回<code>true</code></li>
</ol>
<p>注1：给定以上相等性定义：</p>
<ul>
<li>可以通过<code>&quot;&quot; + a == &quot;&quot; + b</code>强制进行字符串比较</li>
<li>可以通过<code>+a == +b</code>强制进行数字比较</li>
<li>可以通过<code>!a == !b</code>强制进行布尔比较</li>
</ul>
<p>注2：相等运算符保持以下不变式：</p>
<ul>
<li><code>A != B</code>等价于<code>!(A == B)</code></li>
<li><code>A == B</code>等价于<code>B == A</code>，但求值顺序仍然是先A后B</li>
</ul>
<p>注3：相等运算符并不总是可传递的。 例如，可能有两个不同的String对象，每个对象有相同的String值； <code>==</code>运算符会认为String对象和String值相等，但是两个String对象彼此不相等（因为String对象的类型是<code>Object</code>而，String值的类型是<code>String</code>）。 例如：</p>
<ul>
<li><code>new String(&quot;a&quot;) == &quot;a&quot;</code>和<code>&quot;a&quot; == new String(&quot;a&quot;)</code>都为<code>true</code></li>
<li><code>new String(&quot;a&quot;) == new String(&quot;a&quot;)</code>为<code>false</code></li>
</ul>
<p>注4：字符串比较对代码单元值的序列使用简单的相等性测试。 没有尝试使用更复杂的，面向语义的字符或字符串相等性定义以及Unicode规范中定义的整理顺序。 因此，根据Unicode标准规范相等的字符串值可以测试为不相等。 实际上，该算法假定两个字符串都已经处于规范化形式。</p>
<h2 id="1211-二元位运算符"><a class="markdownIt-Anchor" href="#1211-二元位运算符"></a> 12.11 二元位运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BitwiseANDExpression[In, Yield] :</span><br><span class="line">	EqualityExpression[?In, ?Yield]</span><br><span class="line">	BitwiseANDExpression[?In, ?Yield] &amp; EqualityExpression[?In, ?Yield]</span><br><span class="line"></span><br><span class="line">BitwiseXORExpression[In, Yield] :</span><br><span class="line">	BitwiseANDExpression[?In, ?Yield]</span><br><span class="line">	BitwiseXORExpression[?In, ?Yield] ^ BitwiseANDExpression[?In, ?Yield]</span><br><span class="line"></span><br><span class="line">BitwiseORExpression[In, Yield] :</span><br><span class="line">	BitwiseXORExpression[?In, ?Yield]</span><br><span class="line">	BitwiseORExpression[?In, ?Yield] | BitwiseXORExpression[?In, ?Yield]</span><br></pre></td></tr></table></figure>
<h3 id="12113-运行时语义-计算"><a class="markdownIt-Anchor" href="#12113-运行时语义-计算"></a> 12.11.3 运行时语义: 计算</h3>
<p>产生式<code>A : A @ B</code>中<code>@</code>是上面产生式中的位运算符之一，它的计算过程如下：</p>
<ol>
<li>令<code>lref</code>为计算<code>A</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code>为计算<code>B</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>lnum</code>为<code>ToInt32(lval)</code></li>
<li><code>ReturnIfAbrupt(lnum)</code></li>
<li>令<code>rnum</code>为<code>ToInt32(rval)</code></li>
<li><code>ReturnIfAbrupt(rnum)</code></li>
<li>返回对<code>lnum</code>和<code>rnum</code>应用位运算符<code>@</code>的结果。此结果是一个32位有符号整数。</li>
</ol>
<h2 id="1212-二元逻辑运算符"><a class="markdownIt-Anchor" href="#1212-二元逻辑运算符"></a> 12.12 二元逻辑运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LogicalANDExpression[In, Yield] :</span><br><span class="line">	BitwiseORExpression[?In, ?Yield]</span><br><span class="line">	LogicalANDExpression[?In, ?Yield] &amp;&amp; BitwiseORExpression[?In, ?Yield]</span><br><span class="line"></span><br><span class="line">LogicalORExpression[In, Yield] :</span><br><span class="line">	LogicalANDExpression[?In, ?Yield]</span><br><span class="line">	LogicalORExpression[?In, ?Yield] || LogicalANDExpression[?In, ?Yield]</span><br><span class="line"></span><br><span class="line">CoalesceExpression[In, Yield, Await]:</span><br><span class="line">    CoalesceExpressionHead[?In, ?Yield, ?Await]??BitwiseORExpression[?In, ?Yield, ?Await]</span><br><span class="line"></span><br><span class="line">CoalesceExpressionHead[In, Yield, Await]:</span><br><span class="line">    CoalesceExpression[?In, ?Yield, ?Await]</span><br><span class="line">    BitwiseORExpression[?In, ?Yield, ?Await]</span><br><span class="line"></span><br><span class="line">ShortCircuitExpression[In, Yield, Await]:</span><br><span class="line">    LogicalORExpression[?In, ?Yield, ?Await]</span><br><span class="line">    CoalesceExpression[?In, ?Yield, ?Await]</span><br></pre></td></tr></table></figure>
<p>注意：由<code>&amp;&amp;</code>或<code>||</code>运算符产生的值不一定是<code>Boolean</code>类型。 产生的值将始终是两个操作数表达式的值之一。</p>
<h3 id="12123-运行时语义-计算"><a class="markdownIt-Anchor" href="#12123-运行时语义-计算"></a> 12.12.3 运行时语义: 计算</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LogicalANDExpression:</span><br><span class="line">    LogicalANDExpression &amp;&amp; BitwiseORExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>LogicalANDExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li>令<code>lbool</code>为<code>ToBoolean(lval)</code></li>
<li><code>ReturnIfAbrupt(lbool)</code></li>
<li>如果<code>lbool</code>为<code>false</code>，返回<code>lval</code></li>
<li>令<code>rref</code>为计算<code>BitwiseORExpression</code>的结果</li>
<li>返回<code>GetValue(rref)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LogicalORExpression:</span><br><span class="line">    LogicalORExpression || LogicalANDExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>LogicalORExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li>令<code>lbool</code>为<code>ToBoolean(lval)</code></li>
<li><code>ReturnIfAbrupt(lbool)</code></li>
<li>如果<code>lbool</code>为<code>true</code>，返回<code>lval</code></li>
<li>令<code>rref</code>为计算<code>LogicalANDExpression</code>的结果</li>
<li>返回<code>GetValue(rref)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CoalesceExpression:</span><br><span class="line">    CoalesceExpressionHead ?? BitwiseORExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>CoalesceExpressionHead</code>的结果</li>
<li>令<code>lval</code>为? <code>GetValue(lref)</code></li>
<li>如果<code>lval</code>是<code>undefined</code>或<code>null</code>，则
<ol>
<li>令<code>rref</code>为计算<code>BitwiseORExpression</code>的结果</li>
<li>返回 ? <code>GetValue(rref)</code></li>
</ol>
</li>
<li>否则，返回<code>lval</code></li>
</ol>
<h2 id="1213-条件运算符"><a class="markdownIt-Anchor" href="#1213-条件运算符"></a> 12.13 条件运算符</h2>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConditionalExpression[In, Yield] :</span><br><span class="line">	LogicalORExpression[?In, ?Yield]</span><br><span class="line">	LogicalORExpression[?In,?Yield] ? AssignmentExpression[In, ?Yield] : AssignmentExpression[?In, ?Yield]</span><br></pre></td></tr></table></figure>
<p>注：ECMAScript中的ConditionalExpression的语法与C和Java中的略有不同，后者分别允许第二个子表达式为Expression，但将第三个表达式限制为ConditionalExpression。 ECMAScript中这种差异的动机是允许赋值表达式由条件的任一分支支配，并消除以逗号表达式为中心表达式的令人困惑且相当无用的情况。</p>
<h3 id="12133-运行时语义计算"><a class="markdownIt-Anchor" href="#12133-运行时语义计算"></a> 12.13.3 运行时语义:计算</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>LogicalORExpression</code>的结果</li>
<li>令<code>lval</code>为<code>ToBoolean(GetValue(lref))</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>如果<code>lval</code>为<code>true</code>，则
<ol>
<li>令<code>trueRef</code>为计算第一个<code>AssignmentExpression</code>的结果</li>
<li>返回<code>GetValue(trueRef)</code></li>
</ol>
</li>
<li>否则：
<ol>
<li>令<code>falseRef</code>为计算第二个<code>AssignmentExpression</code>的结果</li>
<li>返回<code>GetValue(falseRef)</code></li>
</ol>
</li>
</ol>
<h2 id="1214-赋值运算符"><a class="markdownIt-Anchor" href="#1214-赋值运算符"></a> 12.14 赋值运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssignmentExpression[In, Yield] :</span><br><span class="line">	ConditionalExpression[?In, ?Yield]</span><br><span class="line">	[+Yield] YieldExpression[?In]</span><br><span class="line">	ArrowFunction[?In, ?Yield]</span><br><span class="line">	LeftHandSideExpression[?Yield] &#x3D; AssignmentExpression[?In, ?Yield]</span><br><span class="line">	LeftHandSideExpression[?Yield] AssignmentOperator AssignmentExpression[?In, ?Yield]</span><br><span class="line"></span><br><span class="line">AssignmentOperator : one of</span><br><span class="line">	*&#x3D; &#x2F;&#x3D; %&#x3D; +&#x3D; -&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</span><br></pre></td></tr></table></figure>
<h3 id="12144-运行时语义计算"><a class="markdownIt-Anchor" href="#12144-运行时语义计算"></a> 12.14.4 运行时语义:计算</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentExpression[In, Yield] : LeftHandSideExpression[?Yield] &#x3D; AssignmentExpression[?In, ?Yield]</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>LeftHandSideExpression</code>既不是<code>ObjectLiteral</code>也不是<code>ArrayLiteral</code>，则
<ol>
<li>令<code>lref</code>为计算<code>LeftHandSideExpression</code>的结果</li>
<li><code>ReturnIfAbrupt(lref)</code></li>
<li>令<code>rref</code>为计算<code>AssignmentExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li>如果<code>IsAnonymousFunctionDefinition(AssignmentExpression)</code>和<code>LeftHandSideExpression</code>的<code>IsIdentifierRef</code>都为<code>true</code>，则
<ol>
<li>令<code>hasNameProperty</code>为<code>HasOwnProperty(rval, &quot;name&quot;)</code></li>
<li><code>ReturnIfAbrupt(hasNameProperty)</code></li>
<li>如果<code>hasNameProperty</code>为<code>false</code>，执行<code>SetFunctionName(rval, GetReferencedName(lref))</code></li>
</ol>
</li>
<li>令<code>status</code>为<code>PutValue(lref, rval)</code></li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回<code>rval</code></li>
</ol>
</li>
<li>令<code>assignmentPattern</code>为使用<code>AssignmentPattern[?Yield]</code>作为目标符号解析<code>LeftHandSideExpression</code>对应源文本</li>
<li>令<code>rref</code>为计算<code>AssignmentExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>status</code>为使用<code>rval</code>作为参数执行<code>assignmentPattern</code>的<code>DestructuringAssignmentEvaluation</code>的结果</li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回<code>rval</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>LeftHandSideExpression</code>的结果</li>
<li>令<code>lval</code>为<code>GetValue(lref)</code></li>
<li><code>ReturnIfAbrupt(lval)</code></li>
<li>令<code>rref</code> 为计算<code>AssignmentExpression</code>的结果</li>
<li>令<code>rval</code>为<code>GetValue(rref)</code></li>
<li><code>ReturnIfAbrupt(rval)</code></li>
<li>令<code>op</code>为<code>AssignmentOperator : @=</code>中的<code>@</code></li>
<li>令<code>r</code> 为将<code>op</code>应用于<code>lval</code>和<code>rval</code>的结果，就像计算表达式<code>lval op rval</code>一样。</li>
<li>令<code>status</code>为<code>PutValue(lref, r)</code></li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回<code>r</code></li>
</ol>
<h3 id="12145-解构赋值"><a class="markdownIt-Anchor" href="#12145-解构赋值"></a> 12.14.5 解构赋值</h3>
<p>补充语法</p>
<p>在某些情况下，在处理产生式<code>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</code>时，以下语法用于完善<code>LeftHandSideExpression</code>的解释。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">AssignmentPattern[Yield] :</span><br><span class="line">	ObjectAssignmentPattern[?Yield]</span><br><span class="line">	ArrayAssignmentPattern[?Yield]</span><br><span class="line"></span><br><span class="line">ObjectAssignmentPattern[Yield] :</span><br><span class="line">	&#123; &#125;</span><br><span class="line">	&#123; AssignmentPropertyList[?Yield] &#125;</span><br><span class="line">	&#123; AssignmentPropertyList[?Yield] , &#125;</span><br><span class="line"></span><br><span class="line">ArrayAssignmentPattern[Yield] :</span><br><span class="line">	[ Elision&#123;opt&#125; AssignmentRestElement[?Yield]opt ]</span><br><span class="line">	[ AssignmentElementList[?Yield] ]</span><br><span class="line">	[ AssignmentElementList[?Yield] , Elision&#123;opt&#125; AssignmentRestElement[?Yield]opt ]</span><br><span class="line"></span><br><span class="line">AssignmentPropertyList[Yield] :</span><br><span class="line">	AssignmentProperty[?Yield]</span><br><span class="line">	AssignmentPropertyList[?Yield] , AssignmentProperty[?Yield]</span><br><span class="line"></span><br><span class="line">AssignmentElementList[Yield] :</span><br><span class="line">	AssignmentElisionElement[?Yield]</span><br><span class="line">	AssignmentElementList[?Yield] , AssignmentElisionElement[?Yield]</span><br><span class="line"></span><br><span class="line">AssignmentElisionElement[Yield] :</span><br><span class="line">	Elision&#123;opt&#125; AssignmentElement[?Yield]</span><br><span class="line"></span><br><span class="line">AssignmentProperty[Yield] :</span><br><span class="line">	IdentifierReference[?Yield] Initializer[In,?Yield]opt</span><br><span class="line">	PropertyName : AssignmentElement[?Yield]</span><br><span class="line"></span><br><span class="line">AssignmentElement[Yield] :</span><br><span class="line">	DestructuringAssignmentTarget[?Yield] Initializer[In,?Yield]opt</span><br><span class="line"></span><br><span class="line">AssignmentRestElement[Yield] :</span><br><span class="line">	... DestructuringAssignmentTarget[?Yield]</span><br><span class="line"></span><br><span class="line">DestructuringAssignmentTarget[Yield] :</span><br><span class="line">	LeftHandSideExpression[?Yield]</span><br></pre></td></tr></table></figure>
<h4 id="121451-静态语义早期错误"><a class="markdownIt-Anchor" href="#121451-静态语义早期错误"></a> 12.14.5.1 静态语义:早期错误</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentProperty : IdentifierReference Initializer&#123;opt&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>IdentifierReference</code>的<code>IsValidSimpleAssignmentTarget</code>为<code>false</code>则是语法错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DestructuringAssignmentTarget : LeftHandSideExpression</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>LeftHandSideExpression</code>是<code>ObjectLiteral</code>或<code>ArrayLiteral</code>，并且如果使用<code>AssignmentPattern</code>作为目标符号无法解析没有剩余标记的情况下解析<code>LeftHandSideExpression</code>匹配的词汇标记序列，则会出现语法错误。</li>
<li>如果<code>LeftHandSideExpression</code>既不是<code>ObjectLiteral</code>也不是<code>ArrayLiteral</code>，并且<code>IsValidSimpleAssignmentTarget(LeftHandSideExpression)</code>为<code>false</code>，则是语法错误。</li>
</ul>
<h4 id="121452-运行时语义destructuringassignmentevaluation"><a class="markdownIt-Anchor" href="#121452-运行时语义destructuringassignmentevaluation"></a> 12.14.5.2 运行时语义:DestructuringAssignmentEvaluation</h4>
<p>接受参数<code>value</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentProperty : IdentifierReference Initializer&#123;opt&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>P</code>为<code>IdentifierReference</code>的<code>StringValue</code></li>
<li>令<code>lref</code>为<code>ResolveBinding(P)</code></li>
<li><code>ReturnIfAbrupt(P)</code></li>
<li>令<code>v</code>为<code>GetV(value, P)</code>(ToObject(value).P)</li>
<li><code>ReturnIfAbrupt(v)</code></li>
<li>如果<code>Initializer&#123;opt&#125;</code>存在，且<code>v</code>是<code>undefined</code>，则
<ol>
<li>令<code>defaultValue</code>为计算<code>Initializer</code>的结果</li>
<li>令<code>v</code>为<code>GetValue(defaultValue)</code></li>
<li><code>ReturnIfAbrupt(v)</code></li>
<li>如果<code>IsAnonymousFunctionDefinition(Initializer)</code>为<code>true</code>，则
<ol>
<li>令<code>hasNameProperty</code>为<code>HasOwnProperty(v, &quot;name&quot;)</code></li>
<li><code>ReturnIfAbrupt(hasNameProperty)</code></li>
<li>如果<code>hasNameProperty</code>为<code>false</code>，执行<code>SetFunctionName(v, P)</code></li>
</ol>
</li>
</ol>
</li>
<li>返回<code>PutValue(lref,v)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentProperty : PropertyName : AssignmentElement</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>name</code>为计算<code>PropertyName</code>的结果</li>
<li><code>ReturnIfAbrupt(name)</code></li>
<li>返回使用参数<code>value</code>和<code>name</code>执行<code>AssignmentElement</code>的<code>KeyedDestructuringAssignmentEvaluation</code>的结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayAssignmentPattern : [ ]</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>iterator</code>为<code>GetIterator(value)</code></li>
<li><code>ReturnIfAbrupt(iterator)</code></li>
<li>返回<code>IteratorClose(iterator, NormalCompletion(empty))</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayAssignmentPattern : [ Elision ]</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>iterator</code>为<code>GetIterator(value)</code></li>
<li><code>ReturnIfAbrupt(iterator)</code></li>
<li>令<code>iteratorRecord</code>为<code>Record &#123;[[iterator]]: iterator, [[done]]: false&#125;</code></li>
<li>令<code>result</code>为使用参数<code>iteratorRecord</code>执行<code>Elision</code>的<code>IteratorDestructuringAssignmentEvaluation</code>结果</li>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，返回<code>IteratorClose(iterator, result)</code></li>
<li>返回<code>result</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayAssignmentPattern : [ Elision&#123;opt&#125; AssignmentRestElement ]</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>iterator</code>为<code>GetIterator(value)</code></li>
<li><code>ReturnIfAbrupt(iterator)</code></li>
<li>令<code>iteratorRecord</code>为<code>Record &#123;[[iterator]]: iterator, [[done]]: false&#125;</code></li>
<li>如果<code>Elision</code>存在，则
<ol>
<li>令<code>status</code>为使用参数<code>iteratorRecord</code>执行<code>Elision</code>的<code>IteratorDestructuringAssignmentEvaluation</code>结果</li>
<li>如果<code>status</code>是非常规完结，则
<ol>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，返回<code>IteratorClose(iterator, status)</code></li>
<li>返回<code>Completion(status)</code></li>
</ol>
</li>
</ol>
</li>
<li>令<code>result</code>为使用参数<code>iteratorRecord</code>执行<code>AssignmentRestElement</code>的<code>IteratorDestructuringAssignmentEvaluation</code>结果</li>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，返回<code>IteratorClose(iterator, result)</code></li>
<li>返回<code>result</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayAssignmentPattern : [ AssignmentElementList ]</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>iterator</code>为<code>GetIterator(value)</code></li>
<li><code>ReturnIfAbrupt(iterator)</code></li>
<li>令<code>iteratorRecord</code>为<code>Record &#123;[[iterator]]: iterator, [[done]]: false&#125;</code></li>
<li>令<code>result</code>为使用参数<code>iteratorRecord</code>执行<code>AssignmentElementList</code>的<code>IteratorDestructuringAssignmentEvaluation</code>结果</li>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，返回<code>IteratorClose(iterator, result)</code></li>
<li>返回<code>result</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayAssignmentPattern : [ AssignmentElementList , Elision&#123;opt&#125; AssignmentRestElement&#123;opt&#125; ]</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>iterator</code>为<code>GetIterator(value)</code></li>
<li><code>ReturnIfAbrupt(iterator)</code></li>
<li>令<code>iteratorRecord</code>为<code>Record &#123;[[iterator]]: iterator, [[done]]: false&#125;</code></li>
<li>令<code>status</code>为使用参数<code>iteratorRecord</code>执行<code>AssignmentElementList</code>的<code>IteratorDestructuringAssignmentEvaluation</code>结果</li>
<li>如果<code>status</code>是非常规完结，则
<ol>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，返回<code>IteratorClose(iterator, status)</code></li>
<li>返回<code>Completion(status)</code></li>
</ol>
</li>
<li>如果<code>Elision</code>存在，则
<ol>
<li>令<code>status</code>为使用参数<code>iteratorRecord</code>执行<code>Elision</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
<li>如果<code>status</code>是非常规完结，则
<ol>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，返回<code>IteratorClose(iterator, status)</code></li>
<li>返回<code>Completion(status)</code></li>
</ol>
</li>
</ol>
</li>
<li>如果<code>AssignmentRestElement</code>存在，则令<code>status</code>为使用参数<code>iteratorRecord</code>执行<code>AssignmentRestElement</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，返回<code>IteratorClose(iterator, status)</code></li>
<li>返回<code>Completion(status)</code></li>
</ol>
<h4 id="121453-运行时语义iteratordestructuringassignmentevaluation"><a class="markdownIt-Anchor" href="#121453-运行时语义iteratordestructuringassignmentevaluation"></a> 12.14.5.3 运行时语义:IteratorDestructuringAssignmentEvaluation</h4>
<p>接受参数<code>iteratorRecord</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentElementList : AssignmentElisionElement</span><br></pre></td></tr></table></figure>
<ol>
<li>返回使用参数<code>iteratorRecord</code>执行<code>AssignmentElisionElement</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentElementList : AssignmentElementList , AssignmentElisionElement</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>status</code>为使用参数<code>iteratorRecord</code>执行<code>AssignmentElementList</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回使用参数<code>iteratorRecord</code>执行<code>AssignmentElisionElement</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentElisionElement : AssignmentElement</span><br></pre></td></tr></table></figure>
<ol>
<li>返回使用参数<code>iteratorRecord</code>执行<code>AssignmentElement</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentElisionElement : Elision AssignmentElement</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>status</code>为使用参数<code>iteratorRecord</code>执行<code>Elision</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>返回使用参数<code>iteratorRecord</code>执行<code>AssignmentElement</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elision : ,</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，则
<ol>
<li>令<code>next</code>为<code>IteratorStep(iteratorRecord.[[iterator]])</code></li>
<li>如果<code>next</code>是非常规完结，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li><code>ReturnIfAbrupt(next)</code></li>
<li>如果<code>next</code>为<code>false</code>，将<code>iteratorRecord.[[done]]</code>设为<code>true</code>.</li>
</ol>
</li>
<li>返回<code>NormalCompletion(empty)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elision : Elision ,</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>status</code>为使用参数<code>iteratorRecord</code>执行<code>Elision</code>的<code>IteratorDestructuringAssignmentEvaluation</code>的结果</li>
<li><code>ReturnIfAbrupt(status)</code></li>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，则
<ol>
<li>令<code>next</code>为<code>IteratorStep(iteratorRecord.[[iterator]])</code></li>
<li>如果<code>next</code>是非常规完结，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li><code>ReturnIfAbrupt(next)</code></li>
<li>如果<code>next</code>为<code>false</code>，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
</ol>
</li>
<li>返回<code>NormalCompletion(empty)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentElement[Yield] : DestructuringAssignmentTarget Initializeropt</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>DestructuringAssignmentTarget</code>既不是<code>ObjectLiteral</code>也不是<code>ArrayLiteral</code>，则
<ol>
<li>令<code>lref</code>为计算<code>DestructuringAssignmentTarget</code>的结果</li>
<li><code>ReturnIfAbrupt(lref)</code></li>
</ol>
</li>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>false</code>，则
<ol>
<li>令<code>next</code>为<code>IteratorStep(iteratorRecord.[[iterator]])</code></li>
<li>如果<code>next</code>是非常规完结，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li><code>ReturnIfAbrupt(next)</code></li>
<li>如果<code>next</code>为<code>false</code>，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li>否则：
<ol>
<li>令<code>value</code>为<code>IteratorValue(next)</code></li>
<li>如果<code>value</code>是非常规完结，则将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li><code>ReturnIfAbrupt(value)</code></li>
</ol>
</li>
</ol>
</li>
<li>如果<code>iteratorRecord.[[done]]</code>为<code>true</code>，令<code>value</code>为<code>undefined</code></li>
<li>如果<code>Initializer</code>存在，且<code>value</code>为<code>undefined</code>，则
<ol>
<li>令<code>defaultValue</code>为执行<code>Initializer</code>的结果</li>
<li>令<code>v</code>为<code>GetValue(defaultValue)</code></li>
<li><code>ReturnIfAbrupt(v)</code></li>
</ol>
</li>
<li>否则，令<code>v</code>为<code>value</code></li>
<li>如果<code>DestructuringAssignmentTarget</code>是<code>ObjectLiteral</code>或<code>AssignmentPattern[Yield]</code>（取决于<code>AssignmentElement</code>是否具有<code>Yield</code>参数）作为目标符号<code>ArrayLiteral</code>，则
<ol>
<li>令<code>nestedAssignmentPattern</code>为使用<code>AssignmentPattern</code>或<code>AssignmentPattern[Yield]</code>解析<code>DestructuringAssignmentTarget</code>对应源文本</li>
<li>返回使用参数<code>v</code>执行<code>nestedAssignmentPattern</code>的<code>DestructuringAssignmentEvaluation</code>的结果</li>
</ol>
</li>
<li>如果<code>Initializer</code>存在，且其值<code>value</code>为<code>undefined</code>，并且<code>IsAnonymousFunctionDefinition(Initializer)</code>和<code>DestructuringAssignmentTarget</code>的<code>IsIdentifierRef</code>都为<code>true</code>
<ol>
<li>令<code>hasNameProperty</code>为<code>HasOwnProperty(v, &quot;name&quot;)</code></li>
<li><code>ReturnIfAbrupt(hasNameProperty)</code></li>
<li>如果<code>hasNameProperty</code>为<code>false</code>，执行<code>SetFunctionName(v, GetReferencedName(lref))</code></li>
</ol>
</li>
<li>返回<code>PutValue(lref, v)</code></li>
</ol>
<p>注：在访问迭代器或计算初始化器之前，通过计算不是析构模式的<code>DestructuringAssignmentTarget</code>来维持从左到右的计算顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentRestElement[Yield] : ... DestructuringAssignmentTarget</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>DestructuringAssignmentTarget</code>既不是<code>ObjectLiteral</code>也不是<code>ArrayLiteral</code>，则
<ol>
<li>令<code>lref</code>为计算<code>DestructuringAssignmentTarget</code>的结果</li>
<li><code>ReturnIfAbrupt(lref)</code></li>
</ol>
</li>
<li>令<code>A</code>为<code>ArrayCreate(0)</code></li>
<li>令<code>n=0</code></li>
<li>只要<code>iteratorRecord.[[done]]</code>为<code>false</code>就重复：
<ol>
<li>令<code>next</code>为<code>IteratorStep(iteratorRecord.[[iterator]])</code></li>
<li>如果<code>next</code>是非常规完结，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li><code>ReturnIfAbrupt(next)</code></li>
<li>如果<code>next</code>为<code>false</code>，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li>否则：
<ol>
<li>令<code>nextValue</code>为<code>IteratorValue(next)</code></li>
<li>如果<code>nextValue</code>是非常规完结，将<code>iteratorRecord.[[done]]</code>设为<code>true</code></li>
<li><code>ReturnIfAbrupt(nextValue)</code></li>
<li>令<code>status</code>为<code>CreateDataProperty(A, ToString(n), nextValue)</code></li>
<li>断言：<code>status</code>为<code>true</code></li>
<li>将<code>n</code>递增<code>1</code></li>
</ol>
</li>
</ol>
</li>
<li>如果<code>DestructuringAssignmentTarget</code>既不是<code>ObjectLiteral</code>也不是<code>ArrayLiteral</code>，则返回<code>PutValue(lref, A)</code></li>
<li>令<code>nestedAssignmentPattern</code>为使用<code>AssignmentPattern</code>或<code>AssignmentPattern[Yield]</code>（取决于<code>AssignmentElement</code>是否具有<code>Yield</code>参数）作为目标符号解析<code>DestructuringAssignmentTarget</code>对应的源文本</li>
<li>返回使用参数<code>A</code>执行<code>nestedAssignmentPattern</code>的<code>DestructuringAssignmentEvaluation</code></li>
</ol>
<h4 id="121454-运行时语义keyeddestructuringassignmentevaluation"><a class="markdownIt-Anchor" href="#121454-运行时语义keyeddestructuringassignmentevaluation"></a> 12.14.5.4 运行时语义:KeyedDestructuringAssignmentEvaluation</h4>
<p>接受参数<code>value</code>和<code>propertyName</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignmentElement[Yield] : DestructuringAssignmentTarget Initializer&#123;opt&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>DestructuringAssignmentTarget</code>既不是<code>ObjectLiteral</code>也不是<code>ArrayLiteral</code>，则
<ol>
<li>令<code>lref</code>为计算<code>DestructuringAssignmentTarget</code>的结果</li>
<li><code>ReturnIfAbrupt(lref)</code></li>
</ol>
</li>
<li>令<code>v</code>为<code>GetV(value, propertyName)</code></li>
<li><code>ReturnIfAbrupt(v)</code></li>
<li>如果<code>Initializer</code>存在，且<code>v</code>为<code>undefined</code>，则
<ol>
<li>令<code>defaultValue</code>为计算<code>Initializer</code>的结果</li>
<li>令<code>rhsValue</code>为<code>GetValue(defaultValue)</code></li>
<li><code>ReturnIfAbrupt(rhsValue)</code></li>
</ol>
</li>
<li>否则，令<code>rhsValue</code>为<code>v</code></li>
<li>如果<code>DestructuringAssignmentTarget</code>是<code>ObjectLiteral</code>或<code>ArrayLiteral</code>，则
<ol>
<li>令<code>assignmentPattern</code>为使用<code>AssignmentPattern</code>或<code>AssignmentPattern[Yield]</code>（取决于此<code>AssignmentElement</code>是否具有<code>Yield</code>参数）作为目标符号解析<code>DestructuringAssignmentTarget</code>对应的源文本。</li>
<li>返回使用<code>rhsValue</code>作为参数执行<code>assignmentPattern</code>的<code>DestructuringAssignmentEvaluation</code>的结果</li>
</ol>
</li>
<li>如果存在<code>Initializer</code>且<code>v</code>为<code>undefined</code>且<code>IsAnonymousFunctionDefinition(Initializer)</code>和<code>DestructuringAssignmentTarget</code>的<code>IsIdentifierRef</code>都为<code>true</code>，则
<ol>
<li>令<code>hasNameProperty</code>为<code>HasOwnProperty(rhsValue, &quot;name&quot;)</code></li>
<li><code>ReturnIfAbrupt(hasNameProperty)</code></li>
<li>如果<code>hasNameProperty</code>为<code>false</code>，执行<code>SetFunctionName(rhsValue, GetReferencedName(lref))</code></li>
</ol>
</li>
<li>返回<code>PutValue(lref, rhsValue)</code></li>
</ol>
<h2 id="1215-逗号运算符"><a class="markdownIt-Anchor" href="#1215-逗号运算符"></a> 12.15 逗号运算符</h2>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expression[In, Yield] :</span><br><span class="line">	AssignmentExpression[?In, ?Yield]</span><br><span class="line">	Expression[?In, ?Yield] , AssignmentExpression[?In, ?Yield]</span><br></pre></td></tr></table></figure>
<h3 id="12153-运行时语义计算"><a class="markdownIt-Anchor" href="#12153-运行时语义计算"></a> 12.15.3 运行时语义:计算</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression : Expression , AssignmentExpression</span><br></pre></td></tr></table></figure>
<ol>
<li>令<code>lref</code>为计算<code>Expression</code>的结果</li>
<li><code>ReturnIfAbrupt(GetValue(lref))</code></li>
<li>令<code>rref</code>为计算<code>AssignmentExpression</code>的结果</li>
<li>返回<code>GetValue(rref)</code></li>
</ol>
<p>注：即使不使用GetValue，也必须调用它，因为它可能会有明显的副作用。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/ES规范/12 表达式.html">https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/ES规范/12 表达式.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/11%20%E8%AF%8D%E6%B3%95.html"><i class="fa fa-chevron-left">  </i><span>11 词法</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/ES%E8%A7%84%E8%8C%83/13%20%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E.html"><span>13 语句和声明</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>