<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript高级程序设计"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>JavaScript高级程序设计 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text"> 介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">2.</span> <span class="toc-text"> 历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text"> 标识符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">4.</span> <span class="toc-text"> 注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text"> 严格模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text"> 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E5%A3%B0%E6%98%8E"><span class="toc-number">6.1.</span> <span class="toc-text"> var声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E5%92%8Cconst%E5%A3%B0%E6%98%8E"><span class="toc-number">6.2.</span> <span class="toc-text"> let和const声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%A3%B0%E6%98%8E"><span class="toc-number">6.3.</span> <span class="toc-text"> 全局声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.4.</span> <span class="toc-text"> 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83"><span class="toc-number">7.</span> <span class="toc-text"> 执行上下文与词法环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text"> 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">8.1.</span> <span class="toc-text"> Undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">8.2.</span> <span class="toc-text"> Null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boolean"><span class="toc-number">8.3.</span> <span class="toc-text"> Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#number"><span class="toc-number">8.4.</span> <span class="toc-text"> Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">8.5.</span> <span class="toc-text"> String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">8.5.1.</span> <span class="toc-text"> 字符串字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">8.5.2.</span> <span class="toc-text"> 模板字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#symbol"><span class="toc-number">8.6.</span> <span class="toc-text"> Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E5%90%8Dsymbol"><span class="toc-number">8.6.1.</span> <span class="toc-text"> 知名Symbol</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">8.7.</span> <span class="toc-text"> Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">8.7.1.</span> <span class="toc-text"> 属性的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.7.2.</span> <span class="toc-text"> 创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE"><span class="toc-number">8.7.3.</span> <span class="toc-text"> 属性访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%B1%9E%E6%80%A7%E7%89%B9%E6%80%A7"><span class="toc-number">8.7.4.</span> <span class="toc-text"> 改变属性特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.8.</span> <span class="toc-text"> 包装类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text"> 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">9.1.</span> <span class="toc-text"> 优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.</span> <span class="toc-text"> 抽象操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typev"><span class="toc-number">9.2.1.</span> <span class="toc-text"> Type(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toprimitivev-hint-default"><span class="toc-number">9.2.2.</span> <span class="toc-text"> ToPrimitive(v, hint &#x3D; ‘default’)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tostringv"><span class="toc-number">9.2.3.</span> <span class="toc-text"> ToString(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tonumberv"><span class="toc-number">9.2.4.</span> <span class="toc-text"> ToNumber(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toint32v"><span class="toc-number">9.2.5.</span> <span class="toc-text"> ToInt32(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tobooleanv"><span class="toc-number">9.2.6.</span> <span class="toc-text"> ToBoolean(v)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.3.</span> <span class="toc-text"> 一元运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">9.3.1.</span> <span class="toc-text"> typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete"><span class="toc-number">9.3.2.</span> <span class="toc-text"> delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void"><span class="toc-number">9.3.3.</span> <span class="toc-text"> void</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E"><span class="toc-number">9.3.4.</span> <span class="toc-text"> 递增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%87%8F"><span class="toc-number">9.3.5.</span> <span class="toc-text"> 递减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%8A%A0"><span class="toc-number">9.3.6.</span> <span class="toc-text"> 一元加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%8F"><span class="toc-number">9.3.7.</span> <span class="toc-text"> 一元减</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.4.</span> <span class="toc-text"> 位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D"><span class="toc-number">9.4.1.</span> <span class="toc-text"> 按位取反</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="toc-number">9.4.2.</span> <span class="toc-text"> 按位与</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96"><span class="toc-number">9.4.3.</span> <span class="toc-text"> 按位或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="toc-number">9.4.4.</span> <span class="toc-text"> 按位异或</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.5.</span> <span class="toc-text"> 移位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB"><span class="toc-number">9.5.1.</span> <span class="toc-text"> 左移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="toc-number">9.5.2.</span> <span class="toc-text"> 算术右移&#x2F;有符号右移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="toc-number">9.5.3.</span> <span class="toc-text"> 逻辑右移&#x2F;无符号右移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.6.</span> <span class="toc-text"> 逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="toc-number">9.6.1.</span> <span class="toc-text"> 逻辑非</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E"><span class="toc-number">9.6.2.</span> <span class="toc-text"> 逻辑与</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%88%96"><span class="toc-number">9.6.3.</span> <span class="toc-text"> 逻辑或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6"><span class="toc-number">9.6.4.</span> <span class="toc-text"> 空值合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E6%80%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.7.</span> <span class="toc-text"> 乘性运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95"><span class="toc-number">9.7.1.</span> <span class="toc-text"> 乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95"><span class="toc-number">9.7.2.</span> <span class="toc-text"> 除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E4%BD%99"><span class="toc-number">9.7.3.</span> <span class="toc-text"> 取余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0"><span class="toc-number">9.7.4.</span> <span class="toc-text"> 指数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%80%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.8.</span> <span class="toc-text"> 加性运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95"><span class="toc-number">9.8.1.</span> <span class="toc-text"> 加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%B3%95"><span class="toc-number">9.8.2.</span> <span class="toc-text"> 减法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.9.</span> <span class="toc-text"> 关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E4%BA%8E"><span class="toc-number">9.9.1.</span> <span class="toc-text"> 小于(&lt;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8E"><span class="toc-number">9.9.2.</span> <span class="toc-text"> 大于(&gt;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E"><span class="toc-number">9.9.3.</span> <span class="toc-text"> 小于等于(&lt;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E"><span class="toc-number">9.9.4.</span> <span class="toc-text"> 大于等于(&gt;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">9.9.5.</span> <span class="toc-text"> instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in"><span class="toc-number">9.9.6.</span> <span class="toc-text"> in</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.10.</span> <span class="toc-text"> 相等运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89"><span class="toc-number">9.10.1.</span> <span class="toc-text"> 相等(&#x3D;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89"><span class="toc-number">9.10.2.</span> <span class="toc-text"> 不等(!&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89"><span class="toc-number">9.10.3.</span> <span class="toc-text"> 严格相等(&#x3D;&#x3D;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E4%B8%8D%E7%AD%89"><span class="toc-number">9.10.4.</span> <span class="toc-text"> 严格不等(!&#x3D;&#x3D;)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.11.</span> <span class="toc-text"> 条件运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.12.</span> <span class="toc-text"> 赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">9.12.1.</span> <span class="toc-text"> 解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">9.12.1.1.</span> <span class="toc-text"> 对象解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">9.12.1.2.</span> <span class="toc-text"> 数组解构赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.13.</span> <span class="toc-text"> 逗号运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.14.</span> <span class="toc-text"> new运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.15.</span> <span class="toc-text"> 可选链运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.</span> <span class="toc-text"> 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.1.</span> <span class="toc-text"> 块语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.2.</span> <span class="toc-text"> if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.3.</span> <span class="toc-text"> do-while语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.4.</span> <span class="toc-text"> while语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.5.</span> <span class="toc-text"> for语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.6.</span> <span class="toc-text"> for-in语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-of%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.7.</span> <span class="toc-text"> for-of语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.8.</span> <span class="toc-text"> with语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.9.</span> <span class="toc-text"> switch语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.10.</span> <span class="toc-text"> 标签语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.11.</span> <span class="toc-text"> break和continue语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.12.</span> <span class="toc-text"> try语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.</span> <span class="toc-text"> 函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">11.1.1.</span> <span class="toc-text"> 函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text"> 函数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.3.</span> <span class="toc-text"> 箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.4.</span> <span class="toc-text"> Function构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text"> 函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.1.</span> <span class="toc-text"> 绑定参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">11.3.</span> <span class="toc-text"> 函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%80%BC"><span class="toc-number">11.3.1.</span> <span class="toc-text"> this值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iife"><span class="toc-number">11.3.2.</span> <span class="toc-text"> IIFE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">11.4.</span> <span class="toc-text"> 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">11.5.</span> <span class="toc-text"> 尾调用优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.6.</span> <span class="toc-text"> 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">11.7.</span> <span class="toc-text"> 生成器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text"> 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.1.</span> <span class="toc-text"> 工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.2.</span> <span class="toc-text"> 构造函数模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.3.</span> <span class="toc-text"> 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">12.3.1.</span> <span class="toc-text"> 继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.4.</span> <span class="toc-text"> 类模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">12.4.1.</span> <span class="toc-text"> 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%BB%A7%E6%89%BF"><span class="toc-number">12.4.2.</span> <span class="toc-text"> 多层继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">12.5.</span> <span class="toc-text"> 私有变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">12.5.1.</span> <span class="toc-text"> 实例私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">12.5.2.</span> <span class="toc-text"> 静态私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.5.3.</span> <span class="toc-text"> 模块模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text"> 异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text"> 回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">13.2.</span> <span class="toc-text"> Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%93%8D%E4%BD%9C-2"><span class="toc-number">13.2.1.</span> <span class="toc-text"> 抽象操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BApromise"><span class="toc-number">13.2.2.</span> <span class="toc-text"> 创建Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">13.2.3.</span> <span class="toc-text"> 添加处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">13.2.4.</span> <span class="toc-text"> 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async%E5%92%8Cawait"><span class="toc-number">13.3.</span> <span class="toc-text"> async和await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">13.3.1.</span> <span class="toc-text"> 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">13.3.2.</span> <span class="toc-text"> 使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">14.</span> <span class="toc-text"> 代理和反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">15.</span> <span class="toc-text"> 数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8"><span class="toc-number">16.</span> <span class="toc-text"> 备注</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text"> 常用库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stringraw-template-substitutions"><span class="toc-number">17.1.</span> <span class="toc-text"> String.raw( template , …substitutions )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objectprototypeisprototypeof-v"><span class="toc-number">17.2.</span> <span class="toc-text"> Object.prototype.isPrototypeOf ( V )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objectprototypepropertyisenumerable-v"><span class="toc-number">17.3.</span> <span class="toc-text"> Object.prototype.propertyIsEnumerable ( V )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%94%AE"><span class="toc-number">17.4.</span> <span class="toc-text"> 获取对象属性键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in%E8%AF%AD%E5%8F%A5-2"><span class="toc-number">17.4.1.</span> <span class="toc-text"> for-in语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectgetownpropertynamesobject"><span class="toc-number">17.4.2.</span> <span class="toc-text"> Object.getOwnPropertyNames(object)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectgetownpropertysymbolsobject"><span class="toc-number">17.4.3.</span> <span class="toc-text"> Object.getOwnPropertySymbols(object)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectgetownpropertydescriptorsobject"><span class="toc-number">17.4.4.</span> <span class="toc-text"> Object.getOwnPropertyDescriptors(object)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reflectownkeysobject"><span class="toc-number">17.4.5.</span> <span class="toc-text"> Reflect.ownKeys(object)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectkeysobject"><span class="toc-number">17.4.6.</span> <span class="toc-text"> Object.keys(object)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectentriesobject"><span class="toc-number">17.4.7.</span> <span class="toc-text"> Object.entries(object)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">17.5.</span> <span class="toc-text"> 获取对象属性值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objectvaluesobject"><span class="toc-number">17.5.1.</span> <span class="toc-text"> Object.values(object)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">17.6.</span> <span class="toc-text"> 获取对象属性的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objectgetownpropertydescriptorobject-propname"><span class="toc-number">17.6.1.</span> <span class="toc-text"> Object.getOwnPropertyDescriptor(object, propName)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectgetownpropertydescriptorsobject-2"><span class="toc-number">17.6.2.</span> <span class="toc-text"> Object.getOwnPropertyDescriptors(object)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">17.7.</span> <span class="toc-text"> 获取对象原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B0%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">17.8.</span> <span class="toc-text"> 设置新的原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.9.</span> <span class="toc-text"> 基于原型创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">17.10.</span> <span class="toc-text"> 检查是否存在属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.11.</span> <span class="toc-text"> 合并对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objectassign-target-sources"><span class="toc-number">17.11.1.</span> <span class="toc-text"> Object.assign ( target, …sources )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%AF%94%E8%BE%83"><span class="toc-number">17.12.</span> <span class="toc-text"> 关系比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objectis"><span class="toc-number">17.12.1.</span> <span class="toc-text"> Object.is(value1, value2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97"><span class="toc-number">17.13.</span> <span class="toc-text"> 字符串转数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#number-v"><span class="toc-number">17.13.1.</span> <span class="toc-text"> Number ([v])</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parseint-string-radix"><span class="toc-number">17.13.2.</span> <span class="toc-text"> parseInt (string, radix)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parsefloat-string"><span class="toc-number">17.13.3.</span> <span class="toc-text"> parseFloat (string)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">17.14.</span> <span class="toc-text"> 转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tostring"><span class="toc-number">17.14.1.</span> <span class="toc-text"> toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-v"><span class="toc-number">17.14.2.</span> <span class="toc-text"> String ( [v] )</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">18.</span> <span class="toc-text"> 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E7%90%86"><span class="toc-number">18.1.</span> <span class="toc-text"> 标记清理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">18.2.</span> <span class="toc-text"> 引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD"><span class="toc-number">18.3.</span> <span class="toc-text"> 优化性能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">19.</span> <span class="toc-text"> 模块</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">173</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">JavaScript高级程序设计</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/">JavaScript语言</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1>
<p>完整的JavaScript实现包括三部分：</p>
<ol>
<li>核心（ECMAScript）：由ECMA-262定义并提供核心功能</li>
<li>文档对象模型（DOM）：提供与网页内容交互的方法和接口</li>
<li>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口</li>
</ol>
<span id="more"></span>
<p>ECMAScript是ECMA-262标准定义的语言，ECMA-262将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。<br />
Web浏览器只是ECMAScript实现的宿主环境之一，宿主环境提供ECMAScript的基准实现和环境自身交互必需的扩展，扩展（比如DOM）使用ECMAScript核心类型和语法，提供特定于环境的额外功能。<br />
其他宿主环境还有诸如Flash（实现为ActionScript）、服务器端（实现为Node.js）</p>
<p>ECMA-262定义了：</p>
<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>全局对象</li>
</ul>
<h1 id="历史"><a class="markdownIt-Anchor" href="#历史"></a> 历史</h1>
<p>目前最新的ECMA标准定义了 ECMAScript 2020 语言，它是ECMAScript 语言规范的第11版。<br />
ECMAScript语言规范始于1996年11月。</p>
<ol>
<li>1997年6月发布了ECMA标准的第一版。</li>
<li>1998年6月发布了ECMA标准的第二版，它和第一版几乎没有区别，只是为了与国际标准组织保持一致。</li>
<li>1999年12月发布了ECMA标准的第三版，引入了强大的正则表达式，更好的字符串处理，新的控制语句，try-catch异常处理，更严格的错误定义，数字输出的格式化以及其他小的更改。从这个版本开始，它已经成为了几乎所有浏览器都支持的编程语言，并得到了广泛的采用。</li>
<li>ECMA标准没有发布过第四版，因为这个版本非常激进，很多地方不兼容第三版导致了各种争议，同时缺乏浏览器厂商的支持，最终被放弃。但其中一些改动已合并到了第六版。</li>
<li>2009年12月发布了ECMA标准的第五版，增加了访问器属性，对象的反射式创建和检查，对属性特性的编程控制，额外的数组操作函数，对JSON对象编码格式的支持，用于加强错误检查和程序安全性的严格模式。2011年6月发布了5.1版本，它只对第五版做了很小的修正。</li>
<li>2015年6月发布了ECMA标准的第六版，第六版实际上是15年努力的结晶。新增了模块、类声明、词法块级作用域、迭代器、生成器、用于异步编程的Promise、解构模式和尾调用。扩展了内置库以支持其他数据抽象，包括字典、集合、二进制数组，以及对字符串和正则表达式中Unicode字符的额外支持。内置类型也可以通过派生类进行扩展。</li>
<li>2016年6月发布了ECMA标准的第七版，新增了幂运算符，以及新的数组方法<code>Array.prototype.includes</code></li>
<li>2017年6月发布了ECMA标准的第八版，引入了异步函数、共享内存和原子。还新增了Object静态方法，包括<code>Object.values</code>、<code>Object.entries</code>、<code>Object.getOwnPropertyDescriptors</code>。</li>
<li>2018年6月发布了ECMA标准的第九版，引入了异步迭代器。为正则表达式添加了新功能：<code>dotAll</code>标志、命名捕获组、Unicode属性转义、向后断言。还添加了对象的剩余和展开属性运算。</li>
<li>2019年6月发布了ECMA标准的第十版，添加了数组内置方法<code>Array.prototype.flat</code>和<code>Array.prototype.flatMap</code>，对象静态方法<code>Object.fromEntries</code>、字符串内置方法<code>String.prototype.trimStart</code>和<code>String.prototype.trimEnd</code>。更新了可选的catch绑定参数语法，允许字符串字面值中的行分隔符(U+2028)与段分隔符(U+2029)与JSON对齐。还要求数组排序<code>Array.prototype.sort</code>是稳定排序、<code>JSON.stringify</code>不管输入是什么始终返回格式正确的UTF-8。明确<code>Function.prototype.toString</code>要么返回源文本，要么返回标准占位符。</li>
<li>2020年6月发布了ECMA标准的第11版，引入了字符串的<code>String.prototype.matchAll</code>方法。异步引入模块的<code>import()</code>语法。精确表示整数的新数组原始类型<code>BigInt</code>。为Promise添加了<code>Promise.allSettled</code>方法。引入了<code>globalThis</code>全局变量。令<code>export * as ns from 'module'</code>为模块专用语法。增加了<code>for-in</code>枚举属性的规范化。模块中可用<code>host-populated</code>对象。添加了新语法以处理<code>null</code>和<code>undefined</code>：空值合并(nullish coalescing)，值选择(value selection)运算符，以及可选链。</li>
</ol>
<h1 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h1>
<p>标识符，就是变量、函数、属性或函数参数的名称。<br />
ES6将标识符定义为不是保留字(ReservedWord)的标识符名(IdentifierName)。</p>
<p>一般的，标识符名可以由一或多个下列字符组成：</p>
<ol>
<li>第一个字符必须是一个字母、下划线（_）或美元符号（$）；</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>注：标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符，如 À 或汉字（但不推荐使用）。</p>
<p>标识符区分大小写，<code>a</code>与<code>A</code>是两个完全不同的标识符。另外按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<p>保留字是以下标识符名，可以分为关键字、未来保留字、NULL字面值、Boolean字面值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">关键字</span><br><span class="line">	break    do       in         typeof</span><br><span class="line">	case     else     instanceof var</span><br><span class="line">	catch    export   new        void</span><br><span class="line">	class    extends  return     while</span><br><span class="line">	const    finally  super      with</span><br><span class="line">	continue for      switch     yield</span><br><span class="line">	debugger function this       await</span><br><span class="line">	default  if       throw</span><br><span class="line">	delete   import   try</span><br><span class="line">未来保留字</span><br><span class="line">	enum</span><br><span class="line">NULL字面值</span><br><span class="line">	null</span><br><span class="line">Boolean字面值</span><br><span class="line">	true     false</span><br></pre></td></tr></table></figure>
<p>严格模式的保留字还包括下列标识符名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关键字</span><br><span class="line">	let         static</span><br><span class="line">未来保留字</span><br><span class="line">	implements  package  protected</span><br><span class="line">	interface   private  public</span><br></pre></td></tr></table></figure>
<h1 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h1>
<p>ECMAScript采用C语言风格注释：</p>
<ol>
<li>单行注释：一行中<code>//</code>后面的内容被视为注释</li>
<li>多行注释：以<code>/*</code>开头跨越一行或多行直到下一个<code>*/</code>为止的内容被视为注释</li>
</ol>
<h1 id="严格模式"><a class="markdownIt-Anchor" href="#严格模式"></a> 严格模式</h1>
<p>ECMAScript 语言定义了严格模式，严格模式限制了语言的某些功能，排除了 ECMAScript 语言中某些特定的句法和语义特征，还修改了某些功能的详细语义，以便规避那些用户认为容易出错的功能，从而获得更强的错误检查。</p>
<p>严格模式适用于选择的语法源文本单元级别，严格模式只会在这个源文本单元内施加带有局部效果的限制。一个 ECMAScript 程序可由严格模式和非严格模式的源文本单元组成。在这种情况下，严格的模式只适用于严格模式源文本单元内实际执行的代码。</p>
<p>要为源文本单元（例如整个脚本文件，也可能是单个函数）启用严格模式，需要在源文本单元的第一行添加字符串<code>&quot;use strict&quot;</code>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  &#x2F;&#x2F; 严格模式仅适用于此函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1>
<p>变量将一个标识符对应到一个数据，ECMAScript变量是松散类型的，它可以保存任何类型的数据。有3个关键字可以用于声明变量：<code>var</code>、<code>const</code>和<code>let</code>。其中<code>const</code>和<code>let</code>是ES6新增的。</p>
<h2 id="var声明"><a class="markdownIt-Anchor" href="#var声明"></a> var声明</h2>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier;</span><br><span class="line"><span class="keyword">var</span> identifier = AssignmentExpression;</span><br><span class="line"><span class="keyword">var</span> identifier = AssignmentExpression , identifier2;</span><br><span class="line"><span class="keyword">var</span> identifier = AssignmentExpression , identifier2 = AssignmentExpression2;</span><br></pre></td></tr></table></figure>
<p>标识符右侧是用于初始化的值，也可以没有，声明多个变量用逗号隔开。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> name, age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;a&quot;</span>, age;</span><br></pre></td></tr></table></figure>
<p>var变量在包含它们的词法环境被实例化时被创建，并且在创建时初始化为<code>undefined</code>。也就是说写在同一个词法环境最后一行的var变量，在第一行就可以使用，但值为<code>undefined</code>。<br />
当代码执行到var声明的初始化表达式时，变量的值才被赋予声明语句初始化表达式的值。</p>
<p>var变量的作用域是运行中的执行上下文的 <code>VariableEnvironment</code>（由于基本上只有函数调用才会创建新的<code>VariableEnvironment</code>，也可以不那么精确的说成是函数作用域）。<br />
可以多次使用 var 声明相同标识符的变量，但只要它们在同一个 <code>VariableEnvironment</code> 内，最终也只会定义一个变量。如果相同作用域内存在一个通过<code>LexicalDeclaration</code>(let/const)或<code>ClassDeclaration</code>(class)创建的同名绑定，则会抛出语法错误异常。</p>
<h2 id="let和const声明"><a class="markdownIt-Anchor" href="#let和const声明"></a> let和const声明</h2>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identifier;</span><br><span class="line"><span class="keyword">let</span> identifier = AssignmentExpression;</span><br><span class="line"><span class="keyword">let</span> identifier = AssignmentExpression , identifier2;</span><br><span class="line"><span class="keyword">let</span> identifier = AssignmentExpression , identifier2 = AssignmentExpression2;</span><br><span class="line"><span class="keyword">const</span> identifier = AssignmentExpression;</span><br><span class="line"><span class="keyword">const</span> identifier = AssignmentExpression , identifier2 = AssignmentExpression2;</span><br></pre></td></tr></table></figure>
<p>let变量和const变量在包含它们的词法环境被实例化时创建，但在执行到声明的词法绑定部分（等号左侧）之前，不能以任何方式访问（这种状态被人起名叫“暂时性死区”temporal dead zone，但这不是ES规范术语）。<br />
当代码执行到声明的词法绑定部分时，变量的值才被初始化为声明语句初始化表达式的值。对于let声明，如果没有初始化表达式，则变量的值被初始化为<code>undefined</code>；对于const声明，如果没有初始化表达式，则抛出语法错误异常。</p>
<p>let和const变量的作用域是运行中的执行上下文的<code>LexicalEnvironment</code>（不那么精确的说，块作用域）。<br />
如果在相同作用域内存在存在一个通过<code>VariableStatement</code>(var)或<code>FunctionDeclaration</code>(函数)或<code>LexicalDeclaration</code>(let/const)或<code>ClassDeclaration</code>(class)创建的绑定则抛出语法错误异常。因此在同一个作用域不能重复使用let或const声明相同的变量。</p>
<p>另外，const声明的变量，除了初始化语句之外都不允许赋值，因此它是一个不可修改的常量。<br />
当const声明的是一个可变对象时，尽管变量本身不能修改，必须一直绑定该对象，但该对象自己的属性可以修改。如果需要禁止修改对象属性，可以使用<code>Object.freeze()</code>方法</p>
<h2 id="全局声明"><a class="markdownIt-Anchor" href="#全局声明"></a> 全局声明</h2>
<p>标识符的解析规则是在当前词法环境查找，找不到就在外部词法环境查找，沿着词法环境链最终会找到全局环境，全局环境没有外部环境，因此全局环境就是查找的终点。在任何一个作用域内的标识符，如果找不到，最终一定会在全局环境中查找。<br />
全局环境包含一个关联的全局对象，全局对象在全局环境中的标识符名为<code>this</code>或者<code>globalThis</code>，在浏览器中也叫<code>window</code>。在全局环境中仍没有找到的标识符，还会在全局对象的属性中查找。<br />
由于上述规则，在全局环境中声明的变量，以及全局对象的属性，都可以称之为“全局声明”。</p>
<ul>
<li>在全局环境中的var声明，会出现在全局对象的属性中，两种方式操作的是同一个变量。</li>
<li>在全局环境中的let/const声明，不会出现在全局对象的属性中，即使为全局对象添加一个同名属性，二者也不是同一个变量。</li>
<li>在任何作用域为全局对象添加属性，也创建了“全局声明”。</li>
<li>非严格模式下，在任何作用域内，既不使用let/const，也不使用var，单纯使用赋值运算符也能进行“全局声明”，如果赋值运算符左侧的标识符一个无法解析的标识符，那么该赋值会变成为全局对象添加属性，例如<code>unResolve = 999; console.log(window.unResolve);</code></li>
</ul>
<h2 id="最佳实践"><a class="markdownIt-Anchor" href="#最佳实践"></a> 最佳实践</h2>
<p>使用声明的最佳实践是：</p>
<ol>
<li>不使用<code>var</code>，仅使用<code>let</code>和<code>const</code>声明：这有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</li>
<li><code>const</code>优先，其次才是<code>let</code>：使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</li>
</ol>
<h1 id="执行上下文与词法环境"><a class="markdownIt-Anchor" href="#执行上下文与词法环境"></a> 执行上下文与词法环境</h1>
<p>一个执行上下文是与一段代码关联的状态信息，用于追踪它所关联代码的执行进度。<br />
在任何时间点，最多只有一个实际正在执行代码的执行上下文，这称为运行中的执行上下文。<br />
ECMAScript内部使用栈来追踪执行上下文，运行中的执行上下文始终是栈顶元素。每当控制权从与当前运行中的执行上下文关联的可执行代码，转移到与该执行上下文不关联的可执行代码时，都会创建一个新的执行上下文。 新创建的执行上下文被压入栈，并成为运行中的的执行上下文。</p>
<p>词法环境用于定义标识符与特定的变量或函数之间的关联关系（粗略的说，可以理解为词法环境就是人们常说的作用域）。<br />
一个词法环境通常具有外部词法环境，在解析一个标识符时，如果当前词法环境找不到该标识符，就会在外部词法环境中查找。<br />
一个内部词法环境最多只有一个外部词法环境，但一个外部词法环境可能有多个内部词法环境。<br />
全局环境是唯一没有外部词法环境的词法环境，全局环境的外部环境引用为<code>null</code>。全局环境自带一些标识符绑定，并且包含了一个关联的全局对象，该全局对象是全局环境的<code>this</code>绑定的值。在全局环境解析标识符时，如果没有找到，还会在全局对象的属性中查找。</p>
<p>每个执行上下文都包含两个词法环境类型的组件：</p>
<ul>
<li>一个叫<code>LexicalEnvironment</code>（词法环境），用于解析此执行上下文内的代码创建的标识符引用。</li>
<li>另一个叫<code>VariableEnvironment</code>（变量环境），用于保存此执行上下文内的 VariableStatements 语句（即<code>var</code>声明）创建的绑定。</li>
</ul>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<p>ECMAScript有7种数据类型：Undefined、Null、Boolean、String、Symbol、Number、Object。除了Object以外的六种数据类型是原始类型，原始类型是可以直接表示语言实现的最底层数据的类型。</p>
<h2 id="undefined"><a class="markdownIt-Anchor" href="#undefined"></a> Undefined</h2>
<p>Undefined类型有且只有一个值，它的字面值为<code>undefined</code> 。任何没有被赋值的变量值为 undefined 。</p>
<p>一般来说不需要显式设置这个值，字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了区分空对象指针（null）和未初始化变量。</p>
<h2 id="null"><a class="markdownIt-Anchor" href="#null"></a> Null</h2>
<p>Null类型 有且只有一个值，它的字面值为 <code>null</code> 。</p>
<p>从语义上来说，null表示一个空对象指针。如果一个变量将来要用于保存对象，则可以将其初始化为null。之后只需要检查该变量是否为null，就可以知道变量是否在后来被赋予了一个对象的引用。</p>
<h2 id="boolean"><a class="markdownIt-Anchor" href="#boolean"></a> Boolean</h2>
<p>Boolean类型有两个值，它们的字面值为<code>true</code> 和 <code>false</code>。</p>
<h2 id="number"><a class="markdownIt-Anchor" href="#number"></a> Number</h2>
<p>ECMAScript中所有数值都是IEEE 754-2008 双精度浮点数。</p>
<p>合法的字面值如图所示，包括：</p>
<ul>
<li>十进制字面值：整数部分和小数部分可以省略其中之一，后面可以跟以<code>e</code>开头的指数部分，表示之前的数字乘以10的某个次幂</li>
<li>八进制字面值：以数字0和字母o开头</li>
<li>二进制字面值：以数字0和字母b开头</li>
<li>十六进制字面值：以数字0和字母x开头</li>
</ul>
<p><img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210130202731800_9953.png" alt="" width="621" /><br />
根据IEEE 754，当阶码全为1，而frac部分不全为0时，其值表示 NaN(非数字)，这样的NaN总共有<code>2^53-2</code>个，在ECMAScript中，这些NaN相互之间无法区分。<br />
另外，字面值<code>NaN</code>不等于任何值，包括<code>NaN</code>自己。要判断是否是<code>NaN</code>，有两种办法：</p>
<ul>
<li>利用只有NaN不等于自己的性质判断，若<code>v !== v</code>为真，则是NaN。</li>
<li>使用内置函数isNaN()，但此函数会将其他类型转换为数值类型</li>
</ul>
<h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h2>
<p>字符串类型是零个或多个16位Unicode字符有序序列。字符可以直接由代码点表示，也可以由转义序列表示，转义序列由多个代码点组成，它们合起来表示一个字符。</p>
<p>字符串被设计为不可变的，它没有任何方法可以修改其保存的字符序列，所有修改字符串的方法将返回一个和该字符串无关的全新的字符串。</p>
<h3 id="字符串字面值"><a class="markdownIt-Anchor" href="#字符串字面值"></a> 字符串字面值</h3>
<p>创建字符串的一种方法是使用字符串字面值，它的写法是使用单引号<code>'</code>或双引号<code>&quot;</code>将字符序列引起来。<br />
除了用于闭合的引号、U+005C (反斜线<code>\</code>), U+000D (回车), U+2028 (行分隔符), U+2029 (段分隔符)和U+000A (换行)之外，其他所有代码点都可能以其字面形式出现在字符串字面值中，即输入什么就是什么。而上面六个字符如果想让其出现在字符串字面值内，只能用转义序列的形式输入。</p>
<p>直接输入的行结束符（回车、行分隔符、段分隔符、换行）必须在反斜线<code>\</code>后面，但它不是用于在字符串中加入换行符，而是用来将一行书写不下的内容换成两行书写。<code>\</code>和它后面的行结束符并不会加入字符串内。例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc\</span></span><br><span class="line"><span class="string">def&quot;</span></span><br><span class="line"><span class="comment">// 结果是 &quot;abcdef&quot;</span></span><br></pre></td></tr></table></figure>
<p>字符串字面值的文法如下图（注意蓝色文字表示一个整体例如<code>\n</code>是指换行符而非两个符号<code>\</code>和<code>n</code>）。<br />
转义序列以<code>\</code>开头，有4种形式：</p>
<ul>
<li>后跟某个符号，例如<code>\n</code>表示换行，<code>\\</code>表示反斜线</li>
<li>后跟<code>x</code>加2个十六进制数字，表示此代码点对应的UTF-16字符</li>
<li>后跟<code>u</code>加4个十六进制数字，表示此代码点对应的UTF-16字符</li>
<li>后跟<code>u&#123;</code>加任意个十六进制数字，再跟<code>&#125;</code>，表示此代码点对应的UTF-16字符（注意，合法的范围是0-10FFFF，超出范围会抛出异常）<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210202091116735_13691.png" alt="" width="621" /></li>
</ul>
<h3 id="模板字面值"><a class="markdownIt-Anchor" href="#模板字面值"></a> 模板字面值</h3>
<p>ES6提供了一种用于创建字符串的新方法，即使用模板字面值，它的写法是使用反引号<code>`</code>将字符序列引起来。<br />
它的用法基本上和和字符串字面值类似，区别在于：</p>
<ul>
<li>可以直接输入行结束符，行结束符会作为字符串的一部分。也可以通过输入<code>\</code>加行结束符来换行输入，这样的行结束符不会作为字符串的一部分。</li>
<li>可以使用<code>$&#123;表达式&#125;</code>语法进行插值，表达式的计算结果会被ToString内部函数转为字符串，替换<code>$&#123;表达式&#125;</code>。任何表达式都可以放在花括号内，字符串字面值和模板字面值也是表达式，因此可以也可以放在表达式部分。</li>
</ul>
<h2 id="symbol"><a class="markdownIt-Anchor" href="#symbol"></a> Symbol</h2>
<p>Symbol(符号)是ES6新提供的一种类型，主要用于作为对象的属性的标识符（即属性键），以前对象属性的标识符只能使用字符串，现在还可以使用Symbol。<br />
Symbol的特点是它的每个实例都是唯一、不可变的。</p>
<p>声明一个Symbol变量的唯一方法是使用Symbol函数，即<code>Symbol(&quot;mySymbol&quot;)</code>，没有字面值语法。Symbol函数的参数是可选的Symbol描述，这个描述只用来对人起到提示作用，不具有区分Symbol的功能，两个相同描述的Symbol是完全不同的。</p>
<p>对Symbol调用<code>toString()</code>会返回字符串<code>&quot;Symbol(&quot;+desc+&quot;)&quot;</code>，其中<code>desc</code>是Symbol的描述，如果没有保存Symbol变量，那么只能遍历对象的Symbol属性键，检查它们的描述是否匹配，但这只在作为属性键的Symbol的描述各不相同时有效，如果存在两个相同描述的Symbol就没有办法区分了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;description&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Symbol函数不能用作构造函数，因此无法new出一个Symbol。</p>
<p>如果要在不同代码之间共享Symbol，除了作为参数传递变量之外，还可以使用全局符号注册表。<br />
<code>Symbol.for(key)</code>用来从全局符号注册表中获取key（一个字符串）对应的Symbol，如果不存在则会创建一个新的Symbol与key关联，并保存到全局符号注册表中，key也用作新创建的Symbol的描述。<br />
<code>Symbol.keyFor(symbol)</code>用来从全局符号表中获取symbol关联的key，如果找不到则返回<code>undefined</code>。</p>
<h3 id="知名symbol"><a class="markdownIt-Anchor" href="#知名symbol"></a> 知名Symbol</h3>
<p>ECMAScript定义了一批知名Symbol，它们作为全局<code>Symbol</code>对象的属性存在，这些知名Symbol经常用于作为对象某些特别的方法和值的属性键，通过知名Symbol来重新定义这些特别的方法可以实现或重写一些特别的行为，例如<code>for-of</code>语句迭代中会尝试调用对象的<code>Symbol.iterator</code>属性键对应的函数。</p>
<ol>
<li><code>Symbol.hasInstance</code>：该属性键对应的是一个用于检查对象的原型链上是否有某构造函数的方法，由<code>instanceof</code>操作符使用。<code>lval instanceof rval</code>等价于<code>rval[Symbol.hasInstance](lval)</code>。该方法的默认实现定义在<code>Function.prototype</code>上。</li>
<li><code>Symbol.isConcatSpreadable</code>：该属性键对应的是一个布尔值，由<code>Array.prototype.concat</code>函数使用。当在一个对象上设置此属性为<code>true</code>，则<code>concat</code>函数会将其当做一个数组（要求有整数索引，还有<code>length</code>属性），在连接时会连接该对象的整数索引元素，如果为<code>false</code>，则<code>concat</code>函数会直接将此对象连接。注意，此属性只在对象上才有效，如果不是对象，<code>concat</code>永远认为值为<code>false</code>。如果没有定义此属性，则<code>concat</code>会调用<code>isArray</code>来判断该对象是不是一个数组。</li>
<li><code>Symbol.iterator</code>：该属性键对应的是迭代器方法，该方法需要返回对象默认的迭代器，由for-of语句使用。</li>
<li><code>Symbol.match</code>：该属性键对应的是一个方法，由<code>String.prototype.match(regex)</code>函数使用。如果对象<code>regex</code>定义了<code>Symbol.match</code>方法，则<code>str.match(regex)</code>会返回<code>regex[Symbol.match](str)</code>。如果对象没有定义<code>Symbol.match</code>方法，则<code>match</code>函数会通过<code>regex</code>参数构建正则表达式对象，而正则表达式对象原型上有一个默认的<code>Symbol.match</code>实现。</li>
<li><code>Symbol.replace</code>：该属性键对应的是一个方法，由<code>String.prototype.replace(search, replace)</code>函数使用。如果对象<code>search</code>定义了<code>Symbol.replace</code>方法，则<code>str.replace(search, replace)</code>会返回<code>search[Symbol.replace](str, replace)</code>。正则表达式对象原型上有一个默认的<code>Symbol.replace</code>实现。如果没有定义<code>Symbol.match</code>方法，则会将搜索到的第一个<code>search</code>子串替换为<code>replace</code>。</li>
<li><code>Symbol.search</code>：该属性键对应的是一个方法，由<code>String.prototype.search(regex)</code>函数使用。如果对象<code>regex</code>定义了<code>Symbol.search</code>方法，则<code>str.search(regex)</code>会返回<code>regex[Symbol.search](str)</code>。如果对象没有定义<code>Symbol.search</code>方法，则<code>search</code>函数会通过<code>regex</code>参数构建正则表达式对象，而正则表达式对象原型上有一个默认的<code>Symbol.search</code>实现。</li>
<li><code>Symbol.species</code>：该属性键对应一个get访问器属性，该访问器属性返回一个构造函数。内置对象的原型方法通常使用其<code>Symbol.species</code>来创建派生对象（例如Array.concat），内置对象默认实现的<code>Symbol.species</code>会返回<code>this</code>，继承内置对象的子类如果希望不要使用子类的构造函数创建派生对象   ，可以覆盖该访问器属性。</li>
<li><code>Symbol.split</code>：该属性键对应的是一个方法，由<code>String.prototype.split(separator, limit)</code>函数使用。如果对象<code>separator</code>定义了<code>Symbol.split</code>方法，则<code>str.split(separator, limit)</code>会返回<code>separator[Symbol.split](str, limit)</code>。正则表达式对象原型上有一个默认的<code>Symbol.split</code>实现。如果没有定义<code>Symbol.split</code>方法，则会用<code>separator</code>将<code>str</code>切分成一个数组。</li>
<li><code>Symbol.toPrimitive</code>：该属性键对应的是一个方法，由<code>ToPrimitive(input[,PreferredType])</code>抽象操作使用。在将一个对象转换为原始值，即<code>input</code>为对象时会调用<code>input[Symbol.toPrimitive](hint)</code>，它接受一个字符串参数<code>hint</code>，用于提示该对象应转为何种原始值，<code>hint</code>的值只有三种情况：<code>'default'</code>、<code>'string'</code>、<code>'number'</code>。此时<code>input[Symbol.toPrimitive]</code>返回的结果就是<code>ToPrimitive</code>抽象操作的结果。</li>
<li><code>Symbol.toStringTag</code>：该属性键对应的是一个字符串，由<code>Object.prototype.toString()</code>函数使用。如果调用此<code>toString</code>方法的对象<code>O</code>的<code>Symbol.toStringTag</code>属性键是一个字符串，那么返回的结果是<code>[object $&#123;O[Symbol.toStringTag]&#125;]</code>，如果不是字符串，则会自动判断。许多内置对象都定义了<code>Symbol.toStringTag</code>，例如<code>Map</code>、<code>Promise</code>等等。</li>
<li><code>Symbol.asyncIterator</code>：该属性键对应的是异步迭代器方法，它需要返回对象默认的AsyncIterator，由for-await-of语句使用。</li>
<li><code>Symbol.unscopables</code>：该属性键对应的是一个对象，该对象的属性不会出现在关联对象的<code>with</code>环境绑定中。</li>
</ol>
<h2 id="object"><a class="markdownIt-Anchor" href="#object"></a> Object</h2>
<p>对象是属性的集合，属性分为数据属性，以及访问器属性。</p>
<p>数据属性由三部分组成：</p>
<ol>
<li>一个属性键</li>
<li>一个ECMAScript语言类型（Undefined、Null、Boolean、String、Symbol、Number、Object）值</li>
<li>一个Boolean类型的特性(attributes)集合。</li>
</ol>
<p>访问器属性由三部分组成：</p>
<ol>
<li>一个属性键</li>
<li>一个（或两个）访问器函数。访问器函数用于获取或设置与属性关联的ECMAScript语言值。</li>
<li>一个Boolean类型的特性(attributes)集合组成。</li>
</ol>
<p>属性使用属性键来标识，属性键可以是String类型（包括空串）或Symbol类型。属性键用于访问属性及其值。 对属性的访问有两种方法：get和set，分别对应于值检索和赋值。 通过get和set可以访问对象的自有属性以及它继承的属性，一个对象每个自有属性的属性键，必须与其他自有属性的属性键不同。</p>
<h3 id="属性的特性"><a class="markdownIt-Anchor" href="#属性的特性"></a> 属性的特性</h3>
<p>数据属性有四个特性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性名</th>
<th style="text-align:left">值域</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Value]]</td>
<td style="text-align:left">任何 ECMAScript语言类型</td>
<td style="text-align:left">属性值的所在位置，通过属性的get访问来获取该值</td>
</tr>
<tr>
<td style="text-align:left">[[Writable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 false，试图通过 ECMAScript 代码 [[Set]] 去改变该属性的 [[Value]]将会失败。默认为true</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 true，则该属性可被 for-in 枚举出来，否则，该属性不可枚举。默认为true</td>
</tr>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 false，试图删除该属性或改变该属性为访问器属性，或改变它的特性（除了 [[Value]] ，或将[[Writable]]改为false），都会失败。默认为true</td>
</tr>
</tbody>
</table>
<p>访问器属性也有四个特性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性名</th>
<th style="text-align:left">值域</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Get]]</td>
<td style="text-align:left">Object或Undefined</td>
<td style="text-align:left">如果该值为一个 Object 对象，那么它必须是一个函数对象。每次有对属性进行 get 访问时，该函数的内部方法 [[Call]] 会伴随着一个空参数列表被调用，并取出该属性值。默认为undefined</td>
</tr>
<tr>
<td style="text-align:left">[[Set]]</td>
<td style="text-align:left">Object或Undefined</td>
<td style="text-align:left">如果该值为一个 Object 对象，那么它必须是一个函数对象。每次有对属性进行 set 访问时，该函数的内部方法 [[Call]] 会伴随着一个参数列表被调用，这个参数列表包含了指定值作为唯一的参数。属性的内部方法 [[Set]] 可能会对随后的 属性 内部方法 [[Get]] 的调用返回结果产生影响。默认为undefined</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 true，则该属性可被 for-in 枚举出来，否则，该属性不可枚举。默认为true</td>
</tr>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 false，试图删除该属性，改变该属性为数据属性，或改变它的特性，都会失败。默认为true</td>
</tr>
</tbody>
</table>
<h3 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h3>
<p>创建一个对象的常用方法是使用<code>new</code>运算符，或者对象字面值语法。</p>
<ol>
<li>new运算符后跟一个构造函数调用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对象字面值语法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有自有属性的对象</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义一个自有属性</span></span><br><span class="line"><span class="keyword">let</span> o2 = &#123; 属性定义<span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 多个自有属性用逗号分隔，最后的逗号是可选的</span></span><br><span class="line"><span class="keyword">let</span> o3 = &#123; 属性定义<span class="number">1</span>, 属性定义<span class="number">2</span>, &#125;</span><br></pre></td></tr></table></figure>
<p>如果属性键相同，则后面的属性定义将覆盖前面的属性定义。</p>
<p>属性定义有有四种形式：<br />
第一种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; 属性名:表达式 &#125;</span><br><span class="line"><span class="comment">// 属性名又有四种表达形式：</span></span><br><span class="line"><span class="keyword">let</span> o2 = &#123; 标识符名:表达式 &#125; <span class="comment">// 例如 &#123; a: 55 &#125;</span></span><br><span class="line"><span class="keyword">let</span> o3 = &#123; 字符串字面值:表达式 &#125; <span class="comment">// 例如 &#123; &#x27;a&#x27; : 55 &#125;</span></span><br><span class="line"><span class="keyword">let</span> o4 = &#123; 数字字面值:表达式 &#125; <span class="comment">// 例如 &#123; 1 : 55 &#125;</span></span><br><span class="line"><span class="keyword">let</span> o5 = &#123; [表达式]:表达式 &#125; <span class="comment">// 例如 &#123; [a] : 55, [Symbol(&quot;a&quot;)] : 55 &#125;</span></span><br></pre></td></tr></table></figure>
<p>这种形式用冒号<code>:</code>将属性键与属性值分开，属性名作为属性键，表达式的结果作为属性值。<br />
属性名有标识符名、字符串字面值、数字字面值、<code>[表达式]</code>四种形式。前三种形式的属性名会被转换为字符串属性键，最后一种形式会将中括号内表达式的计算结果作为属性键，最终可能被转换为字符串属性键，也可能被转换为Symbol属性键。<br />
只有最后一种形式会进行计算，因此它可以实现动态的属性名。</p>
<p>第二种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; 标识符名 &#125; <span class="comment">// 例如 &#123; name &#125;</span></span><br></pre></td></tr></table></figure>
<p>这种形式实际上是<code>&#123; 标识符名:表达式 &#125;</code>的一种特殊简写，它将一个已存在的标识符名作为字符串属性键，标识符对应的值作为属性值。<code>&#123; name &#125;</code>等价于<code>&#123; name: name &#125;</code></p>
<p>第三种</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; ...表达式 &#125;</span><br></pre></td></tr></table></figure>
<p>将<code>表达式</code>使用<code>ToObject</code>抽象操作转为对象<code>source</code>，对<code>source</code>对象中的每个自有属性键（通过<code>[[OwnPropertyKeys]]</code>得到），在对象字面值<code>target</code>中创建相同属性键的数据属性，其值为使用<code>[[Get]]</code>从<code>source</code>中获取该属性键得到的值。<br />
简而言之，就是将一个对象所有自有属性拷贝到当前的对象字面值，都变成了数据属性。</p>
<p>第四种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; 方法定义 &#125;</span><br><span class="line"><span class="comment">// 方法定义有6种形式：</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123; 属性名(参数)&#123;函数体&#125; &#125; <span class="comment">// 例如 &#123; say()&#123;&#125; &#125;</span></span><br><span class="line"><span class="keyword">let</span> o2 = &#123; get 属性名()&#123;函数体&#125; &#125; <span class="comment">// 例如 &#123; get length()&#123;&#125; &#125;</span></span><br><span class="line"><span class="keyword">let</span> o3 = &#123; set 属性名(参数)&#123;函数体&#125; &#125; <span class="comment">// 例如 &#123; set length(val)&#123;&#125; &#125;</span></span><br><span class="line"><span class="keyword">let</span> o4 = &#123; * 属性名(参数)&#123;生成器函数体&#125; &#125; <span class="comment">// 例如 &#123; * gen()&#123;&#125; &#125;</span></span><br><span class="line"><span class="keyword">let</span> o5 = &#123; <span class="keyword">async</span> 属性名(参数)&#123;异步函数体&#125; &#125; <span class="comment">// 例如 &#123; async f()&#123;&#125; &#125;</span></span><br><span class="line"><span class="keyword">let</span> o6 = &#123; <span class="keyword">async</span> * 属性名(参数)&#123;异步生成器函数体&#125; &#125; <span class="comment">// 例如 &#123; async *g()&#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>这种形式提供了函数表达式之外的定义方法的途径。</p>
<p>只有下面两种形式可用于定义访问器属性，其他形式定义的都是数据属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o2 = &#123; get 属性名()&#123;函数体&#125; &#125; <span class="comment">// 例如 &#123; get length()&#123;&#125; &#125;</span></span><br><span class="line"><span class="keyword">let</span> o3 = &#123; set 属性名(参数)&#123;函数体&#125; &#125; <span class="comment">// 例如 &#123; set length(val)&#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性访问"><a class="markdownIt-Anchor" href="#属性访问"></a> 属性访问</h3>
<p>访问对象的属性有两种语法，点表示法和中括号表示法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;&#39;a&#39; : 1&#125;</span><br><span class="line">let v1 &#x3D; o.a</span><br><span class="line">let v2 &#x3D; o[&#39;a&#39;]</span><br></pre></td></tr></table></figure>
<ul>
<li>点表示法是对象后跟一个点<code>.</code>，再跟一个标识符名，标识符名会被转换为字符串值，然后去访问这个字符串属性键对应的属性。</li>
<li>中括号表示法是对象后跟一对中括号<code>[]</code>，中括号内部是一个表达式，表达式的计算结果会先通过抽象操作<code>ToPrimitive(argument, hint String)</code>得到原始值，如果是原始值类型是Symbol则返回，类型不是Symbol则使用<code>ToString</code>抽象操作转换为字符串。最后得到的结果要么是Symbol属性键，要么是字符串属性键，再去访问该对象的属性键对应的属性。</li>
</ul>
<p>对属性的访问有两种方法：get和set，分别对应于值检索和赋值。<br />
当属性访问表达式用于右值时，会进行get访问来获取值。当用于左值时，会进行set访问来设置值。</p>
<h3 id="改变属性特性"><a class="markdownIt-Anchor" href="#改变属性特性"></a> 改变属性特性</h3>
<p>通过对象字面值，或者属性访问定义的属性，其特性都是默认值，<code>Enumerable</code>、<code>Configurable</code>都为<code>true</code>，对于数据属性，<code>Writable</code>为<code>true</code>，对于访问器属性<code>Set</code>或<code>Get</code>没有给出的那个为<code>undefined</code>。<br />
要想修改属性的特性，或者在定义属性的同时修改特性，需要使用下面两个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, propName, propDescriptor)</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, propsObj)</span><br></pre></td></tr></table></figure>
<p>前者用于定义/修改一个属性及特性，后者用于定义/修改多个属性及特性。它们只能修改自有属性，尝试修改继承属性实际上会变成定义同名的自有属性。<br />
<code>obj</code>是要定义/修改属性的对象。<br />
<code>propName</code>是要定义/修改的属性键。<br />
<code>propDescriptor</code>是表示特性的对象。它的属性键是小写的特姓名，形如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.x &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="built_in">this</span>.x = x &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特性对象也有几个限制：</p>
<ul>
<li><code>get</code>和<code>set</code>必须是函数</li>
<li>如果存在<code>get</code>或<code>set</code>，就不能有<code>value</code>或<code>writable</code>。</li>
</ul>
<p>特性对象中不要求把所有特性都给出。<br />
当定义一个属性时，如果特性对象中特性不完整（不到4个），则<code>value</code>、<code>get</code>和<code>set</code>为<code>undefined</code>。<code>writable</code>、<code>enumerable</code>和<code>configurable</code>为<code>false</code>。这和通过对象字面值，或者属性访问定义的属性的特性默认值不同。<br />
当修改一个属性时，如果特性对象中特性不完整，则缺失的特性维持原值。</p>
<p><code>propsObj</code>对象用于同时表示多个属性及其特性对象，它的属性键是要定义/修改的属性名，属性值则是<code>propDescriptor</code>特性对象。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    value: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="包装类型"><a class="markdownIt-Anchor" href="#包装类型"></a> 包装类型</h2>
<p>除了<code>Null</code>和<code>Undefined</code>以外，其他原始类型具有与之对应的<code>Object</code>类型，例如<code>String</code>类型有对应的<code>String</code>对象类型，称作包装类型。<br />
包装类型的值的行为与原始值一样，但由于包装类型是<code>Object</code>，因此它还额外提供了方便的属性或方法。<br />
可以使用<code>Boolean()</code>、<code>Number()</code>、<code>String()</code>等函数将原始值变为包装类型，使用包装类型的<code>valueOf()</code>方法可以将包装类型转换为原始值。<br />
但更多情况下，原始类型与包装类型的互相转换过程是自动的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码中，在调用方法<code>substring()</code>时，原始值<code>s1</code>被转换为包装类型，而在赋值给<code>s2</code>时，包装类型又被自动转换为原始值，随后包装对象被销毁。这个过程就仿佛包装类型不存在一样。</p>
<p>基于原型模式，在原始类型的包装类型的原型上添加方法，就可以让所有原始值的包装对象调用。例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.addHash = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;-&quot;</span>+<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.addHash();</span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1>
<p>ECMAScript定义了一组用于计算数据值的运算符，这些运算符的适用于所有类型的操作数，但通常会在内部将其转换为一致的类型。<br />
优先级：<br />
<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p>
<h2 id="优先级"><a class="markdownIt-Anchor" href="#优先级"></a> 优先级</h2>
<ol>
<li>
<ul>
<li>圆括号<code>(op)</code></li>
</ul>
</li>
<li>
<ul>
<li>成员访问<code>op1.op2</code>：从左到右结合</li>
<li>需计算的成员访问<code>op1[op2]</code>：从左到右结合</li>
<li>带参数的<code>new(op1)</code></li>
<li>函数调用<code>op1(op2)</code>：从左到右结合</li>
<li>可选链<code>?.</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>不带参数的<code>new op</code>：从右到左结合</li>
</ul>
</li>
<li>
<ul>
<li>后缀递增<code>op++</code></li>
<li>后缀递减<code>op--</code></li>
</ul>
</li>
<li>
<ul>
<li>逻辑非<code>!op</code>：从右到左结合</li>
<li>按位取反<code>~op</code>：从右到左结合</li>
<li>一元加<code>+op</code>：从右到左结合</li>
<li>一元减<code>-op</code>：从右到左结合</li>
<li>前缀递增<code>++op</code>：从右到左结合</li>
<li>前缀递减<code>--op</code>：从右到左结合</li>
<li><code>typeof op</code>：从右到左结合</li>
<li><code>void op</code>：从右到左结合</li>
<li><code>delete op</code>：从右到左结合</li>
<li><code>await op</code>：从右到左结合</li>
</ul>
</li>
<li>
<ul>
<li>幂<code>op1 ** op2</code>：从右到左结合</li>
</ul>
</li>
<li>
<ul>
<li>乘<code>op1 * op2</code>：从左到右结合</li>
<li>除<code>op1 / op2</code>：从左到右结合</li>
<li>取余<code>op1 % op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>加<code>op1 + op2</code>：从左到右结合</li>
<li>减<code>op1 - op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>左移<code>op1 &lt;&lt; op2</code>：从左到右结合</li>
<li>有符号右移<code>op1 &gt;&gt; op2</code>：从左到右结合</li>
<li>无符号右移<code>op1 &gt;&gt;&gt; op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>小于<code>op1 &lt; op2</code>：从左到右结合</li>
<li>小于等于<code>op1 &lt;= op2</code>：从左到右结合</li>
<li>大于<code>op1 &gt; op2</code>：从左到右结合</li>
<li>大于等于<code>op1 &gt;= op2</code>：从左到右结合</li>
<li><code>op1 in op2</code>：从左到右结合</li>
<li><code>op1 instanceof op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>相等<code>op1 == op2</code>：从左到右结合</li>
<li>不等<code>op1 != op2</code>：从左到右结合</li>
<li>严格相等<code>op1 === op2</code>：从左到右结合</li>
<li>严格不等<code>op1 !== op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>按位与<code>op1 &amp; op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>按位异或<code>op1 ^ op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>按位或<code>op1 | op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>逻辑与<code>op1 &amp;&amp; op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>逻辑或<code>op1 || op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>空值合并<code>op1 ?? op2</code>：从左到右结合</li>
</ul>
</li>
<li>
<ul>
<li>条件<code>op1 ? op2 : op3</code>：从右到左结合</li>
</ul>
</li>
<li>
<ul>
<li>赋值<code>op1 = op2</code>与组合赋值<code>op1 @= op2</code>：从右到左结合</li>
</ul>
</li>
<li>
<ul>
<li><code>yield op</code>：从右到左结合</li>
<li><code>yield*</code>：从右到左结合</li>
</ul>
</li>
<li>
<ul>
<li>逗号<code>op1 , op2</code>：从左到右结合</li>
</ul>
</li>
</ol>
<h2 id="抽象操作"><a class="markdownIt-Anchor" href="#抽象操作"></a> 抽象操作</h2>
<p>运算符通常会将操作数转换为特定的类型，这种情况下会用到一系列用于类型转换的抽象操作。</p>
<h3 id="typev"><a class="markdownIt-Anchor" href="#typev"></a> Type(v)</h3>
<p>Type(v)抽象操作返回一个表示基本类型的字符串，和typeof运算符不同，Type抽象操作返回的是7种基本数据类型。Null类型会返回<code>&quot;Null&quot;</code>，而函数对象会返回<code>&quot;Object&quot;</code>。<br />
另外不像<code>typeof</code>，<code>Type(v)</code>不能给<code>v</code>传递一个无法解析的绑定。</p>
<h3 id="toprimitivev-hint-default"><a class="markdownIt-Anchor" href="#toprimitivev-hint-default"></a> ToPrimitive(v, hint = ‘default’)</h3>
<p>ToPrimitive抽象操作将参数<code>v</code>转换为原始值，即对象以外的基本类型。<br />
如果不是对象，该抽象操作直接返回参数<code>v</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToPrimitive</span>(<span class="params">v, hint = <span class="string">&#x27;default&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Type(v) !== <span class="string">&#x27;Object&#x27;</span>) <span class="keyword">return</span> v;</span><br><span class="line">  <span class="keyword">let</span> custoToPrimitive = v[<span class="built_in">Symbol</span>.toPrimitive];</span><br><span class="line">  <span class="keyword">if</span>(custoToPrimitive) &#123;</span><br><span class="line">    <span class="keyword">return</span> v[<span class="built_in">Symbol</span>.toPrimitive](hint)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span>(hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">      hint = <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> v.valueOf == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = v.valueOf();</span><br><span class="line">        <span class="keyword">if</span>(Type(result) == <span class="string">&#x27;Object&#x27;</span>) result = v.toString();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> v.toString == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = v.toString();</span><br><span class="line">        <span class="keyword">if</span>(Type(result) == <span class="string">&#x27;object&#x27;</span>) result = v.valueOf();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tostringv"><a class="markdownIt-Anchor" href="#tostringv"></a> ToString(v)</h3>
<p>ToString抽象操作将参数<code>v</code>转换为一个<code>String</code>类型的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToString</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = Type(v);</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Undefined&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Null&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Boolean&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v ? <span class="string">&#x27;true&#x27;</span> : <span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Number&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> num2str(v);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;String&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Symbol&#x27;</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> ToPrimitive(v, <span class="string">&#x27;string&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数字转换字符串时：</p>
<ul>
<li>如果<code>num</code>是<code>NaN</code>，返回字符串<code>&quot;NaN&quot;</code></li>
<li>如果<code>num</code>是<code>+0</code>或<code>-0</code>，返回字符串 <code>&quot;0&quot;</code>。</li>
<li>如果<code>num &lt; 0</code>，返回连接两个字符串<code>&quot;-&quot;</code>和<code>ToString(-m)</code>得到的字符串。</li>
<li>如果<code>num</code>是<code>+oo</code>，返回字符串<code>&quot;Infinity&quot;</code></li>
</ul>
<h3 id="tonumberv"><a class="markdownIt-Anchor" href="#tonumberv"></a> ToNumber(v)</h3>
<p>ToNumber抽象操作将参数<code>v</code>转换为一个<code>Number</code>类型的数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToNumber</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = Type(v);</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Undefined&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Null&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> +<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Boolean&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Number&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;String&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> str2num(v);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Symbol&#x27;</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> ToPrimitive(v, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串转换数字时，如果能将字符串整个按下图匹配成功，则返回对应的数字。如果不能匹配，则返回<code>NaN</code>。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210224092035348_17024.png" alt="" width="621" /><br />
上述规则和数字字面值的区别在于</p>
<ul>
<li>数字字符串的前后可以有若干的空白字符或行结束符</li>
<li>表示十进制的数字字符串可以有任意数量的前导0</li>
<li>表示十进制的数字字符串可以包含<code>+</code>或<code>-</code>来指示符号</li>
<li>空的，或只包含空白的数字字符串会被转换为<code>+0</code></li>
<li><code>Infinity</code>和<code>-Infinity</code>可被识别为是有效的数字字符串</li>
</ul>
<h3 id="toint32v"><a class="markdownIt-Anchor" href="#toint32v"></a> ToInt32(v)</h3>
<p>ToInt32 抽象操作将其参数<code>v</code>转换为 在<code>-2^31</code>到<code>2^31-1</code>闭区间内的<code>2^32</code> 个整数之一。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToInt32</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = ToNumber(v);</span><br><span class="line">  <span class="keyword">switch</span>(number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">NaN</span>: <span class="comment">// 仅做演示，实际无法这样检查NaN</span></span><br><span class="line">    <span class="keyword">case</span> +<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> +∞:</span><br><span class="line">    <span class="keyword">case</span> -∞:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;+0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向0取整</span></span><br><span class="line">  <span class="keyword">let</span> int = sign(number)×floor(abs(number));</span><br><span class="line">  <span class="comment">// 模2^32得到32位无符号整数</span></span><br><span class="line">  <span class="keyword">let</span> int32bit = int modulo <span class="number">2</span>^<span class="number">32</span>;</span><br><span class="line">  <span class="comment">// 无符号转换为有符号</span></span><br><span class="line">  <span class="keyword">if</span>(int32bit &gt;= <span class="number">2</span>^<span class="number">31</span>) <span class="keyword">return</span> int32bit-<span class="number">2</span>^<span class="number">32</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> int32bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tobooleanv"><a class="markdownIt-Anchor" href="#tobooleanv"></a> ToBoolean(v)</h3>
<p>ToBoolean抽象操作将参数<code>v</code>转换为一个<code>Boolean</code>类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToBoolean</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = Type(v);</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Undefined&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Null&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Boolean&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Number&#x27;</span>:</span><br><span class="line">      <span class="keyword">switch</span>(v) &#123;</span><br><span class="line">        <span class="keyword">case</span> +<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">NaN</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;String&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v.length != <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Symbol&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一元运算符"><a class="markdownIt-Anchor" href="#一元运算符"></a> 一元运算符</h2>
<p>只有一个操作数的运算符称为一元运算符，操作数写在运算符后面，包括：</p>
<h3 id="typeof"><a class="markdownIt-Anchor" href="#typeof"></a> typeof</h3>
<p>对一个值应用typeof得到的结果是一个字符串，字符串的值取决于值的数据类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> a</span><br></pre></td></tr></table></figure>
<p>注意typeof是一个运算符而不是函数，写法<code>typeof (a)</code>实际上是用括号括起了表达式而不是函数调用，类似<code>a + (b)</code>。</p>
<p>大部分类型会返回将类型小写得到的字符串，两个例外是<code>Null</code>类型会返回<code>&quot;object&quot;</code>，而实现了<code>[[Call]]</code>内部方法的<code>Object</code>会返回<code>&quot;function&quot;</code>。<br />
另外，如果操作数是一个无法解析的引用（如未声明的变量），则返回<code>&quot;udefined&quot;</code></p>
<p>综上，typeof运算符的参数类型与返回值不是一一映射：</p>
<ol>
<li>如果返回值是<code>&quot;undefined&quot;</code>，则参数类型可能是<code>Undefined</code>，也可能是无法解析的引用。</li>
<li>如果返回值是<code>&quot;object&quot;</code>，则参数类型可能是<code>Null</code>，也可能是<code>Object</code>。</li>
<li>其他情况返回值是什么，参数类型就是什么。</li>
</ol>
<h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h3>
<p>删除一个对象上的属性，或者一个环境记录上的绑定。若成功删除或已经删除则返回<code>true</code>，否则返回<code>false</code>。<br />
若一个属性的<code>[[Configurable]]</code>特性为<code>false</code>则不能删除。<br />
严格模式下不能删除环境记录上的绑定。</p>
<h3 id="void"><a class="markdownIt-Anchor" href="#void"></a> void</h3>
<p>对操作数求值（如果是操作数是一个引用，可能有副作用），然后返回<code>undefined</code></p>
<h3 id="递增"><a class="markdownIt-Anchor" href="#递增"></a> 递增</h3>
<p>递增运算符使用<code>ToNumber</code>抽象操作将操作数转换为<code>Number</code>，然后使用加法运算符将其与<code>1</code>相加得到新值，再赋值给操作数。<br />
根据操作数位置的不同，可以将递增运算符分为前缀递增运算符和后缀递增运算符，返回的结果也不同。</p>
<p>前缀递增运算符<code>++v</code>返回的是新值，等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> ++(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = ToNumber(a);</span><br><span class="line">  <span class="keyword">let</span> newValue = oldValue + <span class="number">1</span>;</span><br><span class="line">  a = newValue;</span><br><span class="line">  <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后缀递增运算符<code>v++</code>返回的是旧值，等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> ++(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = ToNumber(a);</span><br><span class="line">  <span class="keyword">let</span> newValue = oldValue + <span class="number">1</span>;</span><br><span class="line">  a = newValue;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递减"><a class="markdownIt-Anchor" href="#递减"></a> 递减</h3>
<p>和递增运算符类似。<br />
递减运算符使用<code>ToNumber</code>抽象操作将操作数转换为<code>Number</code>，然后使用减法运算符将其与<code>1</code>相减得到新值，再赋值给操作数。<br />
根据操作数位置的不同，可以将递减运算符分为前缀递减运算符和后缀递减运算符，返回的结果也不同。</p>
<h3 id="一元加"><a class="markdownIt-Anchor" href="#一元加"></a> 一元加</h3>
<p>一元加运算符<code>+op</code>返回<code>ToNumber(op)</code>，即将操作数转换为<code>Number</code>的结果。<br />
基本上等价于<code>Number(op)</code></p>
<h3 id="一元减"><a class="markdownIt-Anchor" href="#一元减"></a> 一元减</h3>
<p>一元减运算符<code>-op</code>返回<code>-ToNumber(op)</code>，即将操作数转换为<code>Number</code>再取负的结果。当<code>ToNumber(op)</code>为<code>NaN</code>时返回<code>NaN</code>而不用取负。</p>
<h2 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h2>
<p>位运算符会使用<code>ToInt32</code>抽象操作将操作数转换为32位有符号整数，然后进行位运算，得到的结果也是32位有符号整数。</p>
<h3 id="按位取反"><a class="markdownIt-Anchor" href="#按位取反"></a> 按位取反</h3>
<p>按位取反运算符<code>~op</code>返回<code>~ToInt32(op)</code>，即将操作数转换为32位有符号整数，再按位取反的结果，结果仍是一个32位有符号整数。</p>
<h3 id="按位与"><a class="markdownIt-Anchor" href="#按位与"></a> 按位与</h3>
<p>按位与运算符<code>op1 &amp; op2</code>返回<code>ToInt32(op1) &amp; ToInt32(op2)</code>，即将两个操作数转换为32位有符号整数，再按位与的结果，结果仍是一个32位有符号整数。</p>
<h3 id="按位或"><a class="markdownIt-Anchor" href="#按位或"></a> 按位或</h3>
<p>按位或运算符<code>op1 | op2</code>返回<code>ToInt32(op1) | ToInt32(op2)</code>，即将两个操作数转换为32位有符号整数，再按位或的结果，结果仍是一个32位有符号整数。</p>
<h3 id="按位异或"><a class="markdownIt-Anchor" href="#按位异或"></a> 按位异或</h3>
<p>按位与运算符<code>op1 ^ op2</code>返回<code>ToInt32(op1) ^ ToInt32(op2)</code>，即将两个操作数转换为32位有符号整数，再按位异或的结果，结果仍是一个32位有符号整数。</p>
<h2 id="移位运算符"><a class="markdownIt-Anchor" href="#移位运算符"></a> 移位运算符</h2>
<p>移位运算符中，左操作数是进行移位的数，右操作数是移位量。<br />
移位量会被转换为32位无符号整数，然后使用<code>module 32</code>运算截取低5位将其限定在0到31之间，等价于使用掩码<code>0x1F</code>按位与。</p>
<h3 id="左移"><a class="markdownIt-Anchor" href="#左移"></a> 左移</h3>
<p>左移运算符<code>op1 &lt;&lt; op2</code>，返回对<code>ToInt32(op1)</code>左移<code>ToUint32(op2) &amp; 0x1F</code>的结果，结果是一个32位有符号整数。</p>
<h3 id="算术右移有符号右移"><a class="markdownIt-Anchor" href="#算术右移有符号右移"></a> 算术右移/有符号右移</h3>
<p>算术右移运算符<code>op1 &gt;&gt; op2</code>返回对<code>ToInt32(op1)</code>算术右移（在最左侧补的值取决于符号位）<code>ToUint32(op2) &amp; 0x1F</code>的结果，结果是一个32位有符号整数。</p>
<h3 id="逻辑右移无符号右移"><a class="markdownIt-Anchor" href="#逻辑右移无符号右移"></a> 逻辑右移/无符号右移</h3>
<p>逻辑右移运算符<code>op1 &gt;&gt;&gt; op2</code>返回对<code>ToUInt32(op1)</code>逻辑右移（在最左侧补<code>0</code>）<code>ToUint32(op2) &amp; 0x1F</code>的结果，结果是一个32位无符号整数。<br />
使用该运算符可以将32位有符号整数转换为32位无符号整数，只需将移位量设为<code>0</code>。</p>
<h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h2>
<p>逻辑非运算符的结果是一个布尔值。<br />
但逻辑与和逻辑或运算符得到的是对左侧或右侧表达式求值的结果，因此结果不一定是<code>Boolean</code>类型。<br />
逻辑与和逻辑或只会将左侧表达式转换为<code>Boolean</code>值，然后根据这个布尔值决定返回左侧还是右侧求值结果。</p>
<h3 id="逻辑非"><a class="markdownIt-Anchor" href="#逻辑非"></a> 逻辑非</h3>
<p>逻辑非运算符<code>!op</code>返回<code>!ToBoolean(op)</code>，即将操作数转换为布尔值，然后取反，结果仍是一个布尔值。</p>
<h3 id="逻辑与"><a class="markdownIt-Anchor" href="#逻辑与"></a> 逻辑与</h3>
<p>逻辑与运算符<code>op1 &amp;&amp; op2</code><br />
首先计算左侧操作数表达式<code>lval = GetValue(op1)</code>，<br />
若<code>ToBoolean(lval)</code>为<code>false</code>，返回<code>lval</code>，<br />
否则返回<code>GetValue(op2)</code></p>
<h3 id="逻辑或"><a class="markdownIt-Anchor" href="#逻辑或"></a> 逻辑或</h3>
<p>逻辑或运算符<code>op1 || op2</code><br />
首先计算左侧操作数表达式<code>lval = GetValue(op1)</code>，<br />
若<code>ToBoolean(lval)</code>为<code>true</code>，返回<code>lval</code>，<br />
否则返回<code>GetValue(op2)</code></p>
<h3 id="空值合并"><a class="markdownIt-Anchor" href="#空值合并"></a> 空值合并</h3>
<p>空值合并运算符<code>op1 ?? op2</code><br />
首先计算左侧操作数表达式<code>lval = GetValue(op1)</code>，<br />
若<code>lval</code>为<code>undefined</code>或<code>null</code>，则返回<code>GetValue(op2)</code><br />
否则返回<code>lval</code></p>
<p>即：若左操作数不是空值则返回它，若是空值则返回右边。</p>
<h2 id="乘性运算符"><a class="markdownIt-Anchor" href="#乘性运算符"></a> 乘性运算符</h2>
<h3 id="乘法"><a class="markdownIt-Anchor" href="#乘法"></a> 乘法</h3>
<p>乘法运算符<code>op1 * op2</code>将操作数转换为<code>Number</code>类型再执行双精度浮点乘法计算，即<code>ToNumber(op1) * ToNumber(op2)</code>。<br />
乘法运算符是可交换的，但由于有限的精度，乘法运算符不总是可结合的。</p>
<ul>
<li>转换后的任何操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>操作数符号相同，结果的符号为正，符号相反，结果的符号为负。</li>
<li>无穷乘0为<code>NaN</code></li>
<li>无穷乘无穷为有符号的无穷</li>
<li>无穷乘有限非零值为有符号的无穷</li>
<li>若结果太大无法表示则为有符号的无穷，若结果太小无法表示则为有符号的0</li>
</ul>
<h3 id="除法"><a class="markdownIt-Anchor" href="#除法"></a> 除法</h3>
<p>除法运算符<code>op1 / op2</code>将操作数转换为<code>Number</code>类型再执行双精度浮点除法计算，即<code>ToNumber(op1) / ToNumber(op2)</code>。<br />
除法运算符采用的是双精度浮点除法，即使操作数均为整数时也采用浮点除法。因此不像C或C++中存在整数除法。</p>
<ul>
<li>转换后的任何操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>操作数符号相同，结果的符号为正，符号相反，结果的符号为负。</li>
<li>无穷除以无穷为<code>NaN</code></li>
<li>无穷除以有限值为有符号的无穷</li>
<li>有限值除以无穷为有符号的0</li>
<li>0除以0为<code>NaN</code></li>
<li>0除以有限非零值为有符号的0</li>
<li>有限非零值除以0位有符号的无穷</li>
<li>若结果太大无法表示则为有符号的无穷，若结果太小无法表示则为有符号的0</li>
</ul>
<h3 id="取余"><a class="markdownIt-Anchor" href="#取余"></a> 取余</h3>
<p>取余运算符<code>op1 % op2</code>将操作数转换为<code>Number</code>类型再隐式的执行双精度浮点除法计算来得到余数，即<code>ToNumber(op1) % ToNumber(op2)</code>。<br />
取余运算符也接受浮点操作数，不像C或C++中限制只能用对整数使用取余运算符。</p>
<ul>
<li>转换后的任何操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>结果的符号等于被除数<code>op1</code>的符号</li>
<li>如果被除数是无穷，或者除数是零，或者两者都是，则结果为<code>NaN</code></li>
<li>如果被除数是有限值，并且除数是无穷，则结果等于被除数</li>
<li>如果被除数为零，并且除数为有限非零值，则结果等于被除数</li>
<li>其余情况<code>a % b = a - trunc(a/b) * b</code>，其中<code>trunc</code>为截断函数，舍去小数位<code>trunc(-2.4) = -2</code>、<code>trunc(2.6) = 2</code>。结果会按照IEEE 754向偶数舍入规则舍入到最接近的可表示值。</li>
</ul>
<h3 id="指数"><a class="markdownIt-Anchor" href="#指数"></a> 指数</h3>
<p>指数运算符<code>op1 ** op2</code>将操作数转换为<code>Number</code>类型再进行计算，即<code>ToNumber(op1) % ToNumber(op2)</code>。等价于<code>Math.pow(op1, op2)</code>。</p>
<p>指数为<code>0</code>时结果为<code>1</code>，不管底数是什么（即便是<code>NaN</code>）<br />
指数为<code>NaN</code>，或者底数为<code>NaN</code>且指数非0，又或者底数为1指数为无穷，则结果为<code>NaN</code></p>
<h2 id="加性运算符"><a class="markdownIt-Anchor" href="#加性运算符"></a> 加性运算符</h2>
<p>加减法运算符通过<code>a - b === a + (-b)</code>可以互相转换</p>
<h3 id="加法"><a class="markdownIt-Anchor" href="#加法"></a> 加法</h3>
<p>加法运算符<code>op1 + op2</code>执行字符串连接，或者数字加法。<br />
加法运算符使用<code>ToPrimitive</code>将操作数转换为原始值<code>op1Prim</code>和<code>op2Prim</code>，如果有任何一个是字符串，则返回<code>ToString(op1Prim)</code>与<code>ToString(op2Prim)</code>连接的结果。<br />
如果都不是字符串，则返回<code>ToNumber(op1Prim)</code>与<code>ToNumber(op2Prim)</code>相加的结果。</p>
<ul>
<li>如果任一操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>两个相反符号的无穷大之和为<code>NaN</code></li>
<li>两个相同符号的无穷大之和为该符号的无穷大。</li>
<li>无穷大与有限值之和等于该符号的无穷大</li>
<li>两个负零之和为<code>-0</code></li>
<li>两个正零或两个符号相反的零的和为<code>+0</code></li>
<li>零和非零有限值之和等于该非零操作数</li>
<li>模相同符号相反的两个非零有限值的和为<code>+0</code></li>
</ul>
<h3 id="减法"><a class="markdownIt-Anchor" href="#减法"></a> 减法</h3>
<p>减法运算符<code>op1 - op2</code>执行数字减法。<br />
减法运算符使用<code>ToNumber</code>将操作数转换为数字，<br />
返回<code>ToNumber(op1) + (-ToNumber(op2))</code></p>
<h2 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h2>
<p>关系运算符返回一个布尔值。</p>
<h3 id="小于"><a class="markdownIt-Anchor" href="#小于"></a> 小于(&lt;)</h3>
<p>小于运算符<code>op1 &lt; op2</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>&lt;(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lVal = ToPrimitive(op1, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> rVal = ToPrimitive(op2, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lVal.startsWith(rVal)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal.startsWith(lVal)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> i = firstDifferentChar(lVal, rVal);</span><br><span class="line">    <span class="keyword">return</span> codeUnit(lVal[i]) &lt; codeUnit(rVal[i]);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    lVal = ToNumber(lVal);</span><br><span class="line">    rVal = ToNumber(rVal);</span><br><span class="line">    <span class="keyword">if</span>(lVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal === rVal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is +<span class="number">0</span> &amp;&amp; rVal is -<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is -<span class="number">0</span> &amp;&amp; rVal is +<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is +oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal is +oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal is -oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is -oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mathLess(lVal, rVal)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大于"><a class="markdownIt-Anchor" href="#大于"></a> 大于(&gt;)</h3>
<p>大于运算符<code>op1 &gt; op2</code>返回<code>op2 &lt; op1</code>，但求值顺序仍然是先<code>op1</code>后<code>op2</code></p>
<h3 id="小于等于"><a class="markdownIt-Anchor" href="#小于等于"></a> 小于等于(&lt;=)</h3>
<p>小于等于运算符<code>op1 &lt;= op2</code>返回<code>op2 &gt;= op1</code>，但求值顺序仍然是先<code>op1</code>后<code>op2</code></p>
<h3 id="大于等于"><a class="markdownIt-Anchor" href="#大于等于"></a> 大于等于(&gt;=)</h3>
<p>大于等于运算符<code>op1 &gt;= op2</code><br />
除了任何一个操作数被转为<code>NaN</code>的情况外，等于<code>!(op1 &lt; op2)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>&gt;=(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lVal = ToPrimitive(op1, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> rVal = ToPrimitive(op2, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lVal.startsWith(rVal)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal.startsWith(lVal)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> i = firstDifferentChar(lVal, rVal);</span><br><span class="line">    <span class="keyword">return</span> !(codeUnit(lVal[i]) &lt; codeUnit(rVal[i]));</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    lVal = ToNumber(lVal);</span><br><span class="line">    rVal = ToNumber(rVal);</span><br><span class="line">    <span class="keyword">if</span>(lVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal === rVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is +<span class="number">0</span> &amp;&amp; rVal is -<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is -<span class="number">0</span> &amp;&amp; rVal is +<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is +oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal is +oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal is -oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is -oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(mathLess(lVal, rVal)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof"><a class="markdownIt-Anchor" href="#instanceof"></a> instanceof</h3>
<p><code>instanceof</code>运算符<code>O instanceof C</code>用于确定<code>O</code>是否从构造函数<code>C</code>定义的继承路径继承，即<code>C.prototype</code>是否在<code>O</code>的原型链上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">O, C</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> C[<span class="built_in">Symbol</span>.hasInstance] == <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToBoolean(c[<span class="built_in">Symbol</span>.hasInstance](O));</span><br><span class="line">  <span class="keyword">if</span>(Type(O) !== <span class="string">&#x27;Object&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    O = O.__proto__</span><br><span class="line">    <span class="keyword">if</span>(O === C.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(O !== <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="in"><a class="markdownIt-Anchor" href="#in"></a> in</h3>
<p><code>in</code>运算符<code>op1 in op2</code>将<code>op1</code>操作数转为原始值，然后转换为Symbol或String类型的属性键<code>op1Key</code>，最后检查对象<code>op2</code>是否具有自有属性或继承属性<code>op1Key</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">in</span>(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> key = ToPrimitive(op1, <span class="string">&#x27;string&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(Type(key) != <span class="string">&#x27;Symbol&#x27;</span>)</span><br><span class="line">    key = ToString(key);</span><br><span class="line">  <span class="keyword">while</span>(op2 !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(op2.HasOwnProperty(key))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    op2 = op2.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相等运算符"><a class="markdownIt-Anchor" href="#相等运算符"></a> 相等运算符</h2>
<p>相等运算符返回一个布尔值。</p>
<h3 id="相等"><a class="markdownIt-Anchor" href="#相等"></a> 相等(==)</h3>
<p>相等运算符<code>op1 == op2</code>对于类型相同的两个变量会调用严格相等运算符，对于类型不同的变量会进行类型转换然后再次调用相等运算符。</p>
<ol>
<li>一个操作数为<code>Null</code>，另一个操作数为<code>Undefined</code>，结果为<code>true</code></li>
<li>一个操作数为<code>Number</code>，另一个操作数为<code>String</code>，使用<code>ToNumber</code>抽象操作将字符串转为数字，再次调用相等运算符比较。</li>
<li>任意一个操作数为<code>Boolean</code>，使用<code>ToNumber</code>抽象操作将布尔值转为数字，再次调用相等运算符比较。</li>
<li>一个操作数为<code>String|Number|Symbol</code>，另一个操作数为<code>Object</code>，使用<code>ToPrimitive</code>抽象操作将对象转换为原始值，再次调用相等运算符比较。</li>
</ol>
<p>由于类型转换，相等运算符不总是可传递的，例如<code>new String(&quot;a&quot;) == &quot;a&quot;</code>为<code>true</code>，但<code>new String(&quot;a&quot;) == new String(&quot;a&quot;)</code>为<code>false</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>==(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Same(Type(op1), Type(op2))) <span class="keyword">return</span> op1 === op2;</span><br><span class="line">  <span class="keyword">if</span>(op1 is <span class="literal">null</span> &amp;&amp; op2 is <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(op1 is <span class="literal">undefined</span> &amp;&amp; op2 is <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Number&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;String&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op1 == ToNumber(op2);</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToNumber(op1) == op2;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Boolean&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToNumber(op1) == op2;</span><br><span class="line">  <span class="keyword">if</span>(Type(op2) is <span class="string">&#x27;Boolean&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op1 == ToNumber(op2);</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;String|Number|Symbol&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;Object&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op1 == ToPrimitive(op2);</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Object&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;String|Number|Symbol&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToPrimitive(op1) == op2;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不等"><a class="markdownIt-Anchor" href="#不等"></a> 不等(!=)</h3>
<p>不等运算符<code>op1 != op2</code>返回<code>!(op1 == op2)</code>。</p>
<h3 id="严格相等"><a class="markdownIt-Anchor" href="#严格相等"></a> 严格相等(===)</h3>
<p>严格相等运算符<code>op1 === op2</code>的基本要求是两个变量类型相同，值也相同。如果变量类型不相同，它不会进行类型转换，而是直接返回<code>false</code>。<br />
7种基本类型中：由于<code>Undefined</code>和<code>Null</code>只有一个值，因此这两种类型的变量是相同的。<br />
<code>Number</code>类型的要求中有两个例外：</p>
<ul>
<li>任何一个操作数是<code>NaN</code>，则返回<code>false</code>，即<code>NaN</code>不和任何数字相等。</li>
<li><code>+0</code>和<code>-0</code>也被认为是相等的。</li>
</ul>
<p><code>String</code>类型的值相同意味着字符串长度相同，代码单元也完全相同。<br />
<code>Boolean</code>类型的值相同意味着同为<code>true</code>或同为<code>false</code>。<br />
<code>Symbol</code>类型的值相同意味着二者是同一个<code>Symbol</code>，即两者在内存中的地址相同。<br />
<code>Object</code>类型的值相同意味着二者是同一个<code>Object</code>，即两者在内存中的地址相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>===(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(notSame(Type(op1), Type(op2))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Undefined&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Null&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(op1 is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(op2 is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(mathEqual(op1,op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(op1 is +<span class="number">0</span> &amp;&amp; op2 is -<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(op1 is -<span class="number">0</span> &amp;&amp; op2 is +<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(codeUnitAllSame(op1, op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Boolean&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(op1 is <span class="literal">true</span> &amp;&amp; op2 is <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(op1 is <span class="literal">false</span> &amp;&amp; op2 is <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Symbol&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sameSymbol(op1, op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sameObject(op1, op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="严格不等"><a class="markdownIt-Anchor" href="#严格不等"></a> 严格不等(!==)</h3>
<p>严格不等运算符<code>op1 !== op2</code>返回<code>!(op1 === op2)</code>。<br />
和关系运算符不同，<code>NaN</code>不会做特别处理，任何一个操作数为<code>NaN</code>则为<code>true</code>。</p>
<h2 id="条件运算符"><a class="markdownIt-Anchor" href="#条件运算符"></a> 条件运算符</h2>
<p>条件运算符<code>condition ? trueResult : falseResult</code>，首先使用<code>ToBoolean</code>将<code>condition</code>转换为布尔值，若为<code>true</code>则返回<code>trueResult</code>，否则返回<code>falseResult</code></p>
<h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h2>
<p>赋值运算符<code>op1 = op2</code>返回<code>op2</code>。<br />
它的副作用是将<code>op2</code>的值赋给引用<code>op1</code>。<br />
当<code>op1</code>是对象字面值，或者数组字面值时，进行解构赋值。</p>
<p>组合赋值运算符<code>op1 @= op2</code>中的<code>@=</code>可以是以下的形式之一，它返回<code>op1 @ op2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x3D; &#x2F;&#x3D; %&#x3D; **&#x3D; +&#x3D; -&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</span><br></pre></td></tr></table></figure>
<p>它的副作用是将<code>op1 @ op2</code>的值赋给引用<code>op1</code>。<br />
因此<code>op1 += op2</code>等价于<code>op1 = op1 + op2</code></p>
<h3 id="解构赋值"><a class="markdownIt-Anchor" href="#解构赋值"></a> 解构赋值</h3>
<p>解构赋值是ES6提供的用于赋值的新语法。<br />
当赋值表达式的等号左侧是一个类似于对象字面值，或者类似于数组字面值的语法产生式时，触发解构赋值。根据它的形式，可以将其分成对象解构赋值，和数组解构赋值。<br />
任何解构赋值内可以嵌套任何一种解构赋值，嵌套语句从等号右侧对象取出的值，会作为内层解构赋值等号右侧的值进行处理。</p>
<h4 id="对象解构赋值"><a class="markdownIt-Anchor" href="#对象解构赋值"></a> 对象解构赋值</h4>
<p>对象解构赋值可以取出对象中的属性值，同时赋值给若干个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为任何变量赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;&#125; = op2;</span><br><span class="line"><span class="comment">// 根据op2的一个属性，为一个变量赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; 赋值属性<span class="number">1</span> &#125; = op2;</span><br><span class="line"><span class="comment">// 将op2的多个属性分别赋给多个变量，最后的逗号是可选的</span></span><br><span class="line"><span class="keyword">let</span> &#123; 赋值属性<span class="number">1</span>, 赋值属性<span class="number">2</span>, &#125; = op2;</span><br></pre></td></tr></table></figure>
<p>等号右侧的<code>op2</code>会被调用<code>ToObject</code>抽象操作转换为一个对象。<br />
当最左侧具有<code>let</code>、<code>const</code>或<code>var</code>时，解构赋值会先声明变量，同时根据对象的属性初始化。<br />
当最左侧不具有变量声明关键字时，解构赋值会将等号右边对象的属性值，相应的赋给另一个对象的属性。</p>
<p>赋值属性有两种形式：<br />
第一种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; 标识符 &#125; = srcObj</span><br><span class="line">&#123; 标识符 = 默认值 &#125; = srcObj</span><br></pre></td></tr></table></figure>
<p>将标识符转换为字符串属性键，然后将<code>srcObj</code>的同名字符串属性键的值，赋给名称为此标识符的变量。<br />
如果对象<code>srcObj</code>的属性值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，会为变量赋予默认值。如果属性值不为<code>undefined</code>，书写默认值也没有用处。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; myAge &#125; = srcObj</span><br><span class="line"><span class="keyword">let</span> &#123; myAge = <span class="number">18</span> &#125; = srcObj</span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; 属性名:左值表达式 &#125; = srcObj</span><br><span class="line">&#123; 属性名:左值表达式 = 默认值 &#125; = srcObj</span><br></pre></td></tr></table></figure>
<p>左值表达式的结果是一个引用。<br />
从<code>srcObj</code>中获取属性键为<code>属性名</code>的属性，将其值赋给<code>左值表达式</code>。如果对象<code>srcObj</code>的属性值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，会为<code>左值表达式</code>赋予默认值。如果属性值不为<code>undefined</code>，书写默认值也没有用处。</p>
<p>这种形式也支持嵌套的解构赋值，因为解构赋值表达式也是一个左值表达式，可以用来访问<code>srcObj</code>的嵌套的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; 属性名<span class="number">1</span>: &#123; 属性名<span class="number">2</span>: 左值表达式 &#125; &#125; = srcObj</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">&#123; 属性名<span class="number">2</span>: 左值表达式 &#125; = srcObj.属性名<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意，如果<code>srcObj.属性名1</code>不存在，那么必须在外层的解构赋值书写默认值，否则会抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; 属性名<span class="number">1</span>: &#123; 属性名<span class="number">2</span>: 左值表达式 &#125; = 默认对象 &#125; = srcObj</span><br></pre></td></tr></table></figure>
<p>由于解构赋值和对象字面值的语法类似，解构赋值经常被误认为是对象字面值语法，导致抛出SyntaxError异常，此时需要用括号将其作为一个整体表达式执行。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line">&#123; <span class="attr">name</span>: obj[<span class="string">&#x27;oName&#x27;</span>], <span class="attr">age</span>:obj[<span class="string">&#x27;oAge&#x27;</span>] &#125; = person</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">(&#123; <span class="attr">name</span>: obj[<span class="string">&#x27;oName&#x27;</span>], <span class="attr">age</span>:obj[<span class="string">&#x27;oAge&#x27;</span>] &#125; = person)</span><br></pre></td></tr></table></figure>
<p>解构赋值的过程可能抛出异常，但此前已完成的赋值操作不会回滚，因此可能出现部分变量被正确赋值，部分变量没被正确赋值。</p>
<h4 id="数组解构赋值"><a class="markdownIt-Anchor" href="#数组解构赋值"></a> 数组解构赋值</h4>
<p>数组解构赋值可以同时将可迭代对象（不仅仅是数组）的迭代值，赋值给多个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为任何元素赋值，也不调用next()</span></span><br><span class="line"><span class="keyword">let</span> [] = iterable;</span><br><span class="line"><span class="comment">// 为一个元素赋值，调用一次next()</span></span><br><span class="line"><span class="keyword">let</span> [ 元素赋值<span class="number">1</span> ] = iterable;</span><br><span class="line"><span class="comment">// 为多个元素赋值，最后的逗号是可选的，调用两次next()</span></span><br><span class="line"><span class="keyword">let</span> [ 元素赋值<span class="number">1</span>, 元素赋值<span class="number">2</span>, ] = iterable;</span><br><span class="line"><span class="comment">// 留空的元素赋值，调用两次next()</span></span><br><span class="line"><span class="keyword">let</span> [ , 元素赋值<span class="number">1</span>, ]</span><br><span class="line"><span class="comment">// 剩余元素语法，用一个数组接受所有next()的结果</span></span><br><span class="line"><span class="keyword">let</span> [ ...左值表达式 ]</span><br><span class="line"><span class="keyword">let</span> [ 元素赋值<span class="number">1</span>, ...左值表达式]</span><br><span class="line"><span class="keyword">let</span> [ , , , ...左值表达式 ]</span><br></pre></td></tr></table></figure>
<p>当最左侧具有<code>let</code>、<code>const</code>或<code>var</code>时，解构赋值会先声明所有变量，然后用迭代值初始化变量。<br />
当最左侧不具有变量声明关键字时，解构赋值不会声明变量而是直接赋值。</p>
<p>元素赋值有以下几种形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 左值表达式 ] = iterable</span><br><span class="line">[ 左值表达式 = 默认值 ] = iterable</span><br><span class="line">[ ,] = iterable</span><br></pre></td></tr></table></figure>
<p>数组解构赋值执行以下过程：</p>
<ol>
<li>调用等号右侧对象的<code>Symbol.iterator</code>方法获取一个迭代器<code>iterator</code>。</li>
<li>对每个<code>元素赋值</code>语句，调用一次迭代器的<code>next()</code>方法：
<ol>
<li>如果迭代结果（<code>IteratorResult</code>对象）的<code>done</code>为<code>false</code>，且迭代值<code>value</code>不为<code>undefined</code>，则将<code>value</code>赋给<code>元素赋值</code>语句给出的引用。</li>
<li>否则，如果<code>元素赋值</code>语句有<code>默认值</code>，则将<code>默认值</code>赋给<code>元素赋值</code>语句给出的引用。</li>
<li>否则，将<code>undefined</code>赋给<code>元素赋值</code>语句给出的引用。</li>
</ol>
</li>
</ol>
<p>注意：</p>
<ul>
<li><code>元素赋值</code>语句可能为空，即使逗号前留空也会调用<code>next()</code>，只是忽略迭代值，不对结果做赋值操作。因此，如果加上最后可选的逗号，那么每个逗号都会导致一次<code>next()</code>调用，其结果要么被忽略，要么被赋予逗号前的<code>元素赋值</code>语句。</li>
<li><code>...左值表达式</code>会在当前迭代器的基础上，不断调用<code>next()</code>将值添加到一个新数组中，直到返回的迭代结果对象<code>done</code>为<code>true</code>，最后将这个新数组，赋值给<code>左值表达式</code>。<code>...左值表达式</code>语句只能出现在最右边，它的右边不允许再出现逗号或者元素赋值语句。</li>
</ul>
<p>基于数组解构赋值语法可以方便的交换变量的值，等号右侧使用数组字面值创建了一个可迭代对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>
<h2 id="逗号运算符"><a class="markdownIt-Anchor" href="#逗号运算符"></a> 逗号运算符</h2>
<p>逗号运算符<code>op1 , op2</code>从左到右依次求值，返回<code>GetValue(op2)</code></p>
<h2 id="new运算符"><a class="markdownIt-Anchor" href="#new运算符"></a> new运算符</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> F(arg1, arg2);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">F, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = F.prototype;</span><br><span class="line">  <span class="keyword">if</span>(Type(proto) is not <span class="built_in">Object</span>)</span><br><span class="line">    proto = <span class="built_in">Object</span>.prototype;</span><br><span class="line">  <span class="keyword">let</span> thisArgument = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">  <span class="keyword">let</span> result = F.call(thisArgument, ...args);</span><br><span class="line">  <span class="keyword">if</span>(Type(result) is <span class="built_in">Object</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> thisArgument;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new运算符获取其后面的构造函数的<code>prototype</code>属性，以这个属性的值作为原型创建新对象，若这个值不是对象则采用默认原型<code>Object.prototype</code>。<br />
以创建出的新对象作为<code>this</code>值调用构造函数并传递参数，如果构造函数返回了一个对象，则直接返回该对象。如果没有返回对象，则返回之前创建的作为构造函数<code>this</code>值的对象。<br />
<code>new.target</code>操作符可以引用函数式环境记录的<code>[[NewTarget]]</code>对象，当使用<code>new</code>调用函数时，<code>new.target</code>返回的是构造函数对象。当不用<code>new</code>直接调用函数时，<code>new.target</code>为<code>undefined</code>。<br />
通过<code>new.target</code>进行判断，可以阻止函数被<code>new</code>或者阻止直接调用。</p>
<h2 id="可选链运算符"><a class="markdownIt-Anchor" href="#可选链运算符"></a> 可选链运算符</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">op?.(参数)</span><br><span class="line">op?.[表达式]</span><br><span class="line">op?.标识符名</span><br></pre></td></tr></table></figure>
<p>该运算符当<code>?.</code>左侧的<code>op</code>为<code>null</code>或<code>undefined</code>时，直接返回<code>undefined</code>。<br />
否则才会返回函数调用、属性访问或标识符查找。<br />
示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123; &#125;</span><br><span class="line">let val &#x3D; o?.a?.x;</span><br></pre></td></tr></table></figure>
<p>该运算符可以避免访问深层可能不存在的属性时进行额外的检查。</p>
<h1 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h1>
<p>ECMAScript 中的语句以分号结尾。末尾的分号可以省略，省略分号意味着由解析器确定语句在哪里结尾。</p>
<h2 id="块语句"><a class="markdownIt-Anchor" href="#块语句"></a> 块语句</h2>
<p>多条语句可以合并成一个块语句。块语句由一个左花括号（<code>&#123;</code>）标识开始，一个右<br />
花括号（<code>&#125;</code>）标识结束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test &#x3D; false;</span><br><span class="line">  console.log(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块语句会创建新的<code>LexicalEnvironment</code>（词法环境），退出代码块时会回到之前的词法环境。<br />
块语句不会创建新的<code>VariableEnvironment</code>（变量环境）</p>
<h2 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h2>
<p>if语句有两种格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( Expression ) Statement1 <span class="keyword">else</span> Statement2</span><br><span class="line"><span class="keyword">if</span> ( Expression ) Statement1</span><br></pre></td></tr></table></figure>
<p>若<code>ToBoolean(Expression)</code>为<code>true</code>，则执行<code>Statement1</code>，否则执行<code>Statement2</code></p>
<h2 id="do-while语句"><a class="markdownIt-Anchor" href="#do-while语句"></a> do-while语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> Statement <span class="keyword">while</span> ( Expression ) ;</span><br></pre></td></tr></table></figure>
<ol>
<li>执行<code>Statement</code>语句</li>
<li>测试<code>ToBoolean(Expression)</code>，若为<code>false</code>则结束。</li>
<li>回到第1步。</li>
</ol>
<h2 id="while语句"><a class="markdownIt-Anchor" href="#while语句"></a> while语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( Expression ) Statement</span><br></pre></td></tr></table></figure>
<ol>
<li>测试<code>ToBoolean(Expression)</code>，若为<code>false</code>则结束。</li>
<li>执行<code>Statement</code>语句</li>
<li>回到第1步</li>
</ol>
<h2 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( Initialization&#123;opt&#125; ; Expression1&#123;opt&#125; ; Expression2&#123;opt&#125; ) Statement</span><br><span class="line"></span><br><span class="line">Initialization:</span><br><span class="line">  Expression</span><br><span class="line">  <span class="keyword">var</span> VariableDeclarationList</span><br><span class="line">  <span class="keyword">let</span> BindingList</span><br><span class="line">  <span class="keyword">const</span> BindingList</span><br></pre></td></tr></table></figure>
<ol>
<li>执行<code>Initialization</code></li>
<li>测试<code>ToBoolean(Expression1)</code>，若为<code>false</code>则退出</li>
<li>执行<code>Statement</code></li>
<li>执行<code>Expression2</code></li>
<li>回到第2步</li>
</ol>
<p>for语句括号中的每个部分都是可选的，若忽略<code>Initialization</code>或<code>Expression2</code>则不执行第1或第4步，若忽略<code>Expression1</code>，则在第2步测试时永远为<code>true</code>。<br />
在初始化语句中，若使用<code>let</code>或<code>const</code>，则会为for循环基于当前词法环境<code>env</code>来创建一个新的词法环境<code>forEnv</code>。并在退出循环时切回原词法环境<code>env</code>。<br />
若使用的是<code>const</code>，则会将变量绑定在新创建的词法环境<code>forEnv</code>，因此退出循环后变量无法使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env(包围for的词法环境)</span><br><span class="line">  forEnv(for语句创建的词法环境)</span><br></pre></td></tr></table></figure>
<p>若使用的是<code>let</code>，则每次进入循环体<code>Statement</code>时又会基于当前词法环境（第一次是<code>forEnv</code>，之后是<code>forBodyEnv</code>）的外部词法环境<code>env</code>创建新的词法环境<code>forBodyEnv</code>，然后将<code>let</code>声明的变量在这个新词法环境<code>forBodyEnv</code>上创建绑定，同时会给新词法环境中的变量赋予上一次的词法环境相同变量名的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env(包围for的词法环境)</span><br><span class="line">  forEnv(for语句创建的词法环境)</span><br><span class="line">    forBodyEnv1(第一次进入循环体创建的词法环境)</span><br><span class="line">    forBodyEnv2(第二次进入循环体创建的词法环境)</span><br></pre></td></tr></table></figure>
<p>例如<code>for(let i = 0; i &lt; 2; i++)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env</span><br><span class="line">  forEnv(let i &#x3D; 0)</span><br><span class="line">    forBodyEnv1( let i &#x3D; lastEnvVal(i) &#x3D;&gt; i &#x3D; 0 )</span><br><span class="line">      i++ &#x3D;&gt; i &#x3D; 1</span><br><span class="line">    forBodyEnv2( let i &#x3D; lastEnvVal(i) &#x3D;&gt; i &#x3D; 1 )</span><br></pre></td></tr></table></figure>
<p>循环体第一次执行，当前词法环境是<code>forEnv</code>，外部词法环境是<code>env</code>，基于当前词法环境的外部词法环境创建新词法环境<code>forBodyEnv1</code>，在<code>forBodyEnv1</code>上重新创建变量绑定<code>i</code>，其值为上一次词法环境<code>forEnv</code>相同变量名的值<code>0</code>。本次循环结束后，<code>forBodyEnv1</code>词法环境中变量<code>i</code>的值为<code>1</code>。<br />
循环体第二次执行，当前词法环境是<code>forBodyEnv1</code>，外部词法环境是<code>env</code>，基于当前词法环境的外部词法环境创建新词法环境<code>forBodyEnv2</code>，在<code>forBodyEnv2</code>上重新创建变量绑定<code>i</code>，其值为上一次词法环境<code>forBodyEnv1</code>相同变量名的值<code>1</code>，本次循环结束后，<code>forBodyEnv2</code>的词法环境中变量<code>i</code>的值为<code>2</code>。<br />
以此类推。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  button[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  button[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>let</code>时，虽然每次循环<code>i</code>的值都正确累加了，也能访问到这个值（因为被赋予了上一次词法环境的同名值），但每次循环的<code>i</code>不是同一个变量，因而每次点击按钮时输出的都是那一次循环时创建的词法环境中<code>i</code>的值。<br />
使用<code>var</code>时，每次循环的<code>i</code>是同一个变量，累加也是加到这个变量里，因而每次点击按钮时输出的都是这个<code>i</code>的值。</p>
<h2 id="for-in语句"><a class="markdownIt-Anchor" href="#for-in语句"></a> for-in语句</h2>
<p>for-in语句用于遍历对象的可枚举属性的字符串属性键，包括自有属性和继承属性。<br />
首先遍历自有属性，然后是原型的自有属性，然后是原型的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( LeftHandSideExpression <span class="keyword">in</span> Expression ) Statement</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> ForBinding <span class="keyword">in</span> Expression ) Statement</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> ForBinding <span class="keyword">in</span> Expression ) Statement</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> ForBinding <span class="keyword">in</span> Expression ) Statement</span><br></pre></td></tr></table></figure>
<p>每个属性的名字只会遍历一遍，例如如果自有属性有一个可枚举的属性，其属性键为<code>a</code>，那么在遍历原型的自有属性时，即使也有名为<code>a</code>的属性，也不会再次遍历。<br />
for-in语句对词法环境的创建与变量的绑定和for语句一样。<br />
for-in语句不对遍历的顺序作任何保证。<br />
如果在遍历过程中删除了属性，且该属性的名字还没有被遍历过，那么之后也不会再遍历到这个被删除的属性。<br />
如果在遍历过程中添加了属性，for-in语句不保证新添加的属性在未来会被遍历到。<br />
for-in语句实际上遍历了基于<code>Expression</code>创建的生成器函数返回的可迭代对象，可迭代对象返回的值就是属性的名字。</p>
<h2 id="for-of语句"><a class="markdownIt-Anchor" href="#for-of语句"></a> for-of语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( LeftHandSideExpression <span class="keyword">of</span> AssignmentExpression ) Statement</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> ForBinding <span class="keyword">of</span> AssignmentExpression ) Statement</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> ForBinding <span class="keyword">of</span> AssignmentExpression ) Statement</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> ForBinding <span class="keyword">of</span> AssignmentExpression ) Statement</span><br></pre></td></tr></table></figure>
<p>for-of语句会遍历生成器函数返回的可迭代对象<code>GetValue(AssignmentExpression)[Symbol.iterator]()</code><br />
内置对象<code>String</code>、<code>Array</code>、<code>Map</code>、<code>Set</code>都实现了<code>Symbol.iterator</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  result = iterator.next()</span><br><span class="line">  done = result.done</span><br><span class="line">  <span class="keyword">if</span>(done) <span class="keyword">return</span></span><br><span class="line">  value = result.value</span><br><span class="line">  Bind(ForBinding, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="with语句"><a class="markdownIt-Anchor" href="#with语句"></a> with语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ( Expression ) Statement</span><br></pre></td></tr></table></figure>
<p>with语句会基于<code>Expression</code>对象创建一个新的词法环境，并在执行完<code>Statement</code>后还原词法环境。在这个新创建的词法环境中，<code>this</code>值是计算<code>Expression</code>得到的对象，该对象的所有属性都在这个词法环境中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(hostname);</span><br><span class="line">  <span class="comment">// 等价于location.hostname</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>严格模式不允许使用with语句，规范不推荐使用。</p>
<h2 id="switch语句"><a class="markdownIt-Anchor" href="#switch语句"></a> switch语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( Expression0 ) &#123;</span><br><span class="line">  <span class="keyword">case</span> Expression1 : StatementList1&#123;opt&#125;</span><br><span class="line">  <span class="keyword">case</span> Expression2 : StatementList2&#123;opt&#125;</span><br><span class="line">  <span class="keyword">default</span> : StatementList3&#123;opt&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch语句类似if语句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Expression0 === Expression1) StatementList1&#123;opt&#125;</span><br><span class="line"><span class="keyword">if</span>(Expression0 === Expression2) StatementList2&#123;opt&#125;</span><br><span class="line">StatementList3&#123;opt&#125;</span><br></pre></td></tr></table></figure>
<p>switch语句内从上到下执行，只能使用case语句和default语句，case语句可以有一个或多个，default语句最多只能有一个。<br />
每遇到case语句都会将switch表达式与case表达式使用<strong>严格相等运算符</strong>进行比较，若为<code>true</code>则执行它对应的<code>StatementList</code>。<br />
每遇到default语句都会直接执行它对应的<code>StatementList</code>。<br />
<code>StatementList</code>是可选的，可以没有，这种情况下在比较完成后就会直接寻找下一个case或default语句进行比较。<br />
有时我们希望只执行一个case语句或default语句，而非从上到下执行所有的语句，此时可以使用break语句，它会直接退出switch语句。</p>
<h2 id="标签语句"><a class="markdownIt-Anchor" href="#标签语句"></a> 标签语句</h2>
<p>语句前面可以加标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LabelIdentifier : Statement</span><br><span class="line">LabelIdentifier : FunctionDeclaration</span><br></pre></td></tr></table></figure>
<p>任何标识符都可以作为标签。<br />
标签仅用于 break 和 continue 语句。</p>
<h2 id="break和continue语句"><a class="markdownIt-Anchor" href="#break和continue语句"></a> break和continue语句</h2>
<p>break和continue语句用于循环语句的循环体内。<br />
break语句还可以用于switch语句内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">break</span> LabelIdentifier ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">continue</span> LabelIdentifier ;</span><br></pre></td></tr></table></figure>
<p>break语句可以结束当前循环，直接执行循环语句的后面的语句。<br />
break语句位于case或default语句内时，会结束switch语句，并执行switch语句后面的语句。<br />
带标签的break语句可以结束标签所对应语句的循环，通常用于嵌套循环内直接退出外层循环。<br />
continue语句可以结束本轮循环，然后从循环体顶部重新开始执行下一轮循环。<br />
带标签的continue语句可以结束本轮循环，然后从标签所对应语句的循环体顶部重新开始执行下一轮循环。</p>
<h2 id="try语句"><a class="markdownIt-Anchor" href="#try语句"></a> try语句</h2>
<p>try语句一共有三种形式：<br />
第一种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="comment">// something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="comment">// something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其含义是：</p>
<ol>
<li>执行<code>try</code>后面的块</li>
<li>如果抛出了异常，则执行<code>catch</code>中的块，否则这一步什么也不做</li>
<li>执行<code>finally</code>中的块</li>
</ol>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<p>函数是具有<code>[[Call]]</code>内部方法的对象，每个函数都是<code>Function</code>构造函数的实例。</p>
<p>函数对象具有<code>name</code>属性，没有名字可能是空字符串，也可能是<code>&quot;anonymous&quot;</code>，bind的函数<code>name</code>前面有<code>bound</code>前缀，访问器方法的 <code>name</code>前面也有<code>get</code>或<code>set</code>前缀</p>
<p>在函数内部，函数对象具有<code>caller</code>属性，可以得到调用当前函数的函数，若在全局作用域中调用则为<code>null</code>。</p>
<p>函数对象具有<code>length</code>属性，它是函数定义的参数数量。</p>
<p>函数对象创建时包围它的词法环境，会作为函数对象的<code>[[Environment]</code>内部插槽。它也是执行函数代码时的外部词法环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// HERE</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aa = a();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(aa()); <span class="comment">// 函数对象aa的外部词法环境是上面HERE部分，访问不到变量color</span></span><br><span class="line">&#125;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>
<h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2>
<p>要定义函数，有四种方法：</p>
<p>四种方法共同点是参数列表有以下形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空参数列表</span></span><br><span class="line">( )</span><br><span class="line"><span class="comment">// 多个参数用逗号分隔</span></span><br><span class="line">(参数<span class="number">1</span> , 参数<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 只有剩余参数的参数列表</span></span><br><span class="line">( ... 剩余参数 )</span><br><span class="line"><span class="comment">// 剩余参数必须是最后一个参数</span></span><br><span class="line">(参数<span class="number">1</span> , 参数<span class="number">2</span>, ...剩余参数)</span><br></pre></td></tr></table></figure>
<p>参数有以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个参数有以下四种形式</span></span><br><span class="line">参数名</span><br><span class="line">参数名 = 默认值</span><br><span class="line">解构绑定</span><br><span class="line">解构绑定 = 默认值</span><br><span class="line"><span class="comment">// 剩余参数只有一种形式</span></span><br><span class="line">剩余参数名</span><br></pre></td></tr></table></figure>
<p>解构绑定是ES6提供的用于定义函数参数的新语法。<br />
解构绑定的语法和解构赋值的语法几乎相同，可以将解构绑定理解为在函数内，对传进来的参数进行解构赋值。解构绑定也分为对象解构绑定，和数组解构绑定。</p>
<h3 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名标识符 (<span class="params"> 参数列表 </span>) </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<p>函数声明的<code>函数名标识符</code>和<code>var</code>变量一样，会被提升。<br />
函数对象会被自动添加<code>prototype</code>属性，以便作为构造函数。</p>
<h3 id="函数表达式"><a class="markdownIt-Anchor" href="#函数表达式"></a> 函数表达式</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名标识符 (<span class="params"> 参数列表 </span>) </span>&#123; 函数体 &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"> 参数列表 </span>) </span>&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<p>函数表达式中的函数名仅用于函数体内部，不能在外部引用此标识符，一般用于函数体内部递归调用自己。<br />
函数对象会被自动添加<code>prototype</code>属性，以便作为构造函数。</p>
<h3 id="箭头函数"><a class="markdownIt-Anchor" href="#箭头函数"></a> 箭头函数</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">( 参数列表 ) =&gt; &#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 只有一个参数的情况下，参数可以不加括号</span></span><br><span class="line">参数<span class="number">1</span> =&gt; &#123; 函数体 &#125;</span><br><span class="line"><span class="comment">// 函数体只返回一个表达式，可以不加花括号不写return</span></span><br><span class="line">参数<span class="number">1</span> =&gt; 表达式</span><br></pre></td></tr></table></figure>
<p>箭头函数用于定义函数表达式，该语法返回的是一个函数。<br />
参数和<code>=&gt;</code>之间不能有换行符。<br />
函数对象<strong>不会</strong>被自动添加<code>prototype</code>属性。<br />
箭头函数内部没有为<code>arguments</code>，<code>super</code>，<code>this</code>或<code>new.target</code>定义局部绑定。因此在箭头函数里对<code>arguments</code>，<code>super</code>，<code>this</code>或<code>new.target</code>的任何引用都会被解析为箭头函数所在（而不是箭头函数创建的）的词法环境中的绑定。<br />
<code>参数1 =&gt; 表达式</code>这种形式，表达式的计算结果会作为<code>return</code>语句的值返回。</p>
<h3 id="function构造函数"><a class="markdownIt-Anchor" href="#function构造函数"></a> Function构造函数</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>, <span class="string">&quot;函数体&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>函数对象会被自动添加<code>prototype</code>属性，以便作为构造函数。</p>
<h2 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h2>
<p>每个定义的参数在函数体都按顺序作为<code>let</code>变量创建并初始化为调用时传递的值。如果参数没有定义默认值，则不传递参数时其值为<code>undefined</code>。如果参数定义了默认值，则不传递参数或者传递了<code>undefined</code>时，将参数变量初始化为默认值。<br />
在定义默认值时，后定义的参数可以使用前面的参数作为默认值。反之则不行，因为前面参数的<code>let</code>初始化时，后面参数的<code>let</code>还处于暂时性死区无法访问。<br />
参数初始化时会在一个新的临时词法环境中进行，此词法环境的外部词法环境是函数调用时的执行上下文的词法环境，而不是函数体创建的词法环境，因此参数初始化时，默认值无法引用函数体中的变量。</p>
<p>剩余参数的标识符对应一个数组对象，它的元素是所有传递进来的、但没有与定义的命名参数绑定的参数表达式，因此其目的是收集所有未命名的参数值。如果传递进来的所有参数都对应了命名参数，那么剩余参数数组为空。</p>
<p>在非箭头函数内部，可以使用<code>arguments</code>关键字拿到一个类数组对象，它的每个元素都是传递进来的参数。但要注意它的元素是参数的原始值，不包括解构绑定或默认值语法将传递进来的参数进一步赋值后的结果。例如数组解构绑定，传递进来一个数组，<code>arguments</code>的元素就是这个数组，而不是结构绑定后的各个变量值。传递超出定义数量的参数，也可以通过<code>arugments</code>拿到。<br />
非严格模式下<code>arguments</code>对象还有一个<code>callee</code>属性，指向当前函数，此属性可用于对没有名字的函数进行递归调用。<code>arguments.callee</code>具有<code>caller</code>属性，可以得到调用当前函数的函数，若在全局作用域中调用则为<code>null</code>。</p>
<h3 id="绑定参数"><a class="markdownIt-Anchor" href="#绑定参数"></a> 绑定参数</h3>
<p>函数对象具有<code>bind</code>方法，它接受要绑定的<code>this</code>值和参数，返回一个新函数。<br />
新函数的<code>this</code>已经绑定，且接受的参数不包括已经绑定的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.bind ( thisArg , ...args)</span><br></pre></td></tr></table></figure>
<h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2>
<p>函数调用表达式返回一个ECMAScript值，该值是函数体内<code>return</code>语句的值。如果没有<code>return</code>语句，则该值是<code>undefined</code>。<br />
函数调用后，其外部词法环境是<code>[[Enviroment]]</code>内部插槽指向的词法环境，即定义函数时的包围定义语句的词法环境，而非函数调用者的词法环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数引用(参数表达式<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 传递多个参数用逗号分隔</span></span><br><span class="line">函数引用(参数表达式<span class="number">1</span>, 参数表达式<span class="number">2</span>)</span><br><span class="line">函数引用(...可迭代对象)</span><br><span class="line">函数引用(参数表达式<span class="number">1</span>, ...可迭代对象)</span><br><span class="line">函数引用(参数表达式<span class="number">1</span>, ...可迭代对象, 参数表达式<span class="number">2</span>, ...可迭代对象)</span><br><span class="line">函数引用 <span class="string">`模板`</span></span><br><span class="line">函数引用.call(thisValue, 参数表达式<span class="number">1</span>, 参数表达式<span class="number">2</span>)</span><br><span class="line">函数引用.apply(thisValue, 参数数组或<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(a1, <span class="number">5</span>)</span><br><span class="line">func(...iteratable)</span><br><span class="line">func<span class="string">`a<span class="subst">$&#123;b&#125;</span>c`</span></span><br></pre></td></tr></table></figure>
<p>除了最常见的只传参数表达式来进行函数调用的方式，还有两种新的参数语法。</p>
<ol>
<li><code>...可迭代对象</code>：这种语法将可迭代对象的每个迭代值作为单独的参数传给函数，此语法可以用在参数列表的任何位置，也可以使用任意次。</li>
<li>模板字面值。这种方式使用模板字面值来传递参数：<br />
函数接收到的第一个参数是一个数组（为方便下文指代这个数组，将其命名为<code>TemplateObject</code>），之后的参数依次是模板中每个插值表达式<code>$&#123;表达式&#125;</code>的计算结果。<br />
<code>TemplateObject</code>数组的元素是模板字面值的子字符串，子字符串是将插值表达式看作分隔符得到的，有n个插值表达式，就有n+1个子串（如果插值表达式在首尾则可能分隔出空串）。这些子串中的转义序列会被替换成它所表示的字符。<br />
除了整数索引，<code>TemplateObject</code>数组还有一个特殊的属性<code>raw</code>，它也是一个保存模板字面值的子字符串的数组，不同的是，这些子串中的转义序列不会被替换成它所表示的字符，即输入<code>\n</code>，子串中保存的就是字符反斜杠<code>\</code>和字符<code>n</code>。<br />
通过子字符串和插值表达式就可以还原模板字符串本身，它们的顺序是子串1，或 子串1、插值1、子串2。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zipTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = strings[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; expressions.length; i++) &#123;</span><br><span class="line">    result += expressions[i] + strings[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="keyword">return</span> strings[<span class="number">0</span>] + expressions.map(<span class="function">(<span class="params">expression, index</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;expression&#125;</span><span class="subst">$&#123;strings[index + <span class="number">1</span>]&#125;</span>`</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this值"><a class="markdownIt-Anchor" href="#this值"></a> this值</h3>
<p>非箭头函数内部的<code>this</code>关键字的值，取决于函数调用表达式的<code>函数引用</code>部分。如果这部分是一个属性引用，则<code>this</code>是拥有此属性的对象。如果这部分不是属性引用也不在with语句内，则<code>this</code>值为<code>undefined</code>（非严格模式下为<code>window</code>），如果这部分不是属性引用且在with语句内，则<code>this</code>值为<code>with</code>语句中的对象。<br />
箭头函数内部的<code>this</code>关键字的值，取决于定义箭头函数时那一刻，包围箭头函数的词法环境的<code>this</code>值，与之后任何时候的调用表达式无关。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()()); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在上述例子中，参数列表左侧的<code>函数引用</code>部分为<code>object.getIdentityFunc()</code>，它不是一个属性引用，因此<code>this</code>为<code>window</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arrowFunc = foo.call(obj);</span><br><span class="line">arrowFunc(); <span class="comment">// 应该是obj，而不是在此时向上查找到window</span></span><br><span class="line">arrowFunc.call(&#123;&#125;) <span class="comment">// 还是obj</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ()=&gt;&#123;</span><br><span class="line">    ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;<span class="built_in">this</span>.resolve2 = resolve&#125;)</span><br><span class="line"><span class="comment">// Promise构造函数会用call(undefined)调用传入的函数。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 这里的this是undefined</span></span><br><span class="line">  (<span class="function">()=&gt;</span>&#123;<span class="built_in">this</span>.resolve2 = resolve&#125;)()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// window.resolve2</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的this</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    (<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;)()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.foo(); <span class="comment">// a a</span></span><br><span class="line"><span class="keyword">var</span> b = a.foo;</span><br><span class="line">b.foo() <span class="comment">// window window;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bar(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&quot;ok&quot;</span>,<span class="built_in">this</span>)&#125;); <span class="comment">// window</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>, <span class="built_in">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bar(b.foo()); <span class="comment">// b 在调用b.foo()时定义了箭头函数，其this值不会变</span></span><br><span class="line"><span class="keyword">var</span> c = b.foo;</span><br><span class="line"><span class="keyword">new</span> Bar(c()); <span class="comment">// window 在调用c()时定义了箭头函数</span></span><br></pre></td></tr></table></figure>
<p>执行此箭头函数是在Promise的构造函数中，这里的this也不是构造函数中的this，而是定义时包围箭头函数的词法环境中的this。new表达式不会创建新的词法环境，因此它的this就是书写new时的词法环境，即全局词法环境。</p>
<h3 id="iife"><a class="markdownIt-Anchor" href="#iife"></a> IIFE</h3>
<p>立即调用的函数表达式，IIFE(Immediately Invoked Function Expression)。<br />
它是指在定义函数表达式时直接调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br></pre></td></tr></table></figure>
<p>在ES6的块级作用域出现之前，由于只有函数作用域，因此经常使用IIFE来模拟块级作用域。<br />
其一可以避免变量名污染外层作用域，其二IIFE也可以模拟ES6的for语句中<code>let</code>声明的变量，每次循环创建新词法作用域的机制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用IIFE在每次循环创建新作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用let的等价做法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用IIFE在每次循环创建新作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不正确的使用IIFE创建新作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第四种不正确的形式中，尽管使用了IIFE，也创建了新作用域，但这里引用的变量<code>i</code>仍然是<code>for</code>语句中的变量<code>i</code>，而不是每次循环引用不同的变量<code>i</code>。<br />
要正确使用IIFE，需要将循环变量<code>i</code>作为参数传递给IIFE，此时每轮循环的IIFE内有了与外面无关的变量<code>i</code>，同时遮挡了<code>for</code>语句中的白娘<code>i</code>，内层函数再引用变量<code>i</code>就是这个每轮循环中创建的作用域中的独立的变量<code>i</code>。</p>
<h2 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h2>
<p>闭包是指引用了另一个函数作用域中变量的函数。<br />
每个函数对象在创建时都会将包围该函数的词法环境赋给函数对象的<code>[[Environment]]</code>内部插槽，<code>[[Environment]]</code>用于在执行函数代码时用作外部词法环境。<br />
因此一个内部函数可以访问到其外部函数的变量，不管这个内部函数之后在何处被使用。</p>
<p>在闭包中，除非闭包是一个箭头函数，否则当前词法环境的局部<code>this</code>绑定会遮盖住外部词法环境的<code>this</code>绑定，因此必须在外部函数中单独用一个变量保存<code>this</code>值才能让闭包访问，例如<code>let self = this</code>。<br />
如果闭包是一个箭头函数，那么就可以直接访问定义时的词法环境的<code>this</code>值。</p>
<h2 id="尾调用优化"><a class="markdownIt-Anchor" href="#尾调用优化"></a> 尾调用优化</h2>
<p>ES6规定了尾调用的优化机制，满足条件时，调用栈会直接将外层函数弹出，只留下要返回的内层函数。<br />
条件是：</p>
<ul>
<li>严格模式</li>
<li>外部函数的<code>return</code>语句后是函数调用</li>
<li>外部函数的<code>return</code>语句是最后一句，之后没有其他操作</li>
<li><code>return</code>的函数调用中，没有引用外部函数作用域的闭包</li>
</ul>
<h2 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h2>
<p>实现了<code>Iterable</code>接口的对象被称为可迭代对象，可迭代对象类似于数学上的集合，它包含许多元素，但元素是有限，且有无歧义的遍历顺序的。<br />
迭代器<code>Iterator</code>对象表示对可迭代对象的一次遍历，每个迭代器会关联到一个可迭代对象上。<br />
<code>IteratorResult</code>对象表示一次迭代过程中的结果，包括迭代是否完成，本次迭代得到的值。<br />
按照约定，实现了<code>Iterable</code>接口的对象应该具有一个属性键为<code>Symbol.iterator</code>的属性，它的属性值是一个函数，该函数返回一个<code>Iterator</code>对象。</p>
<p><code>Iterator</code>对象需要具有一个必需的函数<code>next</code>，以及两个可选的函数<code>return</code>和<code>throw</code>，这三个函数都返回<code>IteratorResult</code>对象。<br />
如果对<code>next</code>方法的前一次调用，返回了一个<code>done</code>属性为<code>true</code>的<code>IteratorResult</code>对象，那么之后调用<code>next</code>方法，也要返回<code>done</code>属性为<code>true</code>的<code>IteratorResult</code>对象。<br />
调用<code>return</code>方法表示通知调用方，之后不会再调用<code>next</code>方法。返回的<code>IteratorResult</code>对象的<code>done</code>属性应该为<code>true</code>，<code>value</code>属性应该为传递给<code>return</code>方法的参数（如果有）<br />
调用<code>throw</code>方法表示通知调用方，检测到了错误，参数通常是一个异常对象。<code>throw</code>函数内一般会抛出异常，如果不打算抛出，那么返回的<code>IteratorResult</code>对象的<code>done</code>属性应该为<code>true</code>。</p>
<p><code>IteratorResult</code>对象具有两个属性，<code>done</code>和<code>value</code>。<br />
<code>done</code>属性的值为一个布尔值，表示是否到达迭代器末尾，若为<code>false</code>表示没有到达末尾，此时可以使用本次迭代得到的值。<br />
<code>value</code>属性的值是任意ECMAScript类型值，如果<code>done</code>为<code>false</code>，则<code>value</code>为当前迭代元素值。 如果<code>done</code>为<code>true</code>，则此值为迭代器的返回值（如果提供了，没提供为<code>undefined</code>）。</p>
<p>一个最简单的迭代方法定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="comment">// 返回Iterator对象</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; <span class="comment">// 返回IteratorResult对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对同一个可迭代对象可以创建多个<code>Iterator</code>对象，这些对象彼此之间没有任何关联，一个<code>Iterator</code>对象的遍历过程不应该影响另一个。所以在<code>Symbol.iterator</code>方法中应该使用闭包将当前可迭代对象的状态记录下来。</p>
<p>迭代器不需要知道可迭代对象的元素有多少个，只需要不断调用<code>next()</code>方法取值，直到返回的<code>IteratorResult</code>对象的<code>done</code>属性为<code>true</code>就停止。<br />
使用迭代器的示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = o[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> iteratorResult = iterator.next();</span><br><span class="line"><span class="keyword">while</span>(!iteratorResult.done) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = iteratorResult.value;</span><br><span class="line">  doSomething(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ECMAScript提供的很多语法会自动处理上述过程，仅暴露出每次迭代的<code>value</code>值供用户操作。这些内置语法在退出上下文时如果发现还有元素没有迭代，会自动尝试调用<code>return()</code>方法，之后返回的<code>IteratorResult</code>对象的<code>done</code>属性是否为<code>true</code>取决于<code>return()</code>函数。</p>
<h2 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h2>
<p>生成器是一个函数，它拥有暂停和恢复代码执行的能力。使用生成器可以自定义迭代器和实现协程。<br />
声明一个生成器的语法是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * 函数名(<span class="params">参数</span>) </span>&#123;生成器函数体&#125;</span><br></pre></td></tr></table></figure>
<p>生成器函数表达式的语法是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> *(<span class="params">参数</span>) </span>&#123;生成器函数体&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数不能用来定义生成器函数。</p>
<p>生成器函数返回一个生成器对象，生成器对象实现了<code>Iterable</code>和<code>Iterator</code>接口，因此它也有<code>next()</code>等方法，它的<code>Symbol.iterator</code>方法返回的是自己。<br />
生成器函数内的<code>yield</code>语句可以使得生成器函数暂停运行，并返回<code>yield</code>语句右半部分表达式的求值结果，下一次会从同一个位置恢复运行。通过 <code>yield</code> 关键字退出的生成器函数会处在 <code>done: false</code> 状态；通过 <code>return</code> 关键字退出的生成器函数会处于 <code>done: true</code> 状态。<br />
当调用<code>next()</code>方法时，生成器函数开始运行，一直到遇到第一个<code>yield</code>或<code>return</code>语句，如果是<code>yield</code>语句则暂停函数并返回值。再次调用<code>next()</code>方法时，从之前暂停的位置开始运行直到再次遇到<code>yield</code>或<code>return</code>。如果是<code>return</code>语句则结束函数并返回值。再次调用<code>next()</code>方法时返回<code>&#123;value: undefined, done: true&#125;</code></p>
<p><code>yield</code>语句有三种形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span>;</span><br><span class="line"><span class="keyword">yield</span> AssignmentExpression;</span><br><span class="line"><span class="keyword">yield</span> * IterableObject;</span><br></pre></td></tr></table></figure>
<p><code>yield</code>语句中右半部分表达式的计算结果，会出现在刚调用的<code>next()</code>方法返回的对象里。但<code>yield</code>语句整体的返回值，是下一次调用的<code>next()</code>方法的参数。也就是说，<code>next()</code>方法的参数是目前暂停的<code>yield</code>语句即将返回的值。<br />
由于第一次调用<code>next()</code>方法时，程序没有暂停在<code>yield</code>语句，因此第一次传递的参数没有用处。<br />
<code>yield *</code>表达式右边需要是一个实现了<code>Iterable</code>接口的可迭代对象，此时会对该可迭代对象进行遍历，<code>next()</code>方法返回的是可迭代对象遍历出的<code>IteratorResult</code>对象。<code>yield *</code>表达式整体的返回结果，是此可迭代对象遍历完成（内部<code>done</code>为<code>true</code>）时的<code>value</code>值，对于普通迭代器来说，这个值是 <code>undefined</code>，对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值。<br />
基于<code>yield *</code>容易实现递归的生成器函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* nTimes(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> n - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 输出 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于生成器函数的调用结果是一个<code>Iterator</code>对象，因此在实现迭代器<code>Symbol.iterator</code>时，可以把它写成生成器函数，以便节省书写<code>next()</code>等方法的时间。</p>
<p>生成器对象实现了<code>Iterator</code>接口，它也有<code>return()</code>和<code>throw()</code>方法。<br />
<code>return(val)</code>方法会直接结束生成器函数，并将参数<code>val</code>作为生成器函数的返回值。<code>return</code>方法本身返回一个<code>done</code>属性为<code>true</code>且<code>value</code>属性为参数<code>val</code>的<code>IteratorResult</code>对象。此后对<code>next()</code>方法的调用都将返回<code>&#123;value: undefined, done: true&#125;</code>。<br />
<code>throw(e)</code>方法会向目前暂停的 <code>yield</code>语句抛出异常，如果没有处理则会导致生成器函数退出，如果处理了则会继续运行生成器函数，直到遇到下一个<code>yield</code>语句，将下一个<code>yield</code>语句的表达式的求值结果作为<code>throw(e)</code>函数的返回值返回，和正常调用<code>next()</code>类似。</p>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<p>虽然使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。<br />
为此人们发明了很多种办法，用于创建相同接口的不同对象。</p>
<h2 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h2>
<p>工厂模式就是用函数创建对象，在函数内为其添加属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用时通过调用工厂函数来创建对象。<br />
工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。</p>
<h2 id="构造函数模式"><a class="markdownIt-Anchor" href="#构造函数模式"></a> 构造函数模式</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用时通过<code>new</code>运算符加构造函数调用来创建对象。每个函数都可以作为构造函数。<br />
构造函数模式类似于工厂模式，区别在于没有显式创建对象，属性赋了<code>this</code>值，没有<code>return</code>。按照惯例构造函数名首字母大写。<br />
定义自定义构造函数可以确保实例被标识为特定类型，通过<code>o instanceof Person</code>可以检测实例是否是某个构造函数创建的。<br />
构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。例如<code>person1</code>和<code>person2</code>上的方法<code>sayName</code>不是同一个函数对象。一种改良是将方法定义在全局作用域，对象的属性引用全局作用域中的函数，但问题是一旦方法很多，全局作用域的很多名称就会被占用导致混乱。</p>
<h2 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>构造函数是拥有<code>prototype</code>属性的函数，此属性用于实现原型继承和属性共享。<code>prototype</code>属性指向一个对象，此对象具有自有属性<code>constructor</code>，指向构造函数自身。<br />
每个由<code>new</code>运算符配合构造函数创建的对象，都有一个隐式引用（叫做对象的原型，在规范中名为<code>[[Prototype]]</code>，在浏览器中名为<code>__proto__</code>）指向构造函数的<code>prototype</code>属性值。<code>prototype</code>属性值自身又是一个对象，它也可能有自己的隐式引用，连接到它自己的原型，以此类推，这叫做原型链，原型链最终一般会指向<code>Object.prototype</code>，此对象的隐式引用是<code>null</code>。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210302160529035_4331.png" alt="" width="621" /><br />
在读取一个对象属性时，首先检查对象自有的同名属性，如果对象包含同名属性，引用即指向此属性，如果该对象不包含同名的属性，则下一步检查对象的原型是否包含同名属性，以此类推。<br />
写入属性时只会作为对象的自有属性写入，因此无法在实例上修改其原型拥有的属性的值，强行设置会遮住原型上的属性，因为实例存在查找的同名属性就不会再进一步查找了。<br />
原型模式将实例独自拥有的属性定义在构造函数中，而将所有实例共有的属性定义在构造函数的<code>prototype</code>对象上，由于实例自己不包含<code>sayName</code>属性，因此会继续查找实例的原型上的<code>sayName</code>属性，这一次找到了对应的方法。</p>
<p>为原型逐个添加共有属性的写法十分麻烦，更简便的做法是使用对象字面值。有两种方式：</p>
<ol>
<li><code>Person.prototype = &#123; myMethod()&#123;&#125; &#125;</code></li>
<li><code>Object.assign(Person.prototype, &#123; myMethod()&#123;&#125; &#125;)</code></li>
</ol>
<p>第一种方法用对象字面值直接覆盖原有的<code>prototype</code>对象，这种方式的缺点是无法定义不可枚举的<code>constructor</code>属性。由于使用对象字面值创建的属性特定默认为<code>true</code>，因此还需要将<code>constructor</code>属性的<code>enumerable</code>特性改为<code>false</code>。<br />
第二种方法使用<code>Object.assign</code>将字面值中所有数据属性拷贝过来，更加简洁，但只能拷贝数据属性，不能拷贝访问器属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: Person,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;); <span class="comment">// 没提供的特性默认为false</span></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当覆盖了构造函数的<code>prototype</code>属性后，之前创建的所有实例的隐式引用仍然不变，指向覆盖前的<code>prototype</code>对象，原型链没有被更新。因此覆盖原型这一操作，最好在任何实例创建之前完成。</p>
<p>定义在原型上的<code>Object</code>类型属性容易产生问题，每个实例操作的都是这个唯一的对象，但需求通常是每个实例一个副本。因此最佳实践是，只把方法定义在原型上，其他类型的属性都定义在构造函数内作为实例属性。</p>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p>基于原型模式可以实现继承，只要让子类构造函数的<code>prototype</code>对象的隐式引用连接到父类构造函数的<code>prototype</code>对象上，这样在属性查找时，首先找子类的实例对象，然后是子类构造函数的<code>prototype</code>对象，然后是父类构造函数的<code>prototype</code>对象。<br />
有两种实现方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="title">constructor</span>: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: Sub,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Sub.prototype, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: Sub,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>两种方法的区别在于，第一种方式，子类构造函数的<code>prototype</code>对象没有自有属性。第二种情况，子类构造函数的<code>prototype</code>拥有自有属性，即父类的实例属性，同时还运行了一遍父类构造函数。<br />
示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(People.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;People Walk&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;People Eat&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, no</span>)</span>&#123;</span><br><span class="line">  People.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">  <span class="built_in">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(People.prototype, &#123;</span><br><span class="line">  <span class="title">constructor</span>: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: Person,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Student.prototype.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Student Walk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模式"><a class="markdownIt-Anchor" href="#类模式"></a> 类模式</h2>
<p>ES6提供了对原型模式的包装语法。即<code>class</code>定义。<br />
类语法有两种形式：类声明、类表达式。<br />
在进行类声明时，必须有类名标识符。类声明的类标识符作用域是块级作用域，等价于<code>let</code>变量。<br />
而类表达式时，类名标识符是可选的。类表达式返回的是类名标识符绑定值。<br />
<strong>类名标识符绑定的是类的构造函数</strong>，即<code>标识符 === 标识符.prototype.constructor</code>。<br />
可以通过<code>类名标识符.name</code>访问到字符串形式的类名。<br />
类的构造函数对象的<code>[[FunctionKind]]</code>内部插槽的值为<code>classConstructor</code>，这类函数不能直接调用，必须跟在<code>new</code>运算符之后。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空的类体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 标识符 </span>&#123;  &#125;</span><br><span class="line"><span class="comment">// 继承的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123; 类体 &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 标识符 </span>&#123;</span><br><span class="line">  方法定义<span class="number">1</span></span><br><span class="line">  方法定义<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 标识符 </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> 方法定义<span class="number">1</span></span><br><span class="line">  <span class="keyword">static</span> 方法定义<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法定义有以下几种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名标识符 </span>&#123;</span><br><span class="line">  属性名(参数)&#123;函数体&#125;</span><br><span class="line">  get 属性名()&#123;函数体&#125;</span><br><span class="line">  set 属性名(参数)&#123;函数体&#125;</span><br><span class="line">  * 属性名(参数)&#123;生成器函数体&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>花括号包围的是类体，类体中只能定义方法（ES6），且定义的方法默认都在严格模式执行。<br />
不加<code>static</code>的方法定义在构造函数的<code>prototype</code>对象上，作为原型方法，例如<code>Object.prototype.toString()</code><br />
加<code>static</code>的方法定义在构造函数对象上，例如<code>Object.keys(o)</code><br />
标识符后面可以加<code>extends</code>子句，用于继承，其关键字后面是一个作为父类的构造函数，<code>extends</code>子句会使子类的<code>prototype</code>对象的隐式引用指向父类的<code>prototype</code>对象，使子类构造函数的隐式引用指向父类构造函数的引用。<br />
类的构造函数的方法名是<code>constructor</code>，如果类体中没有定义<code>constructor</code>方法，则会自动创建下面的<code>constructor</code>方法。类体中最多只能有一个构造函数，有多个会抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若没有extends子句</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"> </span>)</span>&#123; &#125;</span><br><span class="line"><span class="comment">// 若有extends子句</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">... args</span>)</span>&#123; <span class="built_in">super</span> (...args);&#125;</span><br></pre></td></tr></table></figure>
<p><code>super</code>关键字作为函数调用时（<code>super()</code>），调用的永远是父类构造函数，且只能用在子类构造函数中，而且在引用<code>this</code>之前（没有返回值时会隐式返回<code>this</code>）必须调用<code>super()</code>，因为<code>super()</code>中会初始化<code>this</code>关键字。<br />
<code>super</code>关键字作为属性访问时，<code>super</code>指向类方法的<code>[[HomeObject]]</code>对象的隐式引用（原型），非<code>static</code>方法的<code>[[HomeObject]]</code>指向类构造函数的<code>prototype</code>对象，<code>static</code>方法的<code>[[HomeObject]]</code>指向类构造函数。</p>
<p>综上，根据原型模型的最佳实践，实例属性定义在构造函数中，共有方法则定义在类体中。</p>
<h3 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h3>
<p>抽象类可以在构造函数中根据<code>new.target</code>的值来阻止被<code>new</code>。<br />
还可以通过<code>this</code>强制继承类必须实现原型方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.foo) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Inheriting class must define foo()&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多层继承"><a class="markdownIt-Anchor" href="#多层继承"></a> 多层继承</h3>
<p>使用函数，接受一个父类参数，返回一个继承参数的类。<br />
形成继承链：A继承B，B继承C，C继承D<br />
很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> FooMixin = <span class="function"><span class="keyword">function</span>(<span class="params">Superclass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function"><span class="keyword">function</span>(<span class="params">Superclass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function"><span class="keyword">function</span>(<span class="params">Superclass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bus继承了一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">FooMixin</span>(<span class="title">BarMixin</span>(<span class="title">BazMixin</span>(<span class="title">Vehicle</span>))) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 如果不想嵌套调用，可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">BaseClass, ...Mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mixins.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, current</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> current(accumulator)</span><br><span class="line">  &#125;, BaseClass)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Vehicle</span>, <span class="title">FooMixin</span>, <span class="title">BarMixin</span>, <span class="title">BazMixin</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="私有变量"><a class="markdownIt-Anchor" href="#私有变量"></a> 私有变量</h2>
<h3 id="实例私有变量"><a class="markdownIt-Anchor" href="#实例私有变量"></a> 实例私有变量</h3>
<p>基于构造函数模式可以创建实例的私有变量，由实例方法访问。将构造函数的参数作为私有变量，将构造函数内的方法作为闭包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      age = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="静态私有变量"><a class="markdownIt-Anchor" href="#静态私有变量"></a> 静态私有变量</h3>
<p>利用IIFE，可以创建静态私有变量，由原型方法访问。<br />
将IIFE作用域内的变量作为静态变量，将IIFE内定义的原型方法作为闭包引用静态变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Account = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> moneyRate = <span class="number">3.5</span>;</span><br><span class="line">  <span class="keyword">let</span> Account = <span class="function"><span class="keyword">function</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getMoney = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> money;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.setMoney = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      name = money;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  Account.prototype.getRate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moneyRate;</span><br><span class="line">  &#125;</span><br><span class="line">  Account.prototype.setRate = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    moneyRate = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Account;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="模块模式"><a class="markdownIt-Anchor" href="#模块模式"></a> 模块模式</h3>
<p>模块模式基本上海是使用IIFE创建私有变量，只是最后返回的不是构造函数，而是返回一个对象，该对象包含所有公有接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">  <span class="comment">// 公共接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">getComponentCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> components.length;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">registerComponent</span>(<span class="params">component</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        components.push(component);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<h1 id="异步编程"><a class="markdownIt-Anchor" href="#异步编程"></a> 异步编程</h1>
<p>JavaScript中有大量异步操作，它不是立刻执行的，而是将来某个时机或满足某个条件后才执行的。例如<code>setTimeout</code>、DOM事件模型中的<code>addEventListener</code>。</p>
<h2 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h2>
<p>最常见的异步代码是接受回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 300毫秒后执行callback</span></span><br><span class="line"><span class="built_in">setTimeout</span>(callback, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 点击按钮后执行callback</span></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, callback)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，上述异步函数的作用仅仅是安排回调函数，而不是执行回调函数中的代码，因此其自身的返回值，和回调函数的返回值完全无关。对异步函数进行try-catch也捕获不到回调函数抛出的异常。<br />
要想获得回调函数的返回值，或者处理回调函数中的错误，需要在回调函数代码内进行操作。例如在完成任务后，调用用于成功处理的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> success = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> failure = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;failure: &quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">if</span>(value &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    success(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    failure(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;less than 0.5&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>如果回调函数需要串联执行，例如执行完任务1后执行任务2，则需要将回调函数嵌套很多层，难以维护。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; ,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> Promise</h2>
<p>嵌套的回调函数难以维护，为了解决这个问题，开发者在异步编程上尝试了各种各样的办法，其中最成功的之一就是Promise。</p>
<p>Promise是一个对象，用作延迟（可能还是异步）计算的最终结果的占位符。<br />
一个Promise对象具有四个属性：</p>
<ul>
<li>状态</li>
<li>结果值</li>
<li>待定转兑现时的处理程序列表</li>
<li>待定转拒绝时的处理程序列表</li>
</ul>
<p>任何Promise对象均处于以下三种互斥状态之一：已兑现(fulfilled)，已拒绝(rejected)和待定(pending)：</p>
<ul>
<li>如果<code>p.then(f, r)</code>立即让Job入队来调用函数<code>f</code>，则Promise<code>p</code>是已兑现的</li>
<li>如果<code>p.then(f, r)</code>立即让Job入队来调用函数<code>r</code>，则Promise<code>p</code>是已拒绝的</li>
<li>如果Promise既不是已兑现的，也不是已解决的，则它是待定的</li>
</ul>
<p><img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210308103253039_2283.png" alt="" width="621" /></p>
<p>如果Promise不是待定的，则被称为确定的(settled)，也就是要么已兑现，要么已拒绝</p>
<p>如果一个Promise是确定的，或者已被“锁定(locked in)”以匹配另一个Promise的状态，则该Promise是已解决的(resolved)。<br />
<strong>尝试解决或拒绝一个已解决的Promise没有任何效果。</strong><br />
如果Promise不是已解决的，则它是未解决的。一个未解决的Promises总是待定状态。一个已解决的Promise可能是待定的，也可能是已兑现的，还可能是已拒绝的。</p>
<p>当promise从待定转为兑现时，依次安排执行相应的处理程序，以处理程序的返回值作为参数调用处理程序所绑定的<code>[[Resolve]]</code>或<code>[[Reject]]</code>。</p>
<h3 id="抽象操作-2"><a class="markdownIt-Anchor" href="#抽象操作-2"></a> 抽象操作</h3>
<p>Promise有几个抽象操作，用户无法直接调用，但Promise类内部在使用。</p>
<p><code>RejectPromise</code>接受一个<code>promise</code>对象和一个<code>reason</code>，它会将此<code>promise</code>的结果值设为<code>reason</code>，然后将<code>promise</code>的状态变更为已拒绝，最后将<code>promise</code>的拒绝处理程序列表中的每个函数排队，使其异步调用。</p>
<p><code>FulfillPromise</code>接受一个<code>promise</code>对象和一个<code>value</code>，它会将此<code>promise</code>的结果值设为<code>value</code>，然后将<code>promise</code>的状态变更为已兑现，最后将<code>promise</code>的兑现处理程序列表中的每个函数排队，使其异步调用。</p>
<p><code>PromiseReactionJob</code>接受一个响应程序<code>reaction</code>和参数<code>argument</code>，它会调用响应程序，将相应程序的返回值作为参数再去调用对应的<code>[[Resolve]]</code>或<code>[[Reject]]</code>方法。</p>
<p><code>PromiseResolveThenableJob</code>接受一个Promise对象<code>promiseToResolve</code>，一个具有<code>then</code>方法的对象<code>thenable</code>，以及它的then方法对应的函数对象<code>then</code>。它会基于<code>promiseToResolve</code>创建<code>[[Resolve]]</code>和<code>[[Reject]]</code>方法，然后调用<code>then.call(thenable, [[Resolve]], [[Reject]])</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RejectPromise</span> (<span class="params"> promise, reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// assert: promise.[[PromiseState]] == &quot;pending&quot;</span></span><br><span class="line">  <span class="keyword">let</span> reactions = promise.[[PromiseRejectReactions]];</span><br><span class="line">  promise.[[PromiseResult]] = reason;</span><br><span class="line">  promise.[[PromiseFulfillReactions]] = <span class="literal">undefined</span>;</span><br><span class="line">  promise.[[PromiseRejectReactions]] = <span class="literal">undefined</span>;</span><br><span class="line">  promise.[[PromiseState]] = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> TriggerPromiseReactions(reactions, reason);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FulfillPromise</span> (<span class="params"> promise, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// assert: promise.[[PromiseState]] == &quot;pending&quot;</span></span><br><span class="line">  <span class="keyword">let</span> reactions = promise.[[PromiseFulfillReactions]];</span><br><span class="line">  promise.[[PromiseResult]] = value;</span><br><span class="line">  promise.[[PromiseFulfillReactions]] = <span class="literal">undefined</span>;</span><br><span class="line">  promise.[[PromiseRejectReactions]] = <span class="literal">undefined</span>;</span><br><span class="line">  promise.[[PromiseState]] = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> TriggerPromiseReactions(reactions, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TriggerPromiseReactions</span> (<span class="params"> reactions, argument </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(reaction <span class="keyword">of</span> reactions) &#123;</span><br><span class="line">    EnqueueJob(<span class="string">&quot;PromiseJobs&quot;</span>, PromiseReactionJob, «‍reaction, argument»)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseReactionJob</span> (<span class="params"> reaction, argument </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promiseCapability = reaction.[[Capabilities]];</span><br><span class="line">  <span class="keyword">let</span> handler = reaction.[[Handler]];</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlerResult = handler(argument);</span><br><span class="line">    promiseCapability.[[Resolve]](handlerResult);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    promiseCapability.[[Reject]](e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseResolveThenableJob</span> (<span class="params"> promiseToResolve, thenable, then</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resolvingFunctions = CreateResolvingFunctions(promiseToResolve);</span><br><span class="line">  <span class="keyword">let</span> thenCallResult = then.call(thenable, resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]]);</span><br><span class="line">  <span class="comment">// Call(then, thenable, «resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]]»)</span></span><br><span class="line">  NextJob Completion(thenCallResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建promise"><a class="markdownIt-Anchor" href="#创建promise"></a> 创建Promise</h3>
<p><strong>第一种方式是使用构造函数：</strong><br />
全局对象的属性<code>Promise</code>是一个构造函数，使用<code>new</code>运算符和此构造函数来创建Promise对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异步任务</span></span><br><span class="line">  <span class="keyword">if</span>(success) resolve(fulfilled_value/<span class="built_in">Promise</span>)</span><br><span class="line">  <span class="keyword">else</span> reject(rejected_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Promise的构造函数中，会同步执行传递的<code>executor</code>函数（但如果出现错误，会调用<code>[[Reject]]</code>来拒绝promise而不是直接抛出，因此无法在构造函数外try-catch到错误）。<code>executor</code>函数里是用户要执行的异步任务。<br />
<code>executor</code>函数接受两个函数<code>resolve</code>和<code>reject</code>，这两个函数是内置函数，它们具有内部属性<code>[[Promise]]</code>关联到当前的promise。<code>executor</code>函数代码中需要调用<code>resolve</code>函数来指示它希望解决关联的Promise对象（可能导致promise兑现、拒绝或者安排新的异步任务执行），调用<code>reject</code>函数来指示拒绝关联的Promise对象，这会导致它永远不会兑现。<br />
调用<code>resolve</code>和<code>reject</code>并不会立即执行处理程序，而只是将处理程序添加到运行队列里等待稍后运行。<br />
这两个函数只在第一次调用才有效果，多次调用除了返回<code>undefined</code>没有其他作用。</p>
<p><code>resolve</code>函数接受一个参数<code>resolution</code>并返回<code>undefined</code>：</p>
<ol>
<li>如果<code>resolution</code>是当前的promise，则返回<code>RejectPromise(promise, new TypeError())</code>。</li>
<li>如果<code>resolution</code>不是对象，则返回<code>FulfillPromise(promise, resolution)</code></li>
<li>如果<code>resolution.then</code>不是函数，则返回<code>FulfillPromise(promise, resolution)</code></li>
<li>如果<code>resolution.then</code>是函数，则安排异步执行<code>PromiseResolveThenableJob(promise, resolution, resolution.then)</code>，然后返回<code>undefined</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> [[<span class="title">Resolve</span>]](<span class="params">resolution</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = resolve.[[<span class="built_in">Promise</span>]];</span><br><span class="line">  <span class="comment">// 执行一次</span></span><br><span class="line">  <span class="keyword">let</span> alreadyResolved = resolve.[[AlreadyResolved]];</span><br><span class="line">  <span class="keyword">if</span>(alreadyResolved) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  alreadyResolved = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// -------</span></span><br><span class="line">  <span class="keyword">if</span>(resolution === promise)</span><br><span class="line">    <span class="keyword">return</span> RejectPromise(promise, <span class="keyword">new</span> <span class="built_in">TypeError</span>());</span><br><span class="line">  <span class="keyword">if</span>(Type(resolution) is not <span class="built_in">Object</span>)</span><br><span class="line">    <span class="keyword">return</span> FulfillPromise(promise, resolution);</span><br><span class="line">  <span class="keyword">let</span> thenAction = resolution[<span class="string">&#x27;then&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> thenAction !== <span class="string">&quot;function&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> FulfillPromise(promise, resolution);</span><br><span class="line">  EnqueueJob (<span class="string">&quot;PromiseJobs&quot;</span>, PromiseResolveThenableJob, «‍promise, resolution, thenAction»);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reject</code>函数接受一个参数<code>reason</code>，并返回<code>undefined</code>。</p>
<ol>
<li>返回<code>RejectPromise(promise, reason)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> [[<span class="title">Reject</span>]](<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = resolve.[[<span class="built_in">Promise</span>]];</span><br><span class="line">  <span class="comment">// 执行一次</span></span><br><span class="line">  <span class="keyword">let</span> alreadyResolved = resolve.[[AlreadyResolved]];</span><br><span class="line">  <span class="keyword">if</span>(alreadyResolved) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  alreadyResolved = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// -------</span></span><br><span class="line">  <span class="keyword">return</span> RejectPromise(promise, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二种方式是使用静态方法：</strong><br />
也可以直接创建一个使用给定reason拒绝的Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(reason);</span><br><span class="line"><span class="comment">// 其源码类似于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this是构造函数constructor</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">this</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以直接创建一个使用给定resolution解决的Promise（前提是resolution不能是Promise）：<br />
如果resolution是一个Promise，那么会直接返回这个resolution而不会去解决它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(resolution);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">resolution</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(IsPromise(resolution) &amp;&amp; resolution.constructor === <span class="built_in">this</span>)</span><br><span class="line">      <span class="keyword">return</span> resolution;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">this</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      resolve(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加处理程序"><a class="markdownIt-Anchor" href="#添加处理程序"></a> 添加处理程序</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.then(onFulfilled , onRejected);</span><br><span class="line"><span class="comment">// 默认的拒绝处理程序</span></span><br><span class="line">p.then(onFulfilled);</span><br><span class="line">  </span><br><span class="line">p.then(<span class="literal">null</span>, onRejected);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">p.catch(onRejected)</span><br><span class="line"><span class="comment">// ES9</span></span><br><span class="line">p.finally(onFinally)</span><br></pre></td></tr></table></figure>
<p><code>onFulfilled</code>是当promise的状态从待定变为已兑现时的处理程序。<br />
<code>onRejected</code>是当promise的状态从待定变为已拒绝时的处理程序。<br />
<code>onFulfilled</code>和<code>onRejected</code>函数接受一个参数，这个参数是当前promise的结果值(resulotion或reason)，然后使用新创建的promise来resolve或reject函数<code>onFulfilled</code>和<code>onRejected</code>的返回值，如果传递的<code>onFulfilled</code>和<code>onRejected</code>不是函数，则它们被设为默认处理程序。<br />
默认的<code>onFulfilled = x =&gt; x</code>，即简单的返回传递的第一个参数。<br />
默认的<code>onRejected = x =&gt; throw x</code>，即简单的将传递的第一个参数作为异常对象抛出。</p>
<p><code>then</code>函数执行以下步骤，返回一个新promise：</p>
<ol>
<li>若当前promise是待定状态，将两个处理程序添加到此promise的的处理程序列表中，以便将来调用。</li>
<li>若当前promise是已兑现状态，异步调用onFulfilled并将当前promise的结果值（兑现值）作为参数传给onFulfilled，将onFulfilled的结果作为参数调用新promise的[[Resolve]]。</li>
<li>若当前promise是已拒绝状态，异步调用onRejected并将当前promise的结果值（拒绝值）作为参数传给onRejected，将onRejected的结果作为参数调用新promise的[[Reject]]。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then(onFulfilled , onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> resultCapability = &#123; [[<span class="built_in">Promise</span>]]: <span class="literal">undefined</span>, [[Resolve]]: <span class="literal">undefined</span>, [[Reject]]: <span class="literal">undefined</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> thenPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resultCapability.[[Resolve]] = resolve;</span><br><span class="line">    resultCapability.[[Reject]] = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  resultCapability.[[<span class="built_in">Promise</span>]] = thenPromise;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    onFulfilled = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">throw</span> v; &#125;</span><br><span class="line">  <span class="keyword">let</span> fulfillReaction = &#123; [[Capabilities]]: resultCapability, [[Handler]]: onFulfilled &#125;;</span><br><span class="line">  <span class="keyword">let</span> rejectReaction = &#123; [[Capabilities]]: resultCapability, [[Handler]]: onRejected&#125;;</span><br><span class="line">  <span class="keyword">switch</span>(promise.[[PromiseState]]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>: &#123;</span><br><span class="line">      promise.[[PromiseFulfillReactions]].push(fulfillReaction);</span><br><span class="line">      promise.[[PromiseRejectReactions]].push(rejectReaction);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">let</span> value = promise.[[PromiseResult]];</span><br><span class="line">      EnqueueJob(<span class="string">&quot;PromiseJobs&quot;</span>, PromiseReactionJob, «‍fulfillReaction, value»);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">let</span> reason = promise.[[PromiseResult]];</span><br><span class="line">      EnqueueJob(<span class="string">&quot;PromiseJobs&quot;</span>, PromiseReactionJob, «‍rejectReaction, reason»);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> thenPromise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  synchronousResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1: invoking resolve()&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2: resolve() returns&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;4: then() handler executes&#x27;</span>));</span><br><span class="line">synchronousResolve();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3: synchronousResolve() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// 1: invoking resolve()</span></span><br><span class="line"><span class="comment">// 2: resolve() returns</span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns</span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<p><strong>串联执行</strong><br />
串联执行异步任务，例如执行完任务1后执行任务2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;))</span><br><span class="line">.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;p3 executor&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;))</span><br><span class="line">.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;p4 executor&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure>
<p><strong>所有异步任务执行完后再执行某任务</strong><br />
<code>Promise.all(iterable)</code>函数返回一个新的promise，这个新的promise使用传递的若干promise组成的兑现值数组来resolve，又或者使用传递的若干promise中第一个拒绝的promise的reason来拒绝。当运行此算法时，它将传递的可迭代对象的所有元素使用<code>Promise.resolve</code>方法解析为Promise，如果传递的可迭代对象没有元素，则返回的Promise等价于<code>Promise.resolve([])</code>。<br />
返回的Promise对象只有在传递给<code>all</code>的所有Promise都已兑现时才会resolve，如果有任何一个已拒绝，则它也会拒绝，如果有任何一个待定，则它也是待定的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all(iterable);</span><br></pre></td></tr></table></figure>
<p><strong>第一个异步任务完成后执行某任务</strong><br />
<code>Promise.race(iterable)</code>函数返回一个新的promise，这个新的promise以和传递的第一个确定的Promise相同的方式确定。当运行此算法时，它将传递的可迭代对象的所有元素使用<code>Promise.resolve</code>方法解析为Promise，如果传递的可迭代对象没有元素，则返回的Promise永远处于待定状态，等同于<code>new Promise(() =&gt; &#123;&#125;)</code>。<br />
返回的Promise对象的状态和结果值，等于传递给<code>race</code>的Promise中最先被兑现或拒绝的那个Promise。</p>
<p><strong>函数合并</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="comment">// 原始合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> addFive(addTwo(addThree(x)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(addTen(<span class="number">7</span>)); <span class="comment">// 17</span></span><br><span class="line"><span class="comment">// 利用Promise的合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(x)</span><br><span class="line">    .then(addTwo)</span><br><span class="line">    .then(addThree)</span><br><span class="line">    .then(addFive);</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 利用Promise结合reduce合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [addTwo, addThree, addFive]</span><br><span class="line">    .reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象出合并函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addTen = compose(addTwo, addThree, addFive);</span><br></pre></td></tr></table></figure>
<h2 id="async和await"><a class="markdownIt-Anchor" href="#async和await"></a> async和await</h2>
<p>基于Promise和生成器函数的暂停与恢复上下文的能力，可以将异步函数写成同步函数的写法，尽管没有增强任何功能，但同步的写法简洁易懂。</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p><code>yield</code>语句中右半部分表达式的计算结果，会出现在刚调用的<code>next()</code>方法返回的对象里。但<code>yield</code>语句整体的返回值，是下一次调用的<code>next()</code>方法的参数。也就是说，<code>next()</code>方法的参数是目前暂停的<code>yield</code>语句即将返回的值。<br />
由于第一次调用<code>next()</code>方法时，程序没有暂停在<code>yield</code>语句，因此第一次传递的参数没有用处。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueDefer</span>(<span class="params">value, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> getValueDefer(<span class="number">5</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> getValueDefer(<span class="number">8</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>; <span class="comment">// 如果有return则最后一次next值为6</span></span><br><span class="line">  <span class="comment">// 没有return则最后一次next值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的生成器函数中，要使<code>x</code>拿到Promise的兑现值，就需要将结果作为参数传给迭代器的<code>next()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = foo();</span><br><span class="line"><span class="comment">// 开始运行函数，拿到的是yield右半部分的求值结果</span></span><br><span class="line"><span class="comment">// 即一个Promise</span></span><br><span class="line"><span class="keyword">let</span> generated = generator.next();</span><br><span class="line"><span class="comment">// foo函数暂停在yield语句，等待下一次next()执行</span></span><br><span class="line">generated.value.then(<span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 此Promise的兑现值为x，需要回传给next()来使foo函数得到该值</span></span><br><span class="line">  <span class="comment">// 再次调用next()使foo函数继续执行到下一个yield</span></span><br><span class="line">  <span class="comment">// 返回下一个yield右半部分的求值结果</span></span><br><span class="line">  generated = generator.next(x);</span><br><span class="line">  generated.value.then(<span class="function">(<span class="params">y</span>)=&gt;</span>&#123;</span><br><span class="line">    generated = generator.next(y);</span><br><span class="line">    <span class="comment">// 每一个yield语句都要then</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，对于生成器函数foo中的每一个yield语句都要调用then方法然后传给next得到的兑现值。这种形式就是语句的递归，整理成函数形式如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> generator = generatorFunction();</span><br><span class="line">  <span class="keyword">let</span> generated = generator.next();</span><br><span class="line">  step();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!generated.done) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(generated);</span><br><span class="line">      generated.value.then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123;</span><br><span class="line">        generated = generator.next(v);</span><br><span class="line">        step();</span><br><span class="line">      &#125;, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        generated = generator.throw(err); <span class="comment">// 参数会作为yield的返回值</span></span><br><span class="line">        step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// generated.value可能是undefined（如果没有return语句，默认值）</span></span><br><span class="line">     <span class="comment">// generated.value也可能是一个值（如果有return语句）</span></span><br><span class="line">     <span class="built_in">console</span>.log(generated.value);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在约定<code>run</code>函数返回一个Promise，其结果值为foo函数的返回值。则进一步改写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> generator = generatorFunction();</span><br><span class="line">    <span class="keyword">let</span> generated = generator.next();</span><br><span class="line">    step();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!generated.done) &#123;</span><br><span class="line">        generated.value.then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果在对yield语句右半部分求值过程中出现了异常</span></span><br><span class="line">            <span class="comment">// 则拒绝此promise，避免一直pending</span></span><br><span class="line">            generated = generator.next(v);</span><br><span class="line">          &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          step();</span><br><span class="line">        &#125;, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            generated = generator.throw(err); <span class="comment">// 参数会作为yield的返回值</span></span><br><span class="line">          &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          step();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// generated.value可能是undefined（如果没有return语句，默认值）</span></span><br><span class="line">       <span class="comment">// generated.value也可能是一个值（如果有return语句）</span></span><br><span class="line">       resolve(generated.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用绑定还可以进一步缩减代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> generator = generatorFunction();</span><br><span class="line">    <span class="keyword">let</span> generated = generator.next();</span><br><span class="line">    step();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">genMethod</span>(<span class="params">prop, v</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        generated = generator[prop](v);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      step();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!generated.done) &#123;</span><br><span class="line">        generated.value.then(genMethod.bind(<span class="literal">null</span>, <span class="string">&#x27;next&#x27;</span>), genMethod.bind(<span class="literal">null</span>, <span class="string">&#x27;throw&#x27;</span>));</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// generated.value可能是undefined（如果没有return语句，默认值）</span></span><br><span class="line">       <span class="comment">// generated.value也可能是一个值（如果有return语句）</span></span><br><span class="line">       resolve(generated.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">qux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<p>ES8提供了将异步函数写成同步写法的简便语法：<br />
使用<code>async</code>关键字将这类函数与生成器函数区分开。<br />
不再使用<code>yield</code>而是使用关键字<code>await</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> getValueDefer(<span class="number">5</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> getValueDefer(<span class="number">8</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>; <span class="comment">// 如果有return则最后一次next值为6</span></span><br><span class="line">  <span class="comment">// 没有return则最后一次next值为undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES8</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">await</span> getValueDefer(<span class="number">5</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">await</span> getValueDefer(<span class="number">8</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意所有<code>async</code>函数返回的都是Promise。因此<code>return await</code>语句没有意义，因为你在接受返回值的时又要<code>await</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">myFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = myFunc(); <span class="comment">// result是Promise，它是a的包装</span></span><br><span class="line"><span class="keyword">let</span> realResult = <span class="keyword">await</span> myFunc();</span><br></pre></td></tr></table></figure>
<p>所以直接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">myFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> myFunc();</span><br></pre></td></tr></table></figure>
<p><code>await</code>语句只能在<code>async</code>函数中使用。同时<code>async</code>函数的特质不会扩展到它内部的嵌套函数，因此，await 关键字也只能直接出现在异步函数的定义中。<br />
如果想在顶层上下文使用<code>await</code>，只能包装一层IIFE：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db;</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;db = <span class="keyword">await</span> open();&#125;)();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这种写法将导致Promise串联执行</span></span><br><span class="line">  <span class="comment">// 总共耗费1000+2000+3000=6000毫秒</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  <span class="keyword">await</span> getValueDefer(<span class="number">5</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">await</span> getValueDefer(<span class="number">6</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">await</span> getValueDefer(<span class="number">8</span>, <span class="number">3000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  <span class="comment">// 这种也是</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> getValueDefer(<span class="number">8</span>, i*<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这种写法让所有Promise几乎同时开始</span></span><br><span class="line">  <span class="comment">// 然后依次等p1、p2、p3返回</span></span><br><span class="line">  <span class="comment">// 总共耗费3000毫秒</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  <span class="keyword">let</span> p1 = getValueDefer(<span class="number">5</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> p2 = getValueDefer(<span class="number">6</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> p3 = getValueDefer(<span class="number">8</span>, <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">await</span> p1;</span><br><span class="line">  <span class="keyword">await</span> p2;</span><br><span class="line">  <span class="keyword">await</span> p3;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个for循环中的串行的Promise语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">let</span> data <span class="keyword">of</span> stream</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代理和反射"><a class="markdownIt-Anchor" href="#代理和反射"></a> 代理和反射</h1>
<p>ECMAScript 6 新增的代理和反射为开发者提供了拦截并向ECMAScript内置基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。<br />
类似于访问器属性拦截了赋值运算符对属性的设置值，也拦截了直接取属性值，需要在访问器函数内执行一些操作后才会返回结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"><span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetObj, handler);</span><br></pre></td></tr></table></figure>
<p>每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。<br />
捕获器可以完全由用户手写，也可以直接利用内置操作的函数，这些内置操作的函数被放在了<code>Reflect</code>全局对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="built_in">Reflect</span>.get</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, <span class="built_in">Reflect</span>);</span><br></pre></td></tr></table></figure>
<p>按照ECMAScript规则，捕获器的编写也不是完全自由的，它必须遵守一系列不变式。</p>
<h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArray = arr.map(<span class="function"><span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// return element for newArray, after executing something</span></span><br><span class="line">&#125;[, thisArg]);</span><br><span class="line"><span class="keyword">let</span> newArray = arr.filter(<span class="function"><span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// return element for newArray, if true</span></span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure>
<h1 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h1>
<p>P50<br />
技术上，这个由 Symbol.iterator 函数生成的对象应该通过其 next()方法陆续返回值。可以通过显式地调用 next()方法返回，也可以隐式地通过生成器函数返回：</p>
<h1 id="常用库函数"><a class="markdownIt-Anchor" href="#常用库函数"></a> 常用库函数</h1>
<ul>
<li>判断是否是有限值（非NaN、正负无穷）：isFinite(v)，注意v会被ToNumber转换为数字</li>
<li>判断是否是NaN：isNaN(v)，注意v会被ToNumber转换为数字</li>
<li>判断是否存在指定属性键的自有属性：Object.prototype.hasOwnProperty(propertyName)</li>
<li>将一个值转换为<code>Number</code>类型：使用一元<code>+</code>运算符</li>
<li>将一个值转换为<code>Boolean</code>类型：使用两次逻辑非运算符。</li>
<li>将一个值转换为32位有符号整数：使用两次按位取反运算符。或者使用有符号右移运算符，移位量为0。</li>
<li>将一个值转换为32位无符号整数：使用无符号右移运算符，移位量为0。</li>
</ul>
<h2 id="stringraw-template-substitutions"><a class="markdownIt-Anchor" href="#stringraw-template-substitutions"></a> String.raw( template , …substitutions )</h2>
<p>此函数使用模板字面值来传递参数，返回不转义的模板字面值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span>(<span class="params">template, ...substitutions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> template.raw[<span class="number">0</span>] + substitutions.map(<span class="function">(<span class="params">sub, index</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;sub&#125;</span><span class="subst">$&#123;template.raw[index + <span class="number">1</span>]&#125;</span>`</span>).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="objectprototypeisprototypeof-v"><a class="markdownIt-Anchor" href="#objectprototypeisprototypeof-v"></a> Object.prototype.isPrototypeOf ( V )</h2>
<p>用来检查当前对象是否在V的原型链上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf = <span class="function"><span class="keyword">function</span>(<span class="params">V</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    V = V.__proto__;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> === V) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(V !== <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="objectprototypepropertyisenumerable-v"><a class="markdownIt-Anchor" href="#objectprototypepropertyisenumerable-v"></a> Object.prototype.propertyIsEnumerable ( V )</h2>
<p>当对象具有属性键为<code>V</code>的可枚举的自有属性时返回<code>true</code>，否则返回<code>false</code></p>
<h2 id="获取对象属性键"><a class="markdownIt-Anchor" href="#获取对象属性键"></a> 获取对象属性键</h2>
<h3 id="for-in语句-2"><a class="markdownIt-Anchor" href="#for-in语句-2"></a> for-in语句</h3>
<h3 id="objectgetownpropertynamesobject"><a class="markdownIt-Anchor" href="#objectgetownpropertynamesobject"></a> Object.getOwnPropertyNames(object)</h3>
<p>获取<code>object</code>对象的所有 自有、字符串属性键。<br />
返回一个数组，元素先是按照数字升序排列的整数索引（注意整数索引也是字符串），然后是按照创建顺序排列的其他字符串。</p>
<h3 id="objectgetownpropertysymbolsobject"><a class="markdownIt-Anchor" href="#objectgetownpropertysymbolsobject"></a> Object.getOwnPropertySymbols(object)</h3>
<p>获取<code>object</code>对象的所有Symbol属性键。<br />
返回一个数组，元素是按照创建顺序排列的Symbol</p>
<h3 id="objectgetownpropertydescriptorsobject"><a class="markdownIt-Anchor" href="#objectgetownpropertydescriptorsobject"></a> Object.getOwnPropertyDescriptors(object)</h3>
<p>获取<code>object</code>对象的所有属性键（包括字符串和Symbol），及其对应的属性描述符。<br />
返回一个对象，其键是<code>object</code>的属性键，值是此属性键对应的属性描述符。</p>
<h3 id="reflectownkeysobject"><a class="markdownIt-Anchor" href="#reflectownkeysobject"></a> Reflect.ownKeys(object)</h3>
<p>获取<code>object</code>对象的所有属性键（包括字符串和Symbol）。<br />
返回一个数组，元素先是按照数字升序排列的整数索引（注意整数索引也是字符串），然后是按照创建顺序排列的其他字符串，最后是按照创建顺序排列的Symbol。</p>
<h3 id="objectkeysobject"><a class="markdownIt-Anchor" href="#objectkeysobject"></a> Object.keys(object)</h3>
<p>获取<code>object</code>对象的所有自有、可枚举、字符串属性键。默认顺序先是整数索引，然后是其他字符串属性键。最终顺序要求和for-in语句的遍历顺序一致。</p>
<h3 id="objectentriesobject"><a class="markdownIt-Anchor" href="#objectentriesobject"></a> Object.entries(object)</h3>
<p>获取<code>object</code>对象的所有自有、可枚举、字符串属性键和对应的值。默认顺序先是整数索引，然后是其他字符串属性键。最终顺序要求和for-in语句的遍历顺序一致。<br />
返回一个数组，其元素都是两个元素数组，第一个元素为字符串属性键，第二个元素为对应的属性值。</p>
<h2 id="获取对象属性值"><a class="markdownIt-Anchor" href="#获取对象属性值"></a> 获取对象属性值</h2>
<h3 id="objectvaluesobject"><a class="markdownIt-Anchor" href="#objectvaluesobject"></a> Object.values(object)</h3>
<p>获取<code>object</code>对象的所有自有、可枚举、字符串属性键对应的值。默认顺序先是整数索引，然后是其他字符串属性键。最终顺序要求和for-in语句的遍历顺序一致。<br />
返回一个数组，其值是属性值。</p>
<h2 id="获取对象属性的特性"><a class="markdownIt-Anchor" href="#获取对象属性的特性"></a> 获取对象属性的特性</h2>
<h3 id="objectgetownpropertydescriptorobject-propname"><a class="markdownIt-Anchor" href="#objectgetownpropertydescriptorobject-propname"></a> Object.getOwnPropertyDescriptor(object, propName)</h3>
<p>获取<code>object</code>对象的<code>propName</code>属性键对应的属性描述符。<br />
返回一个属性描述符对象。</p>
<h3 id="objectgetownpropertydescriptorsobject-2"><a class="markdownIt-Anchor" href="#objectgetownpropertydescriptorsobject-2"></a> Object.getOwnPropertyDescriptors(object)</h3>
<p>获取<code>object</code>对象的所有属性键（包括字符串和Symbol），及其对应的属性描述符。<br />
返回一个对象，其键是<code>object</code>的属性键，值是此属性键对应的属性描述符。</p>
<h2 id="获取对象原型"><a class="markdownIt-Anchor" href="#获取对象原型"></a> 获取对象原型</h2>
<p><code>obj.__proto__</code><br />
<code>Object.getPrototypeOf(obj)</code></p>
<h2 id="设置新的原型"><a class="markdownIt-Anchor" href="#设置新的原型"></a> 设置新的原型</h2>
<p><code>Object.setPrototype(obj, proto)</code><br />
将对象<code>obj</code>的隐式引用重新设置为<code>proto</code>，注意这个操作很影响性能。</p>
<h2 id="基于原型创建对象"><a class="markdownIt-Anchor" href="#基于原型创建对象"></a> 基于原型创建对象</h2>
<p><code>Object.create(proto)</code><br />
返回一个对象，其隐式引用被设置为<code>proto</code></p>
<h2 id="检查是否存在属性"><a class="markdownIt-Anchor" href="#检查是否存在属性"></a> 检查是否存在属性</h2>
<p>检查是否存在自有属性：<code>Object.prototype.hasOwnProperty(prop)</code><br />
检查是否存在自有属性和继承属性：<code>prop in obj</code></p>
<h2 id="合并对象"><a class="markdownIt-Anchor" href="#合并对象"></a> 合并对象</h2>
<h3 id="objectassign-target-sources"><a class="markdownIt-Anchor" href="#objectassign-target-sources"></a> Object.assign ( target, …sources )</h3>
<p>将每个源对象<code>source</code>的自有且可枚举属性（属性键顺序依次为整数索引、字符串、Symbol）的值，复制到目标对象<code>target</code>使其具有相同的属性键和值。<br />
如果正在操作的属性是访问器属性，那么读取源对象的值使用的是<code>[[Get]]</code>，复制到目标对象时使用的是<code>[[Set]]</code>。<br />
如果多个源对象具有相同的属性键，那么最后一个源对象的属性会覆盖前面的。<br />
如果复制过程中出现错误（例如<code>[[Get]]</code>或<code>[[Set]]</code>抛出了异常），那么此函数会中止，前面的已完成复制操作不会回滚。</p>
<h2 id="关系比较"><a class="markdownIt-Anchor" href="#关系比较"></a> 关系比较</h2>
<h3 id="objectis"><a class="markdownIt-Anchor" href="#objectis"></a> <a target="_blank" rel="noopener" href="http://Object.is">Object.is</a>(value1, value2)</h3>
<p>此函数类似于严格相等运算符，但是没有严格相等运算符中<code>Number</code>类型的例外：</p>
<ul>
<li>两个操作数都是<code>NaN</code>，返回<code>true</code></li>
<li><code>+0</code>和<code>-0</code>是不相等的。</li>
</ul>
<h2 id="字符串转数字"><a class="markdownIt-Anchor" href="#字符串转数字"></a> 字符串转数字</h2>
<p>对于String类型，parseFloat和Number基本上类似，区别在于：</p>
<ul>
<li>Number忽略的是前导和后缀的空白符，而parseFloat忽略的是前导空白符和任意的不匹配后缀</li>
<li>Number对于空串或只包含空白符的串会返回<code>+0</code>，而parseFloat会返回<code>NaN</code></li>
<li>Number可以解析二进制、八进制、十六进制，parseFloat只能解析十进制</li>
</ul>
<h3 id="number-v"><a class="markdownIt-Anchor" href="#number-v"></a> Number ([v])</h3>
<p>返回一个数字值。<br />
如果参数是数字值，则不转换。<br />
如果没有传递参数，或者参数为Null，返回<code>+0</code>。<br />
如果参数是Undefined，返回NaN<br />
如果参数是布尔值，true返回1，false返回0<br />
如果参数是Symbol，抛出异常。<br />
如果参数是Object，若<code>v.valueOf()</code>存在结果不是<code>Object</code>，则返回<code>Number(v.valueOf())</code>，否则返回<code>Number(v.toString())</code><br />
如果参数是字符串，若整个字符串能匹配下图的文法，则返回对应的数字值（空串或者只包含空白符转换为<code>+0</code>）。如果不能匹配，则返回NaN。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210201144755265_6655.png" alt="" width="621" /></p>
<h3 id="parseint-string-radix"><a class="markdownIt-Anchor" href="#parseint-string-radix"></a> parseInt (string, radix)</h3>
<p>返回一个整数值。</p>
<p>parseInt会<code>ToString(string)</code>保证第一个参数为字符串，然后忽略字符串前导的空白符，也会忽略从第一个不是特定进制合法符号的字符开始往后的所有字符。<br />
字符串必须是特定进制合法的符号，例如12进制只能有<code>0-9a-bA-B</code>，唯一的例外是16进制，16进制可以有前缀<code>0x</code>或<code>0X</code>。<br />
进制基数首先被<code>ToInt32</code>转换为一个32为有符号整数，转换结果要求在2-36之间，否则返回<code>NaN</code>。唯一的例外是转换结果为<code>0</code>（例如undefined），会根据字符串是否有前缀<code>0x</code>或<code>0X</code>将进制基数转换为16或10。<br />
如果去掉字符串前导空白符，以及表示符号的正负号，还有16进制下可能的前缀<code>0x</code>或<code>0X</code>，再去掉后面不是特定进制的合法符号的字符，得到的是空串，则返回<code>NaN</code>。<br />
其他情况就正常解析特定进制的数字。</p>
<h3 id="parsefloat-string"><a class="markdownIt-Anchor" href="#parsefloat-string"></a> parseFloat (string)</h3>
<p>返回一个 Number 值。</p>
<p>parseFloat将字符串解析为十进制字面值，首先使用<code>ToString(string)</code>保证第一个参数为字符串，然后忽略字符串前导的空白符。<br />
然后按照下图找到<code>string</code>的最长前缀，并解析为相应的 Number。<br />
如果<code>string</code>的任何前缀都不能匹配下图，则返回<code>NaN</code>。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210201170210094_14393.png" alt="" width="621" /></p>
<h2 id="转字符串"><a class="markdownIt-Anchor" href="#转字符串"></a> 转字符串</h2>
<p>将一种类型转换为字符串有三种办法：<br />
v.toString()<br />
String(v)<br />
“”+v</p>
<h3 id="tostring"><a class="markdownIt-Anchor" href="#tostring"></a> toString()</h3>
<p>除了Undefined和Null以外的类型都有toString方法，一般都不接受参数。<br />
对于Boolean类型，返回的是<code>&quot;true&quot;</code>或<code>&quot;false&quot;</code><br />
对于Symbol类型，返回的是<code>&quot;Symbol(描述)&quot;</code><br />
对于String类型，返回的是自己的拷贝。<br />
对于Object类型，一些标准内置对象（Function、Error、Date、RegExp、Array）实现了自己单独的toString，例外Date对象返回时间字符串，如果没有实现单独的toString，默认返回<code>&quot;[Object object]&quot;</code><br />
对于Number类型，它是唯一的例外，可以接受可选的参数radix表示进制基数（只能在2-36之间，如果不传递默认为10），用于将数字转换为特定进制基数下的表示字符串。</p>
<p>19.1.3.6 Object.prototype.toString ( )<br />
19.2.3.5 Function.prototype.toString ( )<br />
19.3.3.2 Boolean.prototype.toString ( )<br />
19.4.3.2 Symbol.prototype.toString ( )<br />
19.5.3.4 Error.prototype.toString ( )<br />
20.1.3.6 Number.prototype.toString ( [ radix ] )<br />
20.3.4.41 Date.prototype.toString ( )<br />
21.1.3.23 String.prototype.toString ( )<br />
21.2.5.14 RegExp.prototype.toString ( )<br />
22.1.3.27 Array.prototype.toString ( )</p>
<h3 id="string-v"><a class="markdownIt-Anchor" href="#string-v"></a> String ( [v] )</h3>
<p>返回一个字符串值。<br />
如果没有传递参数，返回空串<code>&quot;&quot;</code>。<br />
如果参数为Null，返回<code>&quot;null&quot;</code>。<br />
如果参数是Undefined，返回<code>&quot;undefined&quot;</code><br />
其他情况返回<code>v.toString()</code></p>
<h1 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h1>
<p>JavaScript采用垃圾回收机制，由执行环境而不是用户自己负责清理不再使用的内存空间。<br />
垃圾回收程序周期性运行，由于某块内存是否还有用，属于不可判定问题，垃圾回收并不是太完美的解决方案。<br />
垃圾回收程序跟踪记录哪个变量会使用，哪个变量不会使用，以便回收内存。浏览器用到过两种标记变量的方式：标记清理、引用计数。<br />
执行垃圾回收不可避免的影响性能，由于垃圾回收运行的时间是无法预计的，因此必须保证无论何时运行垃圾回收程序，都必须尽快结束。<br />
现代垃圾回收程序基本上是根据已分配对象的大小和数量来决定何时运行</p>
<h2 id="标记清理"><a class="markdownIt-Anchor" href="#标记清理"></a> 标记清理</h2>
<p>标记清理(mark-and-sweep)是指，当变量进入上下文时，为变量加上存在于上下文中的标记，在变量离开上下文时加上离开标记。上下文中的变量不应该被清理。<br />
垃圾回收程序首先标记所有变量，然后把在上下文中的变量、以及被上下文变量引用的变量的标记去掉，此时剩下的带有标记的变量就是需要清理的了。</p>
<h2 id="引用计数"><a class="markdownIt-Anchor" href="#引用计数"></a> 引用计数</h2>
<p>引用计数(reference counting)是指，对每个值记录它被引用的次数。变量初次声明并被初始化时，引用计数为1，如果之后被赋值给另一个变量，则引用计数加1，如果引用该值的变量被其他值覆盖了，引用计数减1。当引用计数为0时，说明没办法访问到这个值了。<br />
垃圾回收程序清理所有引用计数为0的变量。<br />
引用计数的一大问题是可能存在循环引用，变量A的属性持有变量B，变量B的属性持有变量A，离开作用域后它们的引用计数仍是2，不会被释放。<br />
IE8和之前的IE版本，并非所有对象都是JavaScript的原生对象，例如BOM的DOM对象是C++实现的组件对象模型，组件对象模型使用引用计数实现垃圾回收，因此这些版本的IE虽然使用了标记清理，但只清理掉了原生对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject;</span><br></pre></td></tr></table></figure>
<p>上面的例子是DOM元素的内存永远不会释放。</p>
<h2 id="优化性能"><a class="markdownIt-Anchor" href="#优化性能"></a> 优化性能</h2>
<ol start="0">
<li>不要过早考虑优化，只有在性能出现问题时才考虑以下方法。</li>
<li>局部变量在超出作用域后会被自动释放，而对于全局变量，如果不再需要，最好手动设置为<code>null</code></li>
<li>使用const和let声明变量，由于它们以块为作用域，比函数作用域退出的更早，垃圾回收程序也会更早的回收</li>
<li>某些引擎会让<code>new</code>出的多个对象共享相同的隐藏类，只要不再创建对象后添加新属性或删除旧属性。因此最好一次性声明所有要用到的字段，某个对象不使用的字段可以赋为<code>null</code>而不是删除。</li>
<li>谨慎使用闭包，因为闭包可能一直引用着外部变量。</li>
<li>如果一个函数内对象被创建后很快就返回了，浏览器可能会更频繁的安排垃圾回收。可以使用一个已存在的对象进行修改，又或者使用一个对象池。</li>
</ol>
<h1 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h1>
<p>只有在执行函数后才会加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod = awawit <span class="keyword">import</span>(<span class="string">&#x27;https://unpkg.com/htm?module&#x27;</span>)</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/JavaScript高级程序设计.html">https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/JavaScript高级程序设计.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E8%AF%AD%E8%A8%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"><i class="fa fa-chevron-left">  </i><span>常见问题</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/Qustion.html"><span>Qustion</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>