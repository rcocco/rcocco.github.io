<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript基础"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>JavaScript基础 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text"> 介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">2.</span> <span class="toc-text"> 历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text"> 标识符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">4.</span> <span class="toc-text"> 注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text"> 严格模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text"> 运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text"> 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">6.2.</span> <span class="toc-text"> 执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83"><span class="toc-number">6.3.</span> <span class="toc-text"> 词法环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.4.</span> <span class="toc-text"> 任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">7.</span> <span class="toc-text"> 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E5%A3%B0%E6%98%8E"><span class="toc-number">7.1.</span> <span class="toc-text"> var声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E5%92%8Cconst%E5%A3%B0%E6%98%8E"><span class="toc-number">7.2.</span> <span class="toc-text"> let和const声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%A3%B0%E6%98%8E"><span class="toc-number">7.3.</span> <span class="toc-text"> 全局声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.4.</span> <span class="toc-text"> 最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%91%E5%AE%9A"><span class="toc-number">7.5.</span> <span class="toc-text"> 解构绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E7%BB%91%E5%AE%9A"><span class="toc-number">7.5.1.</span> <span class="toc-text"> 对象解构绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E7%BB%91%E5%AE%9A"><span class="toc-number">7.5.2.</span> <span class="toc-text"> 数组解构绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text"> 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">8.1.</span> <span class="toc-text"> Undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-number">8.2.</span> <span class="toc-text"> Null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boolean"><span class="toc-number">8.3.</span> <span class="toc-text"> Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">8.4.</span> <span class="toc-text"> String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">8.4.1.</span> <span class="toc-text"> 字符串字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">8.4.2.</span> <span class="toc-text"> 模板字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#symbol"><span class="toc-number">8.5.</span> <span class="toc-text"> Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#number"><span class="toc-number">8.6.</span> <span class="toc-text"> Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bigint"><span class="toc-number">8.7.</span> <span class="toc-text"> BigInt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">8.8.</span> <span class="toc-text"> Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%A7%BD"><span class="toc-number">8.8.1.</span> <span class="toc-text"> 内部槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">8.8.2.</span> <span class="toc-text"> 属性的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.8.3.</span> <span class="toc-text"> 创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE"><span class="toc-number">8.8.4.</span> <span class="toc-text"> 属性访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%B1%9E%E6%80%A7%E7%89%B9%E6%80%A7"><span class="toc-number">8.8.5.</span> <span class="toc-text"> 改变属性特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.9.</span> <span class="toc-text"> 包装类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text"> 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">9.1.</span> <span class="toc-text"> 优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.</span> <span class="toc-text"> 抽象操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typev"><span class="toc-number">9.2.1.</span> <span class="toc-text"> Type(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toprimitivev-hint-default"><span class="toc-number">9.2.2.</span> <span class="toc-text"> ToPrimitive(v, hint &#x3D; ‘default’)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tostringv"><span class="toc-number">9.2.3.</span> <span class="toc-text"> ToString(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tonumericv"><span class="toc-number">9.2.4.</span> <span class="toc-text"> ToNumeric(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tonumberv"><span class="toc-number">9.2.5.</span> <span class="toc-text"> ToNumber(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tointegerv"><span class="toc-number">9.2.6.</span> <span class="toc-text"> ToInteger(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tolengthv"><span class="toc-number">9.2.7.</span> <span class="toc-text"> ToLength(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toint32v"><span class="toc-number">9.2.8.</span> <span class="toc-text"> ToInt32(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#touint32v"><span class="toc-number">9.2.9.</span> <span class="toc-text"> ToUInt32(v)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tobooleanv"><span class="toc-number">9.2.10.</span> <span class="toc-text"> ToBoolean(v)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.3.</span> <span class="toc-text"> 一元运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">9.3.1.</span> <span class="toc-text"> typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete"><span class="toc-number">9.3.2.</span> <span class="toc-text"> delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void"><span class="toc-number">9.3.3.</span> <span class="toc-text"> void</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E"><span class="toc-number">9.3.4.</span> <span class="toc-text"> 递增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%87%8F"><span class="toc-number">9.3.5.</span> <span class="toc-text"> 递减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%8A%A0"><span class="toc-number">9.3.6.</span> <span class="toc-text"> 一元加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%8F"><span class="toc-number">9.3.7.</span> <span class="toc-text"> 一元减</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.4.</span> <span class="toc-text"> 位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D"><span class="toc-number">9.4.1.</span> <span class="toc-text"> 按位取反</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="toc-number">9.4.2.</span> <span class="toc-text"> 按位与</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96"><span class="toc-number">9.4.3.</span> <span class="toc-text"> 按位或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="toc-number">9.4.4.</span> <span class="toc-text"> 按位异或</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.5.</span> <span class="toc-text"> 移位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB"><span class="toc-number">9.5.1.</span> <span class="toc-text"> 左移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="toc-number">9.5.2.</span> <span class="toc-text"> 算术右移&#x2F;有符号右移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="toc-number">9.5.3.</span> <span class="toc-text"> 逻辑右移&#x2F;无符号右移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.6.</span> <span class="toc-text"> 逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="toc-number">9.6.1.</span> <span class="toc-text"> 逻辑非</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E"><span class="toc-number">9.6.2.</span> <span class="toc-text"> 逻辑与</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%88%96"><span class="toc-number">9.6.3.</span> <span class="toc-text"> 逻辑或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6"><span class="toc-number">9.6.4.</span> <span class="toc-text"> 空值合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E6%80%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.7.</span> <span class="toc-text"> 乘性运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95"><span class="toc-number">9.7.1.</span> <span class="toc-text"> 乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95"><span class="toc-number">9.7.2.</span> <span class="toc-text"> 除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E4%BD%99"><span class="toc-number">9.7.3.</span> <span class="toc-text"> 取余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0"><span class="toc-number">9.7.4.</span> <span class="toc-text"> 指数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%80%A7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.8.</span> <span class="toc-text"> 加性运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95"><span class="toc-number">9.8.1.</span> <span class="toc-text"> 加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%B3%95"><span class="toc-number">9.8.2.</span> <span class="toc-text"> 减法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.9.</span> <span class="toc-text"> 关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E4%BA%8E"><span class="toc-number">9.9.1.</span> <span class="toc-text"> 小于(&lt;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8E"><span class="toc-number">9.9.2.</span> <span class="toc-text"> 大于(&gt;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E"><span class="toc-number">9.9.3.</span> <span class="toc-text"> 小于等于(&lt;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E"><span class="toc-number">9.9.4.</span> <span class="toc-text"> 大于等于(&gt;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">9.9.5.</span> <span class="toc-text"> instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in"><span class="toc-number">9.9.6.</span> <span class="toc-text"> in</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.10.</span> <span class="toc-text"> 相等运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89"><span class="toc-number">9.10.1.</span> <span class="toc-text"> 相等(&#x3D;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89"><span class="toc-number">9.10.2.</span> <span class="toc-text"> 不等(!&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89"><span class="toc-number">9.10.3.</span> <span class="toc-text"> 严格相等(&#x3D;&#x3D;&#x3D;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86nan%E4%B8%8E0%E7%9A%84%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89"><span class="toc-number">9.10.4.</span> <span class="toc-text"> 处理NaN与0的严格相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E4%B8%8D%E7%AD%89"><span class="toc-number">9.10.5.</span> <span class="toc-text"> 严格不等(!&#x3D;&#x3D;)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.11.</span> <span class="toc-text"> 条件运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.12.</span> <span class="toc-text"> 赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">9.12.1.</span> <span class="toc-text"> 解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">9.12.1.1.</span> <span class="toc-text"> 对象解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">9.12.1.2.</span> <span class="toc-text"> 数组解构赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.13.</span> <span class="toc-text"> 逗号运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.14.</span> <span class="toc-text"> new运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.15.</span> <span class="toc-text"> 可选链运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.</span> <span class="toc-text"> 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.1.</span> <span class="toc-text"> 空语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debugger%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.2.</span> <span class="toc-text"> debugger语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.3.</span> <span class="toc-text"> 块语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.4.</span> <span class="toc-text"> if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.5.</span> <span class="toc-text"> do-while语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.6.</span> <span class="toc-text"> while语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.7.</span> <span class="toc-text"> for语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83-2"><span class="toc-number">10.7.1.</span> <span class="toc-text"> 词法环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.8.</span> <span class="toc-text"> for-in语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-of%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.9.</span> <span class="toc-text"> for-of语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.10.</span> <span class="toc-text"> with语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.11.</span> <span class="toc-text"> switch语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.12.</span> <span class="toc-text"> 标签语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.13.</span> <span class="toc-text"> break和continue语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#return%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.14.</span> <span class="toc-text"> return语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.15.</span> <span class="toc-text"> throw语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.16.</span> <span class="toc-text"> try语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text"> 异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.</span> <span class="toc-text"> 回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">11.1.1.</span> <span class="toc-text"> 处理返回值和异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.2.</span> <span class="toc-text"> 串联执行回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">11.2.</span> <span class="toc-text"> Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text"> async函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">12.</span> <span class="toc-text"> 执行保存在字符串中的代码</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">187</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">JavaScript基础</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/">JavaScript语言</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1>
<p>通常所说的JavaScript实现包括三部分：</p>
<ol>
<li>核心（ECMAScript）：由ECMA-262定义并提供核心功能</li>
<li>文档对象模型（DOM）：提供与网页内容交互的方法和接口</li>
<li>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口</li>
</ol>
<span id="more"></span>
<p>ECMAScript是ECMA-262标准定义的语言，ECMA-262将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。<br />
Web浏览器只是ECMAScript实现的宿主环境之一，宿主环境提供ECMAScript的基准实现和环境自身交互必需的扩展，扩展（比如DOM）使用ECMAScript核心类型和语法，提供特定于环境的额外功能。<br />
其他宿主环境还有诸如Flash（实现为ActionScript）、服务器端（实现为Node.js）</p>
<p>ECMA-262定义了：</p>
<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>全局对象</li>
</ul>
<h1 id="历史"><a class="markdownIt-Anchor" href="#历史"></a> 历史</h1>
<p>目前最新的ECMA标准定义了 ECMAScript 2020 语言，它是ECMAScript 语言规范的第11版。<br />
ECMAScript语言规范始于1996年11月。</p>
<ol>
<li>1997年6月发布了ECMA标准的第一版。</li>
<li>1998年6月发布了ECMA标准的第二版，它和第一版几乎没有区别，只是为了与国际标准组织保持一致。</li>
<li>1999年12月发布了ECMA标准的第三版，引入了强大的正则表达式，更好的字符串处理，新的控制语句，try-catch异常处理，更严格的错误定义，数字输出的格式化以及其他小的更改。从这个版本开始，它已经成为了几乎所有浏览器都支持的编程语言，并得到了广泛的采用。</li>
<li>ECMA标准没有发布过第四版，因为这个版本非常激进，很多地方不兼容第三版导致了各种争议，同时缺乏浏览器厂商的支持，最终被放弃。但其中一些改动已合并到了第六版。</li>
<li>2009年12月发布了ECMA标准的第五版，增加了访问器属性，对象的反射式创建和检查，对属性特性的编程控制，额外的数组操作函数，对JSON对象编码格式的支持，用于加强错误检查和程序安全性的严格模式。2011年6月发布了5.1版本，它只对第五版做了很小的修正。</li>
<li>2015年6月发布了ECMA标准的第六版，第六版实际上是15年努力的结晶。新增了模块、类声明、词法块级作用域、迭代器、生成器、用于异步编程的Promise、解构模式和尾调用。扩展了内置库以支持其他数据抽象，包括字典、集合、二进制数组，以及对字符串和正则表达式中Unicode字符的额外支持。内置类型也可以通过派生类进行扩展。</li>
<li>2016年6月发布了ECMA标准的第七版，新增了幂运算符，以及新的数组方法<code>Array.prototype.includes</code></li>
<li>2017年6月发布了ECMA标准的第八版，引入了异步函数、共享内存和原子。还新增了Object静态方法，包括<code>Object.values</code>、<code>Object.entries</code>、<code>Object.getOwnPropertyDescriptors</code>。</li>
<li>2018年6月发布了ECMA标准的第九版，引入了异步迭代器。为正则表达式添加了新功能：<code>dotAll</code>标志、命名捕获组、Unicode属性转义、向后断言。还添加了对象的剩余和展开属性运算。</li>
<li>2019年6月发布了ECMA标准的第十版，添加了数组内置方法<code>Array.prototype.flat</code>和<code>Array.prototype.flatMap</code>，对象静态方法<code>Object.fromEntries</code>、字符串内置方法<code>String.prototype.trimStart</code>和<code>String.prototype.trimEnd</code>。更新了可选的catch绑定参数语法，允许字符串字面值中的行分隔符(U+2028)与段分隔符(U+2029)与JSON对齐。还要求数组排序<code>Array.prototype.sort</code>是稳定排序、<code>JSON.stringify</code>不管输入是什么始终返回格式正确的UTF-8。明确<code>Function.prototype.toString</code>要么返回源文本，要么返回标准占位符。</li>
<li>2020年6月发布了ECMA标准的第11版，引入了字符串的<code>String.prototype.matchAll</code>方法。异步引入模块的<code>import()</code>语法。精确表示整数的新数组原始类型<code>BigInt</code>。为Promise添加了<code>Promise.allSettled</code>方法。引入了<code>globalThis</code>全局变量。令<code>export * as ns from 'module'</code>为模块专用语法。增加了<code>for-in</code>枚举属性的规范化。模块中可用<code>host-populated</code>对象。添加了新语法以处理<code>null</code>和<code>undefined</code>：空值合并(nullish coalescing)，值选择(value selection)运算符，以及可选链。</li>
</ol>
<h1 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h1>
<p>标识符，就是变量、函数、属性或函数参数的名称。<br />
ES6将标识符定义为不是保留字(ReservedWord)的标识符名(IdentifierName)。</p>
<p>一般的，标识符名可以由一或多个下列字符组成：</p>
<ol>
<li>第一个字符必须是一个字母、下划线（_）或美元符号（$）；</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>注：标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符，如 À 或汉字（但不推荐使用）。</p>
<p>标识符区分大小写，<code>a</code>与<code>A</code>是两个完全不同的标识符。另外按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<p>保留字是以下标识符名，可以分为关键字、未来保留字、NULL字面值、Boolean字面值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">关键字</span><br><span class="line">	break    do       in         typeof</span><br><span class="line">	case     else     instanceof var</span><br><span class="line">	catch    export   new        void</span><br><span class="line">	class    extends  return     while</span><br><span class="line">	const    finally  super      with</span><br><span class="line">	continue for      switch     yield</span><br><span class="line">	debugger function this       await</span><br><span class="line">	default  if       throw</span><br><span class="line">	delete   import   try</span><br><span class="line">未来保留字</span><br><span class="line">	enum</span><br><span class="line">NULL字面值</span><br><span class="line">	null</span><br><span class="line">Boolean字面值</span><br><span class="line">	true     false</span><br></pre></td></tr></table></figure>
<p>严格模式的保留字还包括下列标识符名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关键字</span><br><span class="line">	let         static</span><br><span class="line">未来保留字</span><br><span class="line">	implements  package  protected</span><br><span class="line">	interface   private  public</span><br></pre></td></tr></table></figure>
<h1 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h1>
<p>ECMAScript采用C语言风格注释：</p>
<ol>
<li>单行注释：一行中<code>//</code>后面的内容被视为注释</li>
<li>多行注释：以<code>/*</code>开头跨越一行或多行直到下一个<code>*/</code>为止的内容被视为注释</li>
</ol>
<h1 id="严格模式"><a class="markdownIt-Anchor" href="#严格模式"></a> 严格模式</h1>
<p>ECMAScript 语言定义了严格模式，严格模式限制了语言的某些功能，排除了 ECMAScript 语言中某些特定的句法和语义特征，还修改了某些功能的详细语义，以便规避那些用户认为容易出错的功能，从而获得更强的错误检查。</p>
<p>严格模式适用于选择的语法源文本单元级别，严格模式只会在这个源文本单元内施加带有局部效果的限制。一个 ECMAScript 程序可由严格模式和非严格模式的源文本单元组成。在这种情况下，严格的模式只适用于严格模式源文本单元内实际执行的代码。</p>
<p>要为源文本单元（例如整个脚本文件，也可能是单个函数）启用严格模式，需要在源文本单元的第一行添加字符串<code>&quot;use strict&quot;</code>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  &#x2F;&#x2F; 严格模式仅适用于此函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运行机制"><a class="markdownIt-Anchor" href="#运行机制"></a> 运行机制</h1>
<p>代理在启动时会创建全局对象、全局环境，以及其他内置对象。然后创建一个新的执行上下文，压入执行上下文栈中，使其变成运行中的执行上下文，并开始执行ECMAScript代码。</p>
<h2 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h2>
<p>一个代理包括一组ECMAScript执行上下文、一个执行上下文栈、一个运行中的执行上下文、一个代理记录(Agent Record)和一个执行线程。除了执行线程之外，一个代理的各个组成部分只属于该代理。</p>
<p>一个代理的执行线程，在代理的执行上下文上独立于其他代理执行一项任务(Job)，但一个执行线程可以被多个代理用作执行线程，前提是这些代理的 代理记录 的<code>[[CanBlock]]</code>属性不为<code>true</code>。</p>
<p>一个Node进程，一个Web浏览器标签页都可以看做一个代理。一些Web浏览器在一个浏览器窗口的多个标签页中共享一个执行线程，例如Chrome和Firefox的多个<code>about:blank</code>页。</p>
<h2 id="执行上下文"><a class="markdownIt-Anchor" href="#执行上下文"></a> 执行上下文</h2>
<p>执行上下文用于跟踪ECMAScript代码的运行。在任何时间点上，每个代理最多只有一个执行上下文在实际执行代码，这被称为代理的运行中的执行上下文。由于这一点，JavaScript常被称为是单线程的。</p>
<p>执行上下文栈被用来管理执行上下文，运行中的执行上下文始终是栈顶元素。每当控制权从与运行中的执行上下文关联的ECMAScript代码，转移到与运行中的执行上下文不关联的ECMAScript代码时，都会创建一个新的执行上下文（例如执行函数代码时创建新的执行陕西该文）。 新创建的执行上下文被压入栈，并成为运行中的的执行上下文。</p>
<p>运行中的执行上下文对代码的计算可以暂停。一旦运行中的执行上下文被暂停，不同的执行上下文可以成为运行中的执行上下文并开始计算其代码。在之后某个时间，被暂停的执行上下文可以再次成为运行中的执行上下文，并在它之前被暂停的地方继续计算其代码。运行中的执行上下文状态的转换通常以堆栈的LIFO（后进先出）方式进行。</p>
<p>每个执行上下文都包含两个词法环境类型的组件，一个称为<code>LexicalEnvironment</code>，另一个称为<code>VariableEnvironment</code>。执行上下文中的代码可以访问这两个词法环境中的绑定。</p>
<h2 id="词法环境"><a class="markdownIt-Anchor" href="#词法环境"></a> 词法环境</h2>
<p>词法环境用于定义标识符与特定的变量或函数之间的关联关系（粗略的说，可以理解为词法环境就是人们常说的作用域）。<br />
一个词法环境通常具有外部词法环境，在解析一个标识符时，如果当前词法环境找不到该标识符，就会在外部词法环境中查找。<br />
一个内部词法环境最多只有一个外部词法环境，但一个外部词法环境可能有多个内部词法环境。<br />
全局环境是唯一没有外部词法环境的词法环境，全局环境的外部环境引用为<code>null</code>。全局环境自带一些标识符绑定，并且包含了一个关联的全局对象，该全局对象是全局环境的<code>this</code>绑定的值。在全局环境解析标识符时，如果没有找到，还会在全局对象的属性中查找。</p>
<p>每个执行上下文都包含两个词法环境类型的组件：</p>
<ul>
<li>一个叫<code>LexicalEnvironment</code>，用于解析此执行上下文内的代码创建的标识符引用。</li>
<li>另一个叫<code>VariableEnvironment</code>，用于保存此执行上下文内的 <code>VariableStatements</code> 语句（即<code>var</code>声明）创建的绑定。</li>
</ul>
<h2 id="任务"><a class="markdownIt-Anchor" href="#任务"></a> 任务</h2>
<p>任务是没有参数的抽象闭包（类似于函数），由主机环境安排在未来某个时间点执行，当没有其他ECMAScript计算正在进行时，它将启动ECMAScript计算。</p>
<ul>
<li>在未来的某个时间点，当没有运行中的执行上下文且执行上下文栈为空时，实现必须：
<ol>
<li>将一个执行上下文压入执行上下文栈。</li>
<li>执行任何实现定义的准备步骤。</li>
<li>调用抽象闭包（执行任务）。</li>
<li>执行任何实现定义的清理步骤。</li>
<li>从执行上下文栈中弹出先前压入的执行上下文。</li>
</ol>
</li>
<li>在任何时间点上，只有一个任务可以进行计算。</li>
<li>一旦开始计算一个任务，它必须在任何其它任务的计算开始之前运行完成。</li>
<li>抽象闭包必须返回一个常规完结，实现它自己对错误的处理。</li>
</ul>
<p>在调度方面，ECMAScript规范不要求主机环境统一对待不同的任务。例如，Web浏览器和Node.js将处理<code>Promise</code>的任务视为具有比其他任务更高的优先级；未来可能会增加不被如此高优先级对待的任务。</p>
<p><code>setTimeout</code>和<code>setInterval</code>设置的定时执行的函数、<code>Promise</code>的响应列表中的处理函数都是任务。<br />
根据ECMAScript规范，Promise的任务必须按先进先出的顺序安排，任务的运行顺序与安排它们的函数调用的顺序相同。</p>
<h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1>
<p>变量将一个标识符对应到一个数据，ECMAScript变量是松散类型的，它可以保存任何类型的数据。有3个关键字可以用于声明变量：<code>var</code>、<code>const</code>和<code>let</code>。其中<code>const</code>和<code>let</code>是ES6新增的。</p>
<h2 id="var声明"><a class="markdownIt-Anchor" href="#var声明"></a> var声明</h2>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量声明<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 多个变量声明用逗号分隔</span></span><br><span class="line"><span class="keyword">var</span> 变量声明<span class="number">1</span>, 变量声明<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><code>变量声明</code>有三种形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标识符</span><br><span class="line">标识符 = 初始化表达式</span><br><span class="line">解构绑定 = 初始化表达式</span><br></pre></td></tr></table></figure>
<p>标识符右侧是用于初始化的值，也可以没有，声明多个变量用逗号隔开。例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> name, age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;a&quot;</span>, age;</span><br></pre></td></tr></table></figure>
<p><code>var</code>变量在包含它们的词法环境被实例化时创建，并且在创建时初始化为<code>undefined</code>。也就是说写在同一个词法环境最后一行的<code>var</code>变量，在第一行就可以使用，但值为<code>undefined</code>。<br />
当代码执行到<code>var</code>声明的初始化表达式时，变量的值才被赋予声明语句初始化表达式的值。</p>
<p><code>var</code>变量的作用域是运行中的执行上下文的 <code>VariableEnvironment</code>（由于基本上只有函数调用才会创建新的<code>VariableEnvironment</code>，也可以不那么精确的说成是函数作用域）。<br />
可以多次使用<code>var</code>声明相同标识符的变量，但只要它们在同一个 <code>VariableEnvironment</code> 内，最终也只会定义一个变量。如果相同作用域内存在一个通过<code>LexicalDeclaration</code>(let/const)或<code>ClassDeclaration</code>(class)创建的同名绑定，则会抛出语法错误异常。</p>
<h2 id="let和const声明"><a class="markdownIt-Anchor" href="#let和const声明"></a> let和const声明</h2>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量声明<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 多个变量声明用逗号分隔</span></span><br><span class="line"><span class="keyword">let</span> 变量声明<span class="number">1</span>, 变量声明<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> 变量声明<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> 变量声明<span class="number">1</span>, 变量声明<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><code>变量声明</code>有三种形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标识符  <span class="comment">// 这种形式const不可用</span></span><br><span class="line">标识符 = 初始化表达式</span><br><span class="line">解构绑定 = 初始化表达式</span><br></pre></td></tr></table></figure>
<p><code>let</code>变量和<code>const</code>变量在包含它们的词法环境被实例化时创建，但在执行到声明的词法绑定部分（等号左侧）之前，不能以任何方式访问（这种状态被人起名叫“暂时性死区”temporal dead zone，但这不是ES规范术语）。<br />
当代码执行到声明的词法绑定部分时，变量的值才被初始化为声明语句初始化表达式（等号右侧）的值。对于<code>let</code>声明，如果没有初始化表达式，则变量的值被初始化为<code>undefined</code>；对于<code>const</code>声明，如果没有初始化表达式，则抛出语法错误异常（但在解构绑定形式里，如果没有<code>默认值</code>则会初始化为<code>undefined</code>而不会抛出异常）。</p>
<p><code>let</code>和<code>const</code>变量的作用域是运行中的执行上下文的<code>LexicalEnvironment</code>（不那么精确的说，块作用域）。<br />
如果在相同作用域内存在存在一个通过<code>VariableStatement</code>(var)或<code>FunctionDeclaration</code>(函数)或<code>LexicalDeclaration</code>(let/const)或<code>ClassDeclaration</code>(class)创建的绑定则抛出语法错误异常。因此在同一个作用域不能重复使用<code>let</code>或<code>const</code>声明相同的变量。</p>
<p>另外，<code>const</code>声明的变量，除了初始化语句之外都不允许赋值，因此它是一个不可修改的常量。<br />
当<code>const</code>声明的是一个对象时，尽管变量本身不能修改，必须一直绑定该对象，但该对象属性可以修改。如果需要禁止修改对象属性，可以使用<code>Object.freeze()</code>方法</p>
<h2 id="全局声明"><a class="markdownIt-Anchor" href="#全局声明"></a> 全局声明</h2>
<p>标识符的解析规则是在当前词法环境查找，找不到就在外部词法环境查找，沿着词法环境链最终会找到全局环境，全局环境没有外部环境，因此在任何一个作用域内的标识符，如果找不到，最终一定会在全局环境中查找。<br />
全局环境包含一个关联的全局对象，全局对象在全局环境中的标识符名为<code>this</code>或者<code>globalThis</code>，在浏览器中也叫<code>window</code>。在全局环境中仍没有找到的标识符，还会在全局对象的属性中查找。<br />
由于上述规则，在全局环境中声明的变量，以及全局对象的属性，都可以称之为“全局声明”。</p>
<ul>
<li>在全局环境中的<code>var</code>声明，会出现在全局对象的属性中，两种方式操作的是同一个变量。</li>
<li>在全局环境中的<code>let/const</code>声明，不会出现在全局对象的属性中，即使为全局对象添加一个同名属性，二者也不是同一个变量。</li>
<li>在任何作用域为全局对象添加属性，也创建了“全局声明”。</li>
<li>非严格模式下，在任何作用域内，既不使用<code>let/const</code>，也不使用<code>var</code>，单纯使用赋值运算符也能进行“全局声明”，如果赋值运算符左侧的标识符一个无法解析的标识符，那么该赋值会变成为全局对象添加属性，例如<code>unResolve = 999; console.log(window.unResolve);</code></li>
</ul>
<h2 id="最佳实践"><a class="markdownIt-Anchor" href="#最佳实践"></a> 最佳实践</h2>
<p>使用声明的最佳实践是：</p>
<ol>
<li>不使用<code>var</code>，仅使用<code>let</code>和<code>const</code>声明：这有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</li>
<li><code>const</code>优先，其次才是<code>let</code>：使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</li>
</ol>
<h2 id="解构绑定"><a class="markdownIt-Anchor" href="#解构绑定"></a> 解构绑定</h2>
<p>解构绑定是ES6提供的用于变量声明的新语法，它可以基于某个对象的属性，又或者是某个可迭代对象的迭代值来声明并初始化变量。<br />
解构绑定可以作为变量声明语句的一部分，也可以是函数形参的一部分。</p>
<h3 id="对象解构绑定"><a class="markdownIt-Anchor" href="#对象解构绑定"></a> 对象解构绑定</h3>
<p>对象解构绑定与一个对象<code>obj</code>相关联，<code>obj</code>可能是传递给函数的参数，也可能是变量声明的初始化表达式的计算结果。<br />
对象解构绑定声明若干个变量，然后取出对象<code>obj</code>中的多个属性值，为声明的变量进行初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不声明任何变量</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="comment">// 根据关联对象的一个属性，初始化一个变量</span></span><br><span class="line">&#123; 属性绑定<span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 根据关联对象的多个属性，初始化多个变量，最后的逗号是可选的</span></span><br><span class="line">&#123; 属性绑定<span class="number">1</span>, 属性绑定<span class="number">2</span>, &#125;</span><br><span class="line"><span class="comment">// 剩余属性绑定，忽略关联对象中已经处理过的属性</span></span><br><span class="line">&#123; 剩余属性绑定 &#125;</span><br><span class="line">&#123; 属性绑定<span class="number">1</span>, 属性绑定<span class="number">2</span>, 剩余属性绑定 &#125;</span><br></pre></td></tr></table></figure>
<p>属性绑定有三种形式：</p>
<ul>
<li>第一种：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标识符</span><br><span class="line">标识符 = 默认值</span><br></pre></td></tr></table></figure>
<p>这种形式会用关联对象<code>obj</code>中属性键为<code>标识符</code>的属性的值，来初始化 运行中的执行上下文（当前作用域）的词法环境中名称为<code>标识符</code>的变量。<br />
如果关联对象<code>obj</code>中属性键为<code>标识符</code>的属性不存在，或者属性存在但值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，会用<code>默认值</code>初始化该变量。如果没有<code>默认值</code>，则会用<code>undefined</code>初始化该变量。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; myAge &#125; = srcObj <span class="comment">// 即var myAge = srcObj.myAge</span></span><br><span class="line"><span class="keyword">var</span> &#123; myAge = <span class="number">18</span> &#125; = srcObj</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名: 标识符</span><br><span class="line">属性名: 标识符 = 默认值</span><br></pre></td></tr></table></figure>
<p>属性名在【数据属性-&gt;Object-&gt;创建对象】一节已经说过有四种形式。<br />
这种形式会用关联对象<code>obj</code>中属性键为<code>属性名</code>的属性的值，来初始化 当前作用域的词法环境中名称为<code>标识符</code>的变量。<br />
如果关联对象<code>obj</code>中属性键为<code>属性名</code>的属性不存在，或者属性存在但值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，会用<code>默认值</code>初始化该变量。如果没有<code>默认值</code>，则会用<code>undefined</code>初始化该变量。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">myAge</span>: newAge &#125; = srcObj; <span class="comment">// 即var newAge = srcObj.myAge</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">myAge</span>: newAge = <span class="number">18</span> &#125; = srcObj;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:解构绑定</span><br><span class="line">属性名:解构绑定 = 默认值</span><br></pre></td></tr></table></figure>
<p>这种形式会用关联对象<code>obj</code>中属性键为<code>属性名</code>的属性的值，将该值作为内层<code>解构绑定</code>的关联对象。实际声明的变量取决于内层<code>解构绑定</code>。<br />
如果关联对象<code>obj</code>中属性键为<code>属性名</code>的属性不存在，或者属性存在但值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，将<code>默认值</code>作为内层<code>解构绑定</code>的关联对象。如果没有<code>默认值</code>，则抛出异常。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="number">2016</span>: &#123; <span class="attr">gdp</span>: GDP2016 &#125; &#125; = srcObj <span class="comment">// 即var GDP2016 = srcObj[&#x27;2016&#x27;].gdp</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="number">2016</span>: &#123; <span class="attr">gdp</span>: GDP2016 &#125; = &#123;<span class="attr">gdp</span>: <span class="literal">undefined</span>&#125; &#125; = srcObj</span><br></pre></td></tr></table></figure>
<p>剩余属性绑定只有一种形式，它只能出现在对象解构绑定的最右边，它的右边不允许再出现属性绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...标识符</span><br></pre></td></tr></table></figure>
<p>它会将关联对象<code>obj</code>中没有在之前的属性绑定中处理过的自有属性，拷贝到一个原型为<code>Object.prototype</code>的新对象里，然后用这个新对象初始化 当前作用域的词法环境中名称为<code>标识符</code>的变量。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="number">2016</span>: &#123; <span class="attr">gdp</span>: GDP2016 &#125;, ...exclude2016 &#125; = srcObj</span><br><span class="line"><span class="comment">// 即var GDP2016 = srcObj[&#x27;2016&#x27;].gdp</span></span><br><span class="line"><span class="comment">// var exclude2016 = &#123;2015: &#123;&#125;, 2017: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>解构绑定的过程可能抛出异常，但此前已完成的变量声明操作不会回滚，因此可能出现部分变量被正确声明与初始化，部分变量没有被成功声明。</p>
<h3 id="数组解构绑定"><a class="markdownIt-Anchor" href="#数组解构绑定"></a> 数组解构绑定</h3>
<p>数组解构绑定与一个可迭代对象<code>iterable</code>相关联，<code>iterable</code>可能是传递给函数的参数，也可能是变量声明的初始化表达式的计算结果。<br />
数组解构绑定声明若干个变量，然后将可迭代对象<code>iterable</code>的迭代器按顺序为声明的变量进行初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不声明任何变量，也不调用next()</span></span><br><span class="line">[]</span><br><span class="line"><span class="comment">// 调用一次next()，用其结果初始化一个变量</span></span><br><span class="line">[ 元素绑定<span class="number">1</span> ]</span><br><span class="line"><span class="comment">// 调用两次next()，结果分别给两个变量进行初始化，最后的逗号是可选的</span></span><br><span class="line">[ 元素绑定<span class="number">1</span>, 元素绑定<span class="number">2</span>, ] = iterable;</span><br><span class="line"><span class="comment">// 留空的元素绑定，调用两次next()，第二次的结果为一个引用赋值</span></span><br><span class="line">[ , 元素绑定<span class="number">1</span>, ]</span><br><span class="line"><span class="comment">// 剩余元素绑定，接受剩余next()的结果</span></span><br><span class="line">[ 剩余元素绑定 ]</span><br><span class="line">[ 元素绑定<span class="number">1</span>, 剩余元素绑定]</span><br><span class="line">[ , , , 剩余元素绑定 ]</span><br></pre></td></tr></table></figure>
<p>元素绑定有以下几种形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标识符</span><br><span class="line">标识符 = 默认值</span><br><span class="line">解构绑定</span><br><span class="line">解构绑定 = 默认值</span><br><span class="line">  <span class="comment">// 留空</span></span><br></pre></td></tr></table></figure>
<p>剩余元素绑定有两种形式，它只能出现在数组解构绑定的最右边，它的右边不允许再出现元素绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...标识符</span><br><span class="line">...解构绑定</span><br></pre></td></tr></table></figure>
<p>数组解构绑定执行以下过程：</p>
<ol>
<li>调用关联的可迭代对象的<code>Symbol.iterator</code>方法获取一个迭代器<code>iterator</code>。</li>
<li>对每个<code>元素绑定</code>表达式，调用一次<code>iterator.next()</code>方法：
<ol>
<li>如果迭代结果（<code>IteratorResult</code>对象）的<code>done</code>为<code>false</code>，且迭代值<code>value</code>不为<code>undefined</code>：
<ul>
<li>如果<code>元素绑定</code>是<code>标识符</code>，则用<code>value</code>为当前作用域的名为<code>标识符</code>的变量初始化</li>
<li>如果<code>元素绑定</code>是<code>解构绑定</code>，则将<code>value</code>作为内层<code>解构绑定</code>的关联对象。</li>
</ul>
</li>
<li>否则：
<ol>
<li>如果<code>元素绑定</code>表达式有<code>默认值</code>：
<ul>
<li>如果<code>元素绑定</code>是<code>标识符</code>，则用<code>默认值</code>为当前作用域名为<code>标识符</code>的变量初始化</li>
<li>如果<code>元素绑定</code>是<code>解构绑定</code>，则将<code>默认值</code>作为内层<code>解构绑定</code>的关联对象</li>
</ul>
</li>
<li>否则：
<ul>
<li>如果<code>元素绑定</code>是<code>标识符</code>，则用<code>undefined</code>为当前作用域名为<code>标识符</code>的变量初始化</li>
<li>如果<code>元素绑定</code>是<code>解构绑定</code>，则抛出异常</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>如果有<code>剩余元素绑定</code>表达式，则创建一个新数组，不断调用<code>iterator.next()</code>，将迭代值添加到这个新数组中，直到迭代结果的<code>done</code>为<code>true</code>。
<ul>
<li>如果<code>剩余元素绑定</code>是<code>...标识符</code>，则用新数组为当前作用域的名为<code>标识符</code>的变量初始化</li>
<li>如果<code>剩余元素绑定</code>是<code>...解构绑定</code>，则将新数组作为<code>解构绑定</code>的关联对象。</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ul>
<li><code>元素绑定</code>语句可能为空，即使逗号前留空也会调用<code>next()</code>，只是忽略迭代值，不对结果做任何操作。因此，如果加上最后可选的逗号，那么每个逗号都会导致一次<code>next()</code>调用，其结果要么被忽略，要么被用来初始化逗号前的<code>元素绑定</code>语句的<code>标识符</code>对应的变量，要么用作内层<code>解构绑定</code>的关联对象。</li>
</ul>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<p>ECMAScript有8种数据类型：Undefined、Null、Boolean、String、Symbol、Number、BigInt、Object。除了Object以外的7种数据类型是原始类型，原始类型是可以直接表示语言实现的最底层数据的类型。</p>
<h2 id="undefined"><a class="markdownIt-Anchor" href="#undefined"></a> Undefined</h2>
<p>Undefined类型有且只有一个值，它的字面值为<code>undefined</code> 。任何没有被赋值的变量值为 <code>undefined</code></p>
<h2 id="null"><a class="markdownIt-Anchor" href="#null"></a> Null</h2>
<p>Null类型 有且只有一个值，它的字面值为 <code>null</code> 。</p>
<p>从语义上来说，<code>null</code>表示一个空对象指针。如果一个变量将来要用于保存对象，则可以将其初始化为<code>null</code>。之后只需要检查该变量是否为<code>null</code>，就可以知道变量是否在后来被赋予了一个对象的引用。</p>
<h2 id="boolean"><a class="markdownIt-Anchor" href="#boolean"></a> Boolean</h2>
<p>Boolean类型有两个值，它们的字面值为<code>true</code> 和 <code>false</code>。</p>
<h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h2>
<p>字符串类型是零个或多个16位无符号整数值（“元素”）的所有有序序列组成的集合，最大长度为<code>2^53-1</code>。<br />
字符串类型常被用于表示文本数据，此时字符串中的每个元素都被视为一个 UTF-16 代码单元值。每个元素都被认为占有此序列中的一个位置，用非负整数索引这些位置。任何时候，第一个元素（若存在）在位置0，下一个元素（若存在）在位置1，依此类推。字符串的长度是它的元素（即16位的值）的个数。空字符串长度为零，因而不包含任何元素。</p>
<p>字符串被设计为不可变的，它没有任何方法可以修改其保存的字符序列，所有修改字符串的方法将返回一个和该字符串无关的全新的字符串。</p>
<h3 id="字符串字面值"><a class="markdownIt-Anchor" href="#字符串字面值"></a> 字符串字面值</h3>
<p>创建字符串的一种方法是使用字符串字面值，它的写法是使用单引号<code>'</code>或双引号<code>&quot;</code>将字符序列引起来。<br />
除了用于闭合的引号、U+005C (反斜线<code>\</code>), U+000D (回车), U+2028 (行分隔符), U+2029 (段分隔符)和U+000A (换行)之外，其他所有代码点都可能以其字面形式出现在字符串字面值中，即输入什么就是什么。而上面六个字符如果想让其出现在字符串字面值内，只能用转义序列的形式输入。</p>
<p>直接输入的行结束符（回车、行分隔符、段分隔符、换行）必须在反斜线<code>\</code>后面，但它不是用于在字符串中加入换行符，而是用来将一行书写不下的内容换成两行书写。<code>\</code>和它后面的行结束符并不会加入字符串内。例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc\</span></span><br><span class="line"><span class="string">def&quot;</span></span><br><span class="line"><span class="comment">// 结果是 &quot;abcdef&quot;</span></span><br></pre></td></tr></table></figure>
<p>字符串字面值的文法如下图（注意蓝色文字表示一个整体例如<code>\n</code>是指换行符而非两个符号<code>\</code>和<code>n</code>）。<br />
转义序列以<code>\</code>开头，有4种形式：</p>
<ul>
<li>后跟某个符号，例如<code>\n</code>表示换行，<code>\\</code>表示反斜线</li>
<li>后跟<code>x</code>加2个十六进制数字，表示此代码点对应的UTF-16字符</li>
<li>后跟<code>u</code>加4个十六进制数字，表示此代码点对应的UTF-16字符</li>
<li>后跟<code>u&#123;</code>加任意个十六进制数字，再跟<code>&#125;</code>，表示此代码点对应的UTF-16字符（注意，合法的范围是0-10FFFF，超出范围会抛出异常）<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210202091116735_13691.png" alt="" width="621" /></li>
</ul>
<h3 id="模板字面值"><a class="markdownIt-Anchor" href="#模板字面值"></a> 模板字面值</h3>
<p>ES6提供了一种用于创建字符串的新方法，即使用模板字面值，它的写法是使用反引号<code>`</code>将字符序列引起来。<br />
它的用法基本上和和字符串字面值类似，区别在于：</p>
<ul>
<li>可以直接输入行结束符，行结束符会作为字符串的一部分。也可以通过输入<code>\</code>加行结束符来换行输入，这样的行结束符不会作为字符串的一部分。</li>
<li>可以使用<code>$&#123;表达式&#125;</code>语法进行插值，表达式的计算结果会被ToString内部函数转为字符串，替换<code>$&#123;表达式&#125;</code>。任何表达式都可以放在花括号内，字符串字面值和模板字面值也是表达式，因此可以也可以放在表达式部分。</li>
</ul>
<h2 id="symbol"><a class="markdownIt-Anchor" href="#symbol"></a> Symbol</h2>
<p>Symbol(符号)是ES6新提供的一种类型，主要用于作为对象的属性的标识符（即属性键），以前对象属性的标识符只能使用字符串，现在还可以使用Symbol。<br />
Symbol的特点是它的每个实例都是唯一、不可变的。</p>
<p>声明一个Symbol变量的唯一方法是使用Symbol函数，即<code>Symbol(&quot;mySymbol&quot;)</code>，没有字面值语法。Symbol函数的参数是可选的Symbol描述，这个描述只用来对人起到提示作用，不具有区分Symbol的功能，两个相同描述的Symbol是完全不同的。</p>
<p>对Symbol调用<code>toString()</code>会返回字符串<code>&quot;Symbol(&quot;+desc+&quot;)&quot;</code>，其中<code>desc</code>是Symbol的描述，如果没有保存Symbol变量，那么只能遍历对象的Symbol属性键，检查它们的描述是否匹配，但这只在作为属性键的Symbol的描述各不相同时有效，如果存在两个相同描述的Symbol就没有办法区分了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;description&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Symbol函数不能用作构造函数，因此无法new出一个Symbol。</p>
<p>如果要在不同代码之间共享Symbol，除了作为参数传递变量之外，还可以使用全局符号注册表。<br />
<code>Symbol.for(key)</code>用来从全局符号注册表中获取key（一个字符串）对应的Symbol，如果不存在则会创建一个新的Symbol与key关联，并保存到全局符号注册表中，key也用作新创建的Symbol的描述。<br />
<code>Symbol.keyFor(symbol)</code>用来从全局符号表中获取symbol关联的key，如果找不到则返回<code>undefined</code>。</p>
<h2 id="number"><a class="markdownIt-Anchor" href="#number"></a> Number</h2>
<p>Number类型的值表示一个浮点数，它采用 IEEE 754 双精度格式。</p>
<ul>
<li>浮点数有限值集合是有限集，它是数学中实数集的子集。</li>
<li>每个浮点数有限值都唯一对应一个与它相同值的实数，这种从浮点数有限值集合，到实数集的对应关系是一个单射。</li>
<li>每个实数都唯一对应一个浮点数，但这种对应关系不是单射，多个实数可能对应到相同的浮点数有限值。该对应关系将每个实数映射到一个数学值与它最接近的浮点数。</li>
</ul>
<p>因此，你输入的Number字面值，在被自动映射为浮点数后，与你希望表示的实数值，在绝大多数情况下都不相同。举例而言：<br />
当你输入<code>0.1</code>时，你希望表示一个实数<code>0.1</code>，但实际的浮点数数学值是<code>0.1000000000000000055511151231257827021181583404541015625</code>。<br />
在控制台等地方，为了便于人类阅读，显示的值会基于浮点数数学值舍入（见<code>Number::toString</code>抽象操作），这导致<code>0.1</code>在控制台显示为<code>0.1</code>，但这种行为只是为了便于人类阅读。在JavaScript中，任何使用Number值的地方，其计算都是基于数学值（如<code>0.1000000000000000055511151231257827021181583404541015625</code>），而非人类友好的显示值（<code>0.1</code>）。同理，实数<code>1000000000000000128</code>的浮点数数学值为<code>1000000000000000128</code>，但显示值为<code>1000000000000000100</code>。<br />
如果你想看到实际的数学值，可以使用下列方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.real = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.toFixed(<span class="number">100</span>).replace(<span class="regexp">/(\.[1-9]+)0+$/</span>, <span class="string">&quot;$1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0.1</span>.real();</span><br></pre></td></tr></table></figure>
<p>遗憾的是该方法最多显示100位小数。</p>
<p>合法的字面值如图所示，包括：</p>
<ul>
<li>十进制字面值：整数部分和小数部分可以省略其中之一，后面可以跟以<code>e</code>开头的指数部分，表示之前的数字乘以10的某个次幂</li>
<li>八进制字面值：以数字0和字母o开头</li>
<li>二进制字面值：以数字0和字母b开头</li>
<li>十六进制字面值：以数字0和字母x开头</li>
</ul>
<p><img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210512175224024_6457.png" alt="" width="621" /></p>
<p>根据IEEE 754，当阶码全为1，而frac部分不全为0时，其值表示 NaN(非数字)，这样的NaN总共有<code>2^53-2</code>个，在ECMAScript中，这些NaN相互之间无法区分。</p>
<h2 id="bigint"><a class="markdownIt-Anchor" href="#bigint"></a> BigInt</h2>
<p>BigInt类型表示一个数学上的整数值。该值可以是任何大小，不限于特定的位宽。操作BigInt类型的运算被设计为返回基于数学的精确答案。对于二进制运算，BigInt作为二进制补码字符串，负数被视为向左无限设置的位。</p>
<p>合法的字面值如图所示，包括：</p>
<ul>
<li>十进制字面值：以n结尾</li>
<li>八进制字面值：以数字0和字母o开头，以n结尾</li>
<li>二进制字面值：以数字0和字母b开头，以n结尾</li>
<li>十六进制字面值：以数字0和字母x开头，以n结尾</li>
</ul>
<p><img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210512175652919_13118.png" alt="" width="621" /></p>
<h2 id="object"><a class="markdownIt-Anchor" href="#object"></a> Object</h2>
<p>对象是属性的集合，属性分为数据属性，以及访问器属性。</p>
<p>数据属性由三部分组成：</p>
<ol>
<li>一个属性键</li>
<li>一个ECMAScript语言类型（Undefined、Null、Boolean、String、Symbol、Number、Object）值</li>
<li>一个Boolean类型的特性(attributes)集合。</li>
</ol>
<p>访问器属性由三部分组成：</p>
<ol>
<li>一个属性键</li>
<li>一个（或两个）访问器函数。访问器函数用于获取或设置与属性关联的ECMAScript语言值。</li>
<li>一个Boolean类型的特性(attributes)集合组成。</li>
</ol>
<p>属性使用属性键来标识，属性键可以是String类型（包括空串）或Symbol类型。<br />
属性键用于访问属性及其值。 对属性的访问有两种方法：get和set，分别对应于值检索和赋值。<br />
通过get和set可以访问对象的自有属性以及它继承的属性，一个对象的自有属性的属性键，必须与该对象其他自有属性的属性键不同。</p>
<h3 id="内部槽"><a class="markdownIt-Anchor" href="#内部槽"></a> 内部槽</h3>
<p>对象有两个内部槽：<code>[[Prototype]]</code>和<code>[[Extensible]]</code>。<br />
内部槽可以理解为内部属性，但程序员不能像普通属性一样看到和访问它。</p>
<p><code>[[Prototype]]</code>内部槽通常称为对象的原型，其值要么是<code>null</code>，要么是一个对象，它用于实现继承。在访问一个属性时，如果这个属性不是当前对象的自有属性，就会查找<code>[[Prototype]]</code>对象的同名自有属性，这样的属性称为继承的属性（实际上只是这些属性对于子对象是可见的）。<br />
继承的数据属性只能进行get访问，不能进行set访问，因此无法通过子对象来修改<code>[[Prototype]]</code>对象的自有属性。进行set访问实际上会变成创建同名的自有属性。<br />
继承的访问器属性可以进行get访问，也可以进行set访问。</p>
<p><code>[[Extensible]]</code>内部槽通常称为对象的可扩展性，其值是一个布尔值。如果它为<code>false</code>，那么就不能再为当前对象添加任何属性。也不允许修改该对象的<code>[[Prototype]]</code>以及<code>[[Extensible]]</code>内部槽的值（也就是说改不回<code>true</code>了）</p>
<h3 id="属性的特性"><a class="markdownIt-Anchor" href="#属性的特性"></a> 属性的特性</h3>
<p>数据属性有四个特性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性名</th>
<th style="text-align:left">值域</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Value]]</td>
<td style="text-align:left">任何 ECMAScript语言类型</td>
<td style="text-align:left">属性值的所在位置，通过属性的get访问来获取该值</td>
</tr>
<tr>
<td style="text-align:left">[[Writable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 false，试图通过 ECMAScript 代码 [[Set]] 去改变该属性的 [[Value]]将会失败。默认为true</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 true，则该属性可被 for-in 枚举出来，否则，该属性不可枚举。默认为true</td>
</tr>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 false，试图删除该属性或改变该属性为访问器属性，或改变它的特性（不包括修改 [[Value]]，或将[[Writable]]改为false的情况），都会失败。默认为true</td>
</tr>
</tbody>
</table>
<p>访问器属性也有四个特性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性名</th>
<th style="text-align:left">值域</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[[Get]]</td>
<td style="text-align:left">Object或Undefined</td>
<td style="text-align:left">如果该值为一个 Object 对象，那么它必须是一个函数对象。每次有对属性进行 get 访问时，该函数的内部方法 [[Call]] 会伴随着一个空参数列表被调用，并取出该属性值。默认为undefined</td>
</tr>
<tr>
<td style="text-align:left">[[Set]]</td>
<td style="text-align:left">Object或Undefined</td>
<td style="text-align:left">如果该值为一个 Object 对象，那么它必须是一个函数对象。每次有对属性进行 set 访问时，该函数的内部方法 [[Call]] 会伴随着一个参数列表被调用，这个参数列表包含了指定值作为唯一的参数。属性的内部方法 [[Set]] 可能会对随后的 属性 内部方法 [[Get]] 的调用返回结果产生影响。默认为undefined</td>
</tr>
<tr>
<td style="text-align:left">[[Enumerable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 true，则该属性可被 for-in 枚举出来，否则，该属性不可枚举。默认为true</td>
</tr>
<tr>
<td style="text-align:left">[[Configurable]]</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">如果为 false，试图删除该属性，改变该属性为数据属性，或改变它的特性，都会失败。默认为true</td>
</tr>
</tbody>
</table>
<h3 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h3>
<p>创建一个对象的常用方法是使用<code>new</code>运算符，<code>Object.create()</code>函数，或者对象字面值语法。</p>
<ol>
<li>new运算符后跟一个构造函数调用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>Object.create</code>函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="built_in">Object</span>.create();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对象字面值语法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有自有属性的对象</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 定义一个自有属性</span></span><br><span class="line">&#123; 属性定义<span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 多个自有属性用逗号分隔，最后的逗号是可选的</span></span><br><span class="line">&#123; 属性定义<span class="number">1</span>, 属性定义<span class="number">2</span>, &#125;</span><br></pre></td></tr></table></figure>
<p>如果属性键相同，则后面的属性定义将覆盖前面的属性定义。</p>
<p>属性定义有有四种形式：<br />
第一种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性名:表达式 <span class="comment">// 例如 &#123; a: 55 &#125;</span></span><br><span class="line"><span class="comment">// 属性名又有四种表达形式：</span></span><br><span class="line">标识符名 <span class="comment">// 例如 a</span></span><br><span class="line">字符串字面值 <span class="comment">// 例如 &#x27;a&#x27;</span></span><br><span class="line">数字字面值  <span class="comment">// 例如 1</span></span><br><span class="line">[表达式]   <span class="comment">// 例如 [a] 和 [Symbol(&quot;a&quot;)]</span></span><br></pre></td></tr></table></figure>
<p>这种形式用冒号<code>:</code>将属性键与属性值分开，属性名作为属性键，表达式的结果作为属性值。<br />
属性名有标识符名、字符串字面值、数字字面值、<code>[表达式]</code>四种形式。前三种形式的属性名会被转换为字符串属性键，最后一种形式会将中括号内表达式的计算结果作为属性键，最终可能被转换为字符串属性键，也可能被转换为Symbol属性键。<br />
只有最后一种形式会进行计算，因此它可以实现动态的属性名。</p>
<p>第二种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标识符名 <span class="comment">// 例如 &#123; name &#125;</span></span><br></pre></td></tr></table></figure>
<p>这种形式实际上是<code>标识符名:表达式</code>的一种特殊简写，它将一个已存在的标识符名作为字符串属性键，标识符对应的值作为属性值。<code>&#123; name &#125;</code>等价于<code>&#123; name: name &#125;</code></p>
<p>第三种</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...表达式</span><br></pre></td></tr></table></figure>
<p>将<code>表达式</code>使用<code>ToObject</code>抽象操作转为对象<code>source</code>，对<code>source</code>对象中的每个自有属性键（通过<code>[[OwnPropertyKeys]]</code>得到），在对象字面值<code>target</code>中创建相同属性键的数据属性，其值为使用<code>[[Get]]</code>从<code>source</code>中获取该属性键得到的值。<br />
简而言之，就是将一个对象所有自有属性拷贝到当前的对象字面值，都变成了数据属性。</p>
<p>第四种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法定义</span><br><span class="line"><span class="comment">// 方法定义有6种形式：</span></span><br><span class="line">属性名(参数)&#123;函数体&#125; <span class="comment">// 例如 say()&#123;&#125;</span></span><br><span class="line">get 属性名()&#123;函数体&#125; <span class="comment">// 例如 get length()&#123;&#125;</span></span><br><span class="line">set 属性名(参数)&#123;函数体&#125; <span class="comment">// 例如 set length(val)&#123;&#125;</span></span><br><span class="line">* 属性名(参数)&#123;生成器函数体&#125; <span class="comment">// 例如 * gen()&#123;&#125;</span></span><br><span class="line"><span class="keyword">async</span> 属性名(参数)&#123;异步函数体&#125; <span class="comment">// 例如 async f()&#123;&#125;</span></span><br><span class="line"><span class="keyword">async</span> * 属性名(参数)&#123;异步生成器函数体&#125; <span class="comment">// 例如 async *g()&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种形式提供了函数表达式之外的定义方法的途径。</p>
<p>只有下面两种形式可用于定义访问器属性，其他形式定义的都是数据属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get 属性名()&#123;函数体&#125; <span class="comment">// 例如 &#123; get length()&#123;&#125; &#125;</span></span><br><span class="line">set 属性名(参数)&#123;函数体&#125; <span class="comment">// 例如 &#123; set length(val)&#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>只定义了<code>get</code>访问器的属性将是只读的，因为只能获取属性值而无法设置属性值。</p>
<h3 id="属性访问"><a class="markdownIt-Anchor" href="#属性访问"></a> 属性访问</h3>
<p>访问对象的属性有两种语法，点表示法和中括号表示法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;&#39;a&#39; : 1&#125;</span><br><span class="line">let v1 &#x3D; o.a</span><br><span class="line">let v2 &#x3D; o[&#39;a&#39;]</span><br></pre></td></tr></table></figure>
<ul>
<li>点表示法是对象后跟一个点<code>.</code>，再跟一个标识符名，标识符名会被转换为字符串值，然后去访问这个字符串属性键对应的属性。</li>
<li>中括号表示法是对象后跟一对中括号<code>[]</code>，中括号内部是一个表达式，表达式的计算结果会先通过抽象操作<code>ToPrimitive(argument, hint String)</code>得到原始值，如果是原始值类型是Symbol则返回，类型不是Symbol则使用<code>ToString</code>抽象操作转换为字符串。最后得到的结果要么是Symbol属性键，要么是字符串属性键，再去访问该对象的属性键对应的属性。</li>
</ul>
<p>对属性的访问有两种方法：get和set，分别对应于值检索和赋值。<br />
当属性访问表达式用于右值时，会进行get访问来获取值。<br />
当属性访问用于左值时，会进行set访问来设置<strong>自有属性</strong>的值。</p>
<h3 id="改变属性特性"><a class="markdownIt-Anchor" href="#改变属性特性"></a> 改变属性特性</h3>
<p>通过对象字面值，或者属性访问定义的属性，其特性为：<code>Enumerable</code>、<code>Configurable</code>都为<code>true</code>，对于数据属性，<code>Writable</code>为<code>true</code>，对于访问器属性<code>Set</code>或<code>Get</code>没有给出的那个为<code>undefined</code>。<br />
要想修改属性的特性，或者在定义属性的同时修改特性，需要使用下列函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, propName, attrs)</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, propsObj)</span><br></pre></td></tr></table></figure>
<h2 id="包装类型"><a class="markdownIt-Anchor" href="#包装类型"></a> 包装类型</h2>
<p><code>Boolean</code>、<code>Number</code>和<code>String</code>类型具有与之对应的特殊的<code>Object</code>类型，称作包装类型。<br />
包装类型的值的行为与原始值一样，但由于包装类型是<code>Object</code>，因此它还额外提供了方便的属性或方法。<br />
除了<code>String</code>以外的包装类型对象都没有自有属性，<code>String</code>具有自有属性，它的整数索引对应于字符串的每个代码单元，还有一个<code>&quot;length&quot;</code>属性对应于字符串的长度。<br />
可以使用<code>Boolean()</code>、<code>Number()</code>、<code>String()</code>等函数将原始值变为包装类型，使用包装类型的<code>valueOf()</code>方法可以将包装类型转换为原始值。<br />
但更多情况下，原始类型与包装类型的互相转换过程是自动的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码中，在调用方法<code>substring()</code>时，原始值<code>s1</code>被转换为包装类型，而在赋值给<code>s2</code>时，包装类型又被自动转换为原始值，随后包装对象被销毁。这个过程就仿佛包装类型不存在一样。</p>
<p>基于原型模式，在原始类型的包装类型的原型上添加方法，就可以让所有原始值的包装对象调用。例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.addHash = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;-&quot;</span>+<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.addHash();</span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1>
<p>ECMAScript定义了一组用于计算数据值的运算符，这些运算符的适用于所有类型的操作数，但通常会在内部将其转换为一致的类型。<br />
优先级：<br />
<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p>
<h2 id="优先级"><a class="markdownIt-Anchor" href="#优先级"></a> 优先级</h2>
<ol>
<li>
<ul>
<li>圆括号<code>(op)</code>：返回引用还是值取决于<code>op</code></li>
</ul>
</li>
<li>
<ul>
<li>成员访问<code>op1.op2</code>：从左到右结合，返回引用</li>
<li>需计算的成员访问<code>op1[op2]</code>：从左到右结合，返回引用</li>
<li>带参数的<code>new(op1)</code>：返回值</li>
<li>函数调用<code>op1(op2)</code>：从左到右结合，返回值</li>
<li>可选链<code>?.</code>：从左到右结合，<code>op?.op</code>和<code>op?.[]</code>返回引用，而<code>op?.()</code>返回值</li>
</ul>
</li>
<li>
<ul>
<li>不带参数的<code>new op</code>：从右到左结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>后缀递增<code>op++</code>：返回值</li>
<li>后缀递减<code>op--</code>：返回值</li>
</ul>
</li>
<li>
<ul>
<li>逻辑非<code>!op</code>：从右到左结合，返回值</li>
<li>按位取反<code>~op</code>：从右到左结合，返回值</li>
<li>一元加<code>+op</code>：从右到左结合，返回值</li>
<li>一元减<code>-op</code>：从右到左结合，返回值</li>
<li>前缀递增<code>++op</code>：从右到左结合，返回值</li>
<li>前缀递减<code>--op</code>：从右到左结合，返回值</li>
<li><code>typeof op</code>：从右到左结合，返回值</li>
<li><code>void op</code>：从右到左结合，返回值</li>
<li><code>delete op</code>：从右到左结合，返回值</li>
<li><code>await op</code>：从右到左结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>幂<code>op1 ** op2</code>：从右到左结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>乘<code>op1 * op2</code>：从左到右结合，返回值</li>
<li>除<code>op1 / op2</code>：从左到右结合，返回值</li>
<li>取余<code>op1 % op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>加<code>op1 + op2</code>：从左到右结合，返回值</li>
<li>减<code>op1 - op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>左移<code>op1 &lt;&lt; op2</code>：从左到右结合，返回值</li>
<li>有符号右移<code>op1 &gt;&gt; op2</code>：从左到右结合，返回值</li>
<li>无符号右移<code>op1 &gt;&gt;&gt; op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>小于<code>op1 &lt; op2</code>：从左到右结合，返回值</li>
<li>小于等于<code>op1 &lt;= op2</code>：从左到右结合，返回值</li>
<li>大于<code>op1 &gt; op2</code>：从左到右结合，返回值</li>
<li>大于等于<code>op1 &gt;= op2</code>：从左到右结合，返回值</li>
<li><code>op1 in op2</code>：从左到右结合，返回值</li>
<li><code>op1 instanceof op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>相等<code>op1 == op2</code>：从左到右结合，返回值</li>
<li>不等<code>op1 != op2</code>：从左到右结合，返回值</li>
<li>严格相等<code>op1 === op2</code>：从左到右结合，返回值</li>
<li>严格不等<code>op1 !== op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>按位与<code>op1 &amp; op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>按位异或<code>op1 ^ op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>按位或<code>op1 | op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>逻辑与<code>op1 &amp;&amp; op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>逻辑或<code>op1 || op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>空值合并<code>op1 ?? op2</code>：从左到右结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>条件<code>op1 ? op2 : op3</code>：从右到左结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>赋值<code>op1 = op2</code>与组合赋值<code>op1 @= op2</code>：从右到左结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li><code>yield op</code>：从右到左结合，返回值</li>
<li><code>yield*</code>：从右到左结合，返回值</li>
</ul>
</li>
<li>
<ul>
<li>逗号<code>op1 , op2</code>：从左到右结合，返回值</li>
</ul>
</li>
</ol>
<h2 id="抽象操作"><a class="markdownIt-Anchor" href="#抽象操作"></a> 抽象操作</h2>
<p>运算符通常会将操作数转换为特定的类型，这种情况下会用到一系列用于类型转换的抽象操作。</p>
<h3 id="typev"><a class="markdownIt-Anchor" href="#typev"></a> Type(v)</h3>
<p>Type(v)抽象操作返回一个表示基本类型的字符串，和typeof运算符不同，Type抽象操作返回的是7种基本数据类型。Null类型会返回<code>&quot;Null&quot;</code>，而函数对象会返回<code>&quot;Object&quot;</code>。<br />
另外不像<code>typeof</code>，<code>Type(v)</code>不能给<code>v</code>传递一个无法解析的绑定。</p>
<h3 id="toprimitivev-hint-default"><a class="markdownIt-Anchor" href="#toprimitivev-hint-default"></a> ToPrimitive(v, hint = ‘default’)</h3>
<p>ToPrimitive抽象操作将参数<code>v</code>转换为原始值，即对象以外的基本类型。<br />
如果不是对象，该抽象操作直接返回参数<code>v</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToPrimitive</span>(<span class="params">v, hint = <span class="string">&#x27;default&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Type(v) !== <span class="string">&#x27;Object&#x27;</span>) <span class="keyword">return</span> v;</span><br><span class="line">  <span class="keyword">let</span> custoToPrimitive = v[<span class="built_in">Symbol</span>.toPrimitive];</span><br><span class="line">  <span class="keyword">if</span>(custoToPrimitive) &#123;</span><br><span class="line">    <span class="keyword">return</span> v[<span class="built_in">Symbol</span>.toPrimitive](hint)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span>(hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">      hint = <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> v.valueOf == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = v.valueOf();</span><br><span class="line">        <span class="keyword">if</span>(Type(result) == <span class="string">&#x27;Object&#x27;</span>) result = v.toString();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> v.toString == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = v.toString();</span><br><span class="line">        <span class="keyword">if</span>(Type(result) == <span class="string">&#x27;object&#x27;</span>) result = v.valueOf();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tostringv"><a class="markdownIt-Anchor" href="#tostringv"></a> ToString(v)</h3>
<p>ToString抽象操作将参数<code>v</code>转换为一个<code>String</code>类型的字符串。</p>
<p>当<code>v</code>不是对象时，表达式<code>&quot;&quot; + v</code>和<code>ToString</code>抽象操作完全等价。<br />
当<code>v</code>是对象时，在获取原始值时，<code>ToString</code>抽象操作会调用<code>ToPrimitive(v, 'string')</code>，而表达式<code>&quot;&quot; + v</code>会调用<code>ToPrimitive(v)</code>，在这一点上有所区别。</p>
<p>表达式<code>String(v)</code>也可以调用ToString抽象操作，区别在于对于Symbol不会抛出异常，而是返回<code>&quot;Symbol(&quot;+desc+&quot;)&quot;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToString</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = Type(v);</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Undefined&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Null&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Boolean&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v ? <span class="string">&#x27;true&#x27;</span> : <span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Number&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Number</span>::toString(v);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;String&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Symbol&#x27;</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;BigInt&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v.toString();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> ToString(ToPrimitive(v, <span class="string">&#x27;string&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tonumericv"><a class="markdownIt-Anchor" href="#tonumericv"></a> ToNumeric(v)</h3>
<p>ToNumeric抽象操作将参数<code>v</code>转换为<code>Number</code>类型或<code>BigInt</code>类型的数字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToNumeric</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> primValue = ToPrimitive(v, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(Type(primValue) == <span class="string">&#x27;BigInt&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> primValue;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ToNumber(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tonumberv"><a class="markdownIt-Anchor" href="#tonumberv"></a> ToNumber(v)</h3>
<p>ToNumber抽象操作将参数<code>v</code>转换为一个<code>Number</code>类型的数字。<br />
表达式<code>+v</code>可以调用ToNumber抽象操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToNumber</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = Type(v);</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Undefined&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Null&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> +<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Boolean&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Number&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;String&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> str2num(v);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Symbol&#x27;</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> ToPrimitive(v, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串转换数字时，如果能将字符串整个按下图匹配成功，则返回对应的数字。如果不能匹配，则返回<code>NaN</code>。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/_v_images/20210224092035348_17024.png" alt="" width="621" /><br />
上述规则和数字字面值的区别在于</p>
<ul>
<li>数字字符串的前后可以有若干的空白字符或行结束符</li>
<li>表示十进制的数字字符串可以有任意数量的前导0</li>
<li>表示十进制的数字字符串可以包含<code>+</code>或<code>-</code>来指示符号</li>
<li>空的，或只包含空白的数字字符串会被转换为<code>+0</code></li>
<li><code>Infinity</code>和<code>-Infinity</code>可被识别为是有效的数字字符串</li>
</ul>
<h3 id="tointegerv"><a class="markdownIt-Anchor" href="#tointegerv"></a> ToInteger(v)</h3>
<p><code>ToInteger</code> 抽象操作将其参数<code>v</code>转换为有限整数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToInteger</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = +v;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.is(number, <span class="literal">NaN</span>) || <span class="built_in">Object</span>.is(number, +<span class="number">0</span>) || <span class="built_in">Object</span>.is(number, -<span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> +<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(number === +Infintiy || number === -<span class="literal">Infinity</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> integer = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(number));</span><br><span class="line">  <span class="keyword">if</span>(number &lt;= -<span class="number">0</span>) integer = -integer;</span><br><span class="line">  <span class="keyword">return</span> integer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tolengthv"><a class="markdownIt-Anchor" href="#tolengthv"></a> ToLength(v)</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToLength</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = ToInteger(v);</span><br><span class="line">  <span class="keyword">if</span>(len &lt;= +<span class="number">0</span>) <span class="keyword">return</span> +<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(len, <span class="number">2</span>**<span class="number">53</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="toint32v"><a class="markdownIt-Anchor" href="#toint32v"></a> ToInt32(v)</h3>
<p>ToInt32 抽象操作将其参数<code>v</code>转换为 在<code>-2^31</code>到<code>2^31-1</code>闭区间内的<code>2^32</code> 个整数之一。<br />
表达式<code>~~v</code>或<code>v | 0</code>可以调用 ToInt32 抽象操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToInt32</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = ToNumber(v);</span><br><span class="line">  <span class="keyword">switch</span>(number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">NaN</span>: <span class="comment">// 仅做演示，实际无法这样检查NaN</span></span><br><span class="line">    <span class="keyword">case</span> +<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> +∞:</span><br><span class="line">    <span class="keyword">case</span> -∞:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;+0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向0取整</span></span><br><span class="line">  <span class="keyword">let</span> int = sign(number)×floor(abs(number));</span><br><span class="line">  <span class="comment">// 模2^32得到32位无符号整数</span></span><br><span class="line">  <span class="keyword">let</span> int32bit = int modulo <span class="number">2</span>^<span class="number">32</span>;</span><br><span class="line">  <span class="comment">// 无符号转换为有符号</span></span><br><span class="line">  <span class="keyword">if</span>(int32bit &gt;= <span class="number">2</span>^<span class="number">31</span>) <span class="keyword">return</span> int32bit-<span class="number">2</span>^<span class="number">32</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> int32bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="touint32v"><a class="markdownIt-Anchor" href="#touint32v"></a> ToUInt32(v)</h3>
<p>ToUInt32 抽象操作将其参数<code>v</code>转换为 在<code>0</code>到<code>2^32-1</code>闭区间内的<code>2^32</code> 个整数之一。<br />
表达式<code>v &gt;&gt;&gt; 0</code>可以调用 ToUInt32 抽象操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToUInt32</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = ToNumber(v);</span><br><span class="line">  <span class="keyword">switch</span>(number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">NaN</span>: <span class="comment">// 仅做演示，实际无法这样检查NaN</span></span><br><span class="line">    <span class="keyword">case</span> +<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> +∞:</span><br><span class="line">    <span class="keyword">case</span> -∞:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;+0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向0取整</span></span><br><span class="line">  <span class="keyword">let</span> int = sign(number)×floor(abs(number));</span><br><span class="line">  <span class="comment">// 模2^32得到32位无符号整数</span></span><br><span class="line">  <span class="keyword">let</span> int32bit = int modulo <span class="number">2</span>^<span class="number">32</span>;</span><br><span class="line">  <span class="keyword">return</span> int32bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tobooleanv"><a class="markdownIt-Anchor" href="#tobooleanv"></a> ToBoolean(v)</h3>
<p>ToBoolean抽象操作将参数<code>v</code>转换为一个<code>Boolean</code>类型的值。<br />
表达式<code>!!v</code>可以调用ToBoolean抽象操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToBoolean</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = Type(v);</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Undefined&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Null&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Boolean&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Number&#x27;</span>:</span><br><span class="line">      <span class="keyword">switch</span>(v) &#123;</span><br><span class="line">        <span class="keyword">case</span> +<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">NaN</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;BigInt&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v !== <span class="number">0n</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;String&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> v.length != <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Symbol&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Object&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一元运算符"><a class="markdownIt-Anchor" href="#一元运算符"></a> 一元运算符</h2>
<p>只有一个操作数的运算符称为一元运算符，操作数写在运算符后面，包括：</p>
<h3 id="typeof"><a class="markdownIt-Anchor" href="#typeof"></a> typeof</h3>
<p>对一个值应用typeof得到的结果是一个字符串，字符串的值取决于值的数据类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> op</span><br></pre></td></tr></table></figure>
<p>注意typeof是一个运算符而不是函数，写法<code>typeof (op)</code>实际上是用括号括起了表达式而不是函数调用，类似<code>a + (b)</code>。</p>
<p>如果<code>op</code>是无法解析的引用（例如未声明的变量），则返回<code>&quot;undefined&quot;</code>。<br />
如果<code>op</code>是可以解析的引用，则会调用<code>GetValue(op)</code>对<code>op</code>进行求值，然后根据求值结果的类型，按照下表返回一个字符串。</p>
<table>
<thead>
<tr>
<th style="text-align:left">求值结果的类型</th>
<th style="text-align:left">返回字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Undefined</td>
<td style="text-align:left">“undefined”</td>
</tr>
<tr>
<td style="text-align:left">Null</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">“boolean”</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">“number”</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">“string”</td>
</tr>
<tr>
<td style="text-align:left">Symbol</td>
<td style="text-align:left">“symbol”</td>
</tr>
<tr>
<td style="text-align:left">BigInt</td>
<td style="text-align:left">“bigint”</td>
</tr>
<tr>
<td style="text-align:left">Object (没有实现[[Call]])</td>
<td style="text-align:left">“object”</td>
</tr>
<tr>
<td style="text-align:left">Object (实现了[[Call]])</td>
<td style="text-align:left">“function”</td>
</tr>
</tbody>
</table>
<p><code>Undefined</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>BigInt</code>这6个类型返回将类型小写得到的字符串。<code>Null</code>返回<code>&quot;object&quot;</code>，而<code>Object</code>根据是否是可调用的返回<code>&quot;object&quot;</code>或<code>&quot;function&quot;</code>。</p>
<p>因此，要检查引用是否是指定类型：</p>
<ul>
<li><code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>BigInt</code>使用<code>typeof</code>判断结果是否是小写的类型名字符串</li>
<li><code>Null</code>类型使用<code>op === null</code></li>
<li><code>Object</code>类型使用<code>op !== null &amp;&amp; (typeof op == 'object' || typeof op == 'function')</code></li>
<li>可调用的对象（函数）使用<code>typeof</code>判断结果是否为<code>function</code></li>
<li><code>Undefined</code>、无法解析引用（不存在的属性或变量）使用<code>typeof</code>判断结果为<code>undefined</code></li>
</ul>
<p>在已知<code>typeof</code>运算符的结果，反推操作数的类型时：</p>
<ul>
<li>如果返回值是<code>&quot;undefined&quot;</code>，则参数类型可能是<code>Undefined</code>，也可能是无法解析的引用。</li>
<li>如果返回值是<code>&quot;object&quot;</code>，则参数类型可能是<code>Null</code>，也可能是<code>Object</code>。</li>
<li>如果返回值是<code>&quot;function&quot;</code>，则参数类型是<code>Object</code></li>
<li>如果返回值是<code>&quot;boolean&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;bigint&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;symbol&quot;</code>，则参数类型就是对应的类型</li>
</ul>
<h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h3>
<p>删除一个对象上的自有属性，若成功删除或已经删除则返回<code>true</code>，否则返回<code>false</code>。<br />
若一个属性的<code>[[Configurable]]</code>特性为<code>false</code>则不能删除，而且严格模式下进行删除将抛出异常。</p>
<h3 id="void"><a class="markdownIt-Anchor" href="#void"></a> void</h3>
<p>对操作数求值（如果是操作数是一个引用，可能有副作用），然后返回<code>undefined</code></p>
<h3 id="递增"><a class="markdownIt-Anchor" href="#递增"></a> 递增</h3>
<p>递增运算符使用<code>ToNumeric</code>抽象操作将操作数转换为<code>Number</code>或<code>BigInt</code>，然后使用加法运算符将其与<code>1</code>相加得到新值，再赋值给操作数。<br />
根据操作数位置的不同，可以将递增运算符分为前缀递增运算符和后缀递增运算符，返回的结果也不同。</p>
<p>前缀递增运算符<code>++v</code>返回的是新值，等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> ++(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = ToNumeric(a);</span><br><span class="line">  <span class="keyword">let</span> one;</span><br><span class="line">  <span class="keyword">if</span>(Type(oldValue) == <span class="string">&#x27;BigInt&#x27;</span>) &#123;</span><br><span class="line">    one = <span class="number">1n</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    one = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newValue = oldValue + one;</span><br><span class="line">  a = newValue;</span><br><span class="line">  <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后缀递增运算符<code>v++</code>返回的是旧值，等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> ++(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = ToNumeric(a);</span><br><span class="line">  <span class="keyword">let</span> one;</span><br><span class="line">  <span class="keyword">if</span>(Type(oldValue) == <span class="string">&#x27;BigInt&#x27;</span>) &#123;</span><br><span class="line">    one = <span class="number">1n</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    one = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newValue = oldValue + one;</span><br><span class="line">  a = newValue;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递减"><a class="markdownIt-Anchor" href="#递减"></a> 递减</h3>
<p>和递增运算符类似。<br />
递减运算符使用<code>ToNumeric</code>抽象操作将操作数转换为<code>Number</code>或<code>BigInt</code>，然后使用减法运算符将其与<code>1</code>相减得到新值，再赋值给操作数。<br />
根据操作数位置的不同，可以将递减运算符分为前缀递减运算符和后缀递减运算符，返回的结果也不同。</p>
<h3 id="一元加"><a class="markdownIt-Anchor" href="#一元加"></a> 一元加</h3>
<p>一元加运算符<code>+op</code>返回<code>ToNumber(op)</code>，即将操作数转换为<code>Number</code>的结果。<br />
基本上等价于<code>Number(op)</code>。<br />
注意<code>BigInt</code>类型调用<code>ToNumber</code>将抛出异常，因此不能使用一元加运算符。</p>
<h3 id="一元减"><a class="markdownIt-Anchor" href="#一元减"></a> 一元减</h3>
<p>一元减运算符使用<code>ToNumeric</code>抽象操作将操作数转换为<code>Number</code>或<code>BigInt</code>得到<code>numOp</code>，然后返回对<code>numOp</code>取负的结果。<br />
当<code>numOp</code>为<code>NaN</code>时返回<code>NaN</code>而不用取负。<br />
当<code>numOp</code>为<code>0n</code>时返回<code>0n</code>而不用取负。</p>
<h2 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h2>
<p>位运算符使用<code>ToNumeric</code>将操作数转换为<code>Number</code>或<code>BigInt</code>类型得到<code>numOp</code>。<br />
如果转换后的操作数类型不同，则抛出 TypeError 异常</p>
<h3 id="按位取反"><a class="markdownIt-Anchor" href="#按位取反"></a> 按位取反</h3>
<ul>
<li>如果<code>numOp</code>是<code>Number</code>类型，则使用<code>ToInt32</code>抽象操作将<code>numOp</code>转换为32位有符号整数，然后按位取反，得到的结果也是32位有符号整数。</li>
<li>如果<code>numOp</code>是<code>BigInt</code>类型，则返回其反码，即<code>-numOp-1</code></li>
</ul>
<h3 id="按位与"><a class="markdownIt-Anchor" href="#按位与"></a> 按位与</h3>
<ul>
<li>如果转换后是<code>Number</code>类型：
<ul>
<li>按位与运算符<code>op1 &amp; op2</code>返回<code>ToInt32(numOp1) &amp; ToUInt32(numOp2)</code>，即将<code>numOp1</code>转换为32位有符号整数，<code>numOp2</code>转换为32位无符号整数，再按位与的结果，结果看作一个32位有符号整数。</li>
</ul>
</li>
<li>如果转换后是<code>BigInt</code>类型：
<ul>
<li>将<code>numOp1</code>和<code>numOp2</code>看作无穷长度补码数进行按位与，具体算法如下：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> &amp;(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// x = numOp1, y = numOp2</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0n</span>;</span><br><span class="line">  <span class="keyword">let</span> shift = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 低位按位与</span></span><br><span class="line">  <span class="comment">// 正数不断右移直到变成0</span></span><br><span class="line">  <span class="comment">// 负数不断右移直到变成-1</span></span><br><span class="line">  <span class="keyword">while</span>((x != <span class="number">0</span> &amp;&amp; x != -<span class="number">1</span>) || (y != <span class="number">0</span> &amp;&amp; y != -<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDigit = x modulo <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> yDigit = y modulo <span class="number">2</span>;</span><br><span class="line">    result += <span class="number">2</span>**shift * (xDigit &amp; yDigit);</span><br><span class="line">    shift += <span class="number">1</span>;</span><br><span class="line">    x = (x - xDigit) / <span class="number">2</span>;</span><br><span class="line">    y = (y - yDigit) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时只有四种可能：</span></span><br><span class="line">  <span class="comment">// x = 0, y = 0  =&gt; tmp = 0</span></span><br><span class="line">  <span class="comment">// x = 0, y = -1 =&gt; tmp = 0</span></span><br><span class="line">  <span class="comment">// x = -1, y = 0 =&gt; tmp = 0</span></span><br><span class="line">  <span class="comment">// x = -1, y = -1 =&gt; tmp = 1</span></span><br><span class="line">  <span class="keyword">let</span> tmp = (x modulo <span class="number">2</span>) &amp; (y modulo <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 都是正数不用符号扩展</span></span><br><span class="line">  <span class="comment">// 一正一负，高位1&amp;0必为0也不用处理</span></span><br><span class="line">  <span class="keyword">if</span>(tmp != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// x和y都是负数</span></span><br><span class="line">    <span class="comment">// 已经右移到了x和y都是全1的情况，</span></span><br><span class="line">    <span class="comment">// 进行符号扩展</span></span><br><span class="line">    <span class="comment">// shift + 1位补码数与符号扩展成无穷位补码数在数值上相等</span></span><br><span class="line">    result -= <span class="number">2</span>**shift</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按位或"><a class="markdownIt-Anchor" href="#按位或"></a> 按位或</h3>
<ul>
<li>如果转换后是<code>Number</code>类型：
<ul>
<li>按位与运算符<code>op1 | op2</code>返回<code>ToInt32(numOp1) | ToUInt32(numOp2)</code>，即将<code>numOp1</code>转换为32位有符号整数，<code>numOp2</code>转换为32位无符号整数，再按位或的结果，结果看作一个32位有符号整数。</li>
</ul>
</li>
<li>如果转换后是<code>BigInt</code>类型：
<ul>
<li>将<code>numOp1</code>和<code>numOp2</code>看作无穷长度补码数进行按位或，具体算法如下：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> |(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// x = numOp1, y = numOp2</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0n</span>;</span><br><span class="line">  <span class="keyword">let</span> shift = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 低位按位与</span></span><br><span class="line">  <span class="comment">// 正数不断右移直到变成0</span></span><br><span class="line">  <span class="comment">// 负数不断右移直到变成-1</span></span><br><span class="line">  <span class="keyword">while</span>((x != <span class="number">0</span> &amp;&amp; x != -<span class="number">1</span>) || (y != <span class="number">0</span> &amp;&amp; y != -<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDigit = x modulo <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> yDigit = y modulo <span class="number">2</span>;</span><br><span class="line">    result += <span class="number">2</span>**shift * (xDigit | yDigit);</span><br><span class="line">    shift += <span class="number">1</span>;</span><br><span class="line">    x = (x - xDigit) / <span class="number">2</span>;</span><br><span class="line">    y = (y - yDigit) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时只有四种可能：</span></span><br><span class="line">  <span class="comment">// x = 0, y = 0  =&gt; tmp = 0</span></span><br><span class="line">  <span class="comment">// x = 0, y = -1 =&gt; tmp = 1</span></span><br><span class="line">  <span class="comment">// x = -1, y = 0 =&gt; tmp = 1</span></span><br><span class="line">  <span class="comment">// x = -1, y = -1 =&gt; tmp = 1</span></span><br><span class="line">  <span class="keyword">let</span> tmp = (x modulo <span class="number">2</span>) | (y modulo <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 都是正数不用符号扩展</span></span><br><span class="line">  <span class="comment">// 一正一负，高位1|0必为1需要扩展</span></span><br><span class="line">  <span class="keyword">if</span>(tmp != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// x和y都是负数</span></span><br><span class="line">    <span class="comment">// 已经右移到了x和y都是全1的情况，</span></span><br><span class="line">    <span class="comment">// 进行符号扩展</span></span><br><span class="line">    <span class="comment">// shift + 1位补码数与符号扩展成无穷位补码数在数值上相等</span></span><br><span class="line">    result -= <span class="number">2</span>**shift</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按位异或"><a class="markdownIt-Anchor" href="#按位异或"></a> 按位异或</h3>
<ul>
<li>如果转换后是<code>Number</code>类型：
<ul>
<li>按位与运算符<code>op1 ^ op2</code>返回<code>ToInt32(numOp1) ^ ToUInt32(numOp2)</code>，即将<code>numOp1</code>转换为32位有符号整数，<code>numOp2</code>转换为32位无符号整数，再按位异或的结果，结果看作一个32位有符号整数。</li>
</ul>
</li>
<li>如果转换后是<code>BigInt</code>类型：
<ul>
<li>将<code>numOp1</code>和<code>numOp2</code>看作无穷长度补码数进行按位异或，具体算法如下：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> ^(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// x = numOp1, y = numOp2</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0n</span>;</span><br><span class="line">  <span class="keyword">let</span> shift = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 低位按位与</span></span><br><span class="line">  <span class="comment">// 正数不断右移直到变成0</span></span><br><span class="line">  <span class="comment">// 负数不断右移直到变成-1</span></span><br><span class="line">  <span class="keyword">while</span>((x != <span class="number">0</span> &amp;&amp; x != -<span class="number">1</span>) || (y != <span class="number">0</span> &amp;&amp; y != -<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDigit = x modulo <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> yDigit = y modulo <span class="number">2</span>;</span><br><span class="line">    result += <span class="number">2</span>**shift * (xDigit ^ yDigit);</span><br><span class="line">    shift += <span class="number">1</span>;</span><br><span class="line">    x = (x - xDigit) / <span class="number">2</span>;</span><br><span class="line">    y = (y - yDigit) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时只有四种可能：</span></span><br><span class="line">  <span class="comment">// x = 0, y = 0  =&gt; tmp = 0</span></span><br><span class="line">  <span class="comment">// x = 0, y = -1 =&gt; tmp = 1</span></span><br><span class="line">  <span class="comment">// x = -1, y = 0 =&gt; tmp = 1</span></span><br><span class="line">  <span class="comment">// x = -1, y = -1 =&gt; tmp = 0</span></span><br><span class="line">  <span class="keyword">let</span> tmp = (x modulo <span class="number">2</span>) ^ (y modulo <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 同正同负1^1或0^0都为0不用符号扩展</span></span><br><span class="line">  <span class="comment">// 一正一负，高位1^0必为1需要扩展</span></span><br><span class="line">  <span class="keyword">if</span>(tmp != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// x和y都是负数</span></span><br><span class="line">    <span class="comment">// 已经右移到了x和y都是全1的情况，</span></span><br><span class="line">    <span class="comment">// 进行符号扩展</span></span><br><span class="line">    <span class="comment">// shift + 1位补码数与符号扩展成无穷位补码数在数值上相等</span></span><br><span class="line">    result -= <span class="number">2</span>**shift</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移位运算符"><a class="markdownIt-Anchor" href="#移位运算符"></a> 移位运算符</h2>
<p>移位运算符中，左操作数是进行移位的数，右操作数是移位量。<br />
移位运算符将两个操作数使用<code>ToNumeric</code>抽象操作转换为<code>Number</code>或<code>BigInt</code>类型得到<code>numOp1</code>和<code>numOp2</code>后再进行计算，如果转换后两个数的类型不同，则抛出异常。</p>
<ul>
<li>如果转换后是<code>Number</code>类型，移位量<code>numOp2</code>会被转换为32位无符号整数，然后使用<code>module 32</code>运算截取低5位将其限定在0到31之间，等价于使用掩码<code>0x1F</code>按位与。</li>
<li>如果转换后是<code>BigInt</code>类型时，将<code>numOp1</code>当成无限长度的二进制补码数。</li>
</ul>
<h3 id="左移"><a class="markdownIt-Anchor" href="#左移"></a> 左移</h3>
<ul>
<li>如果转换后是<code>Number</code>类型：
<ul>
<li>左移运算符<code>op1 &lt;&lt; op2</code>，返回对<code>ToInt32(numOp1)</code>左移<code>ToUint32(numOp2) &amp; 0x1F</code>的结果，结果是一个32位有符号整数。</li>
</ul>
</li>
<li>如果转换后是<code>BigInt</code>类型：
<ol>
<li>如果<code>numOp2 &lt; 0n</code>，返回将<code>numOp1 ÷ 2^(-numOp2)</code>向下舍入到最近的整数得到的值</li>
<li>否则，返回<code>numOp1 × 2^(numOp2)</code></li>
</ol>
</li>
</ul>
<h3 id="算术右移有符号右移"><a class="markdownIt-Anchor" href="#算术右移有符号右移"></a> 算术右移/有符号右移</h3>
<ul>
<li>如果转换后是<code>Number</code>类型：
<ul>
<li>算术右移运算符<code>op1 &gt;&gt; op2</code>返回对<code>ToInt32(numOp1)</code>算术右移（在最左侧补的值取决于符号位）<code>ToUint32(numOp2) &amp; 0x1F</code>的结果，结果是一个32位有符号整数。</li>
</ul>
</li>
<li>如果转换后是<code>BigInt</code>类型，返回<code>numOp1 &lt;&lt; -numOp2</code>，即：
<ol>
<li>如果<code>numOp2 &gt; 0n</code>，返回将<code>numOp1 ÷ 2^(numOp2)</code>向下舍入到最近的整数得到的值</li>
<li>否则，返回<code>numOp1 × 2^(-numOp2)</code></li>
</ol>
</li>
</ul>
<h3 id="逻辑右移无符号右移"><a class="markdownIt-Anchor" href="#逻辑右移无符号右移"></a> 逻辑右移/无符号右移</h3>
<ul>
<li>如果转换后是<code>Number</code>类型：
<ul>
<li>逻辑右移运算符<code>op1 &gt;&gt;&gt; op2</code>返回对<code>ToUInt32(numOp1)</code>逻辑右移（在最左侧补<code>0</code>）<code>ToUint32(numOp2) &amp; 0x1F</code>的结果，结果是一个32位无符号整数。</li>
</ul>
</li>
<li>如果转换后是<code>BigInt</code>类型：
<ul>
<li>抛出 TypeError 异常，即<code>BigInt</code>无法进行逻辑右移，因为<code>BigInt</code>将<code>numOp1</code>视为无限长度的二进制补码数，最左侧是无限远处，做不到在最左侧补<code>0</code>。</li>
</ul>
</li>
</ul>
<h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h2>
<p>逻辑非运算符的结果是一个<code>Boolean</code>类型值。<br />
逻辑与、逻辑或、空值合并运算符得到的是对左侧或右侧表达式求值的结果，因此结果不一定是<code>Boolean</code>类型。逻辑与和逻辑或只会将左侧表达式转换为<code>Boolean</code>值，然后根据这个布尔值决定返回左侧还是右侧求值结果。</p>
<h3 id="逻辑非"><a class="markdownIt-Anchor" href="#逻辑非"></a> 逻辑非</h3>
<p>逻辑非运算符<code>!op</code>返回<code>!ToBoolean(op)</code>，即将操作数转换为布尔值，然后取反，结果仍是一个布尔值。</p>
<h3 id="逻辑与"><a class="markdownIt-Anchor" href="#逻辑与"></a> 逻辑与</h3>
<p>逻辑与运算符<code>op1 &amp;&amp; op2</code><br />
首先计算左侧操作数表达式<code>lval = GetValue(op1)</code>，<br />
若<code>ToBoolean(lval)</code>为<code>false</code>，返回<code>lval</code>，<br />
否则返回<code>GetValue(op2)</code></p>
<h3 id="逻辑或"><a class="markdownIt-Anchor" href="#逻辑或"></a> 逻辑或</h3>
<p>逻辑或运算符<code>op1 || op2</code><br />
首先计算左侧操作数表达式<code>lval = GetValue(op1)</code>，<br />
若<code>ToBoolean(lval)</code>为<code>true</code>，返回<code>lval</code>，<br />
否则返回<code>GetValue(op2)</code></p>
<h3 id="空值合并"><a class="markdownIt-Anchor" href="#空值合并"></a> 空值合并</h3>
<p>空值合并运算符<code>op1 ?? op2</code><br />
首先计算左侧操作数表达式<code>lval = GetValue(op1)</code>，<br />
若<code>lval</code>为<code>undefined</code>（包括属性不存在的情况）或<code>null</code>，则返回<code>GetValue(op2)</code><br />
否则返回<code>lval</code></p>
<p>即：若左操作数不是空值则返回它，若是空值则返回右边。<br />
注意如果左操作数是一个无法解析的引用，也不是一个属性引用，则会抛出异常。</p>
<h2 id="乘性运算符"><a class="markdownIt-Anchor" href="#乘性运算符"></a> 乘性运算符</h2>
<p>乘性运算符将两个操作数使用<code>ToNumeric</code>抽象操作转换为<code>Number</code>或<code>BigInt</code>类型得到<code>numOp1</code>和<code>numOp2</code>后再进行计算，如果转换后两个操作数的类型不同，则抛出异常。</p>
<h3 id="乘法"><a class="markdownIt-Anchor" href="#乘法"></a> 乘法</h3>
<ul>
<li>如果转换后类型是<code>Number</code>，执行双精度浮点乘法运算：
<ul>
<li>乘法运算符是可交换的，但由于有限的精度，乘法运算符不总是可结合的。</li>
<li>转换后的任何操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>操作数符号相同，结果的符号为正，符号相反，结果的符号为负。</li>
<li>无穷乘0为<code>NaN</code></li>
<li>无穷乘无穷为有符号的无穷</li>
<li>无穷乘有限非零值为有符号的无穷</li>
<li>若结果太大无法表示则为有符号的无穷，若结果太小无法表示则为有符号的0</li>
</ul>
</li>
<li>如果转换后类型是<code>BigInt</code>，执行整数乘法运算：
<ul>
<li>不管得到的结果有多大，永远返回精确的数学值</li>
</ul>
</li>
</ul>
<h3 id="除法"><a class="markdownIt-Anchor" href="#除法"></a> 除法</h3>
<ul>
<li>如果转换后类型是<code>Number</code>，执行双精度浮点除法运算：
<ul>
<li>除法运算符采用的是双精度浮点除法，即使操作数均为整数时也采用浮点除法。</li>
<li>转换后的任何操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>操作数符号相同，结果的符号为正，符号相反，结果的符号为负。</li>
<li>无穷除以无穷为<code>NaN</code></li>
<li>无穷除以有限值为有符号的无穷</li>
<li>有限值除以无穷为有符号的<code>0</code></li>
<li><code>0</code>除以<code>0</code>为<code>NaN</code></li>
<li><code>0</code>除以有限非零值为有符号的0</li>
<li>有限非零值除以<code>0</code>为有符号的无穷</li>
<li>若结果太大无法表示则为有符号的无穷，若结果太小无法表示则为有符号的<code>0</code></li>
</ul>
</li>
<li>如果转换后类型是<code>BigInt</code>，执行整数除法运算：
<ul>
<li>计算两数相除得到的商，然后将商向0舍入。即简单的舍去小数部分，这类似于C/C++等语言中的整数除法运算。</li>
</ul>
</li>
</ul>
<h3 id="取余"><a class="markdownIt-Anchor" href="#取余"></a> 取余</h3>
<ul>
<li>如果转换后类型是<code>Number</code>，执行双精度浮点除法运算来得到余数：
<ul>
<li>取余运算符也接受浮点操作数，不像C或C++中限制只能用对整数使用取余运算符。</li>
<li>转换后的任何操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>结果的符号等于被除数<code>op1</code>的符号</li>
<li>如果被除数是无穷，或者除数是零，或者两者都是，则结果为<code>NaN</code></li>
<li>如果被除数是有限值，并且除数是无穷，则结果等于被除数</li>
<li>如果被除数为零，并且除数为有限非零值，则结果等于被除数</li>
<li>其余情况<code>a % b = a - trunc(a/b) * b</code>，其中<code>trunc</code>为截断函数，舍去小数位<code>trunc(-2.4) = -2</code>、<code>trunc(2.6) = 2</code>。结果会按照IEEE 754向偶数舍入规则舍入到最接近的可表示值。符号与被除数一致。</li>
</ul>
</li>
<li>如果转换后类型是<code>BigInt</code>，执行整数除法运算得到余数：
<ul>
<li>若除数为<code>0n</code>，则抛出异常</li>
<li>若被除数为<code>0n</code>，返回<code>0n</code></li>
<li>其他情况<code>a % b = a - trunc(a/b) * b</code>，其中<code>trunc</code>为截断函数，舍去小数位<code>trunc(-2.4) = -2</code>、<code>trunc(2.6) = 2</code>。符号与被除数一致。</li>
</ul>
</li>
</ul>
<h3 id="指数"><a class="markdownIt-Anchor" href="#指数"></a> 指数</h3>
<ul>
<li>若转换后类型为<code>Number</code>，需要注意：
<ul>
<li>指数为<code>0</code>时结果为<code>1</code>，不管底数是什么（即便是<code>NaN</code>）</li>
<li>指数为<code>NaN</code>，或者底数为<code>NaN</code>且指数非<code>0</code>，又或者底数为<code>1</code>指数为无穷，则结果为<code>NaN</code></li>
</ul>
</li>
<li>若转换后类型为<code>BigInt</code>，需要注意：
<ul>
<li>如果指数小于<code>0n</code>，抛出异常</li>
<li>如果指数是<code>0n</code>，返回<code>1n</code></li>
</ul>
</li>
</ul>
<h2 id="加性运算符"><a class="markdownIt-Anchor" href="#加性运算符"></a> 加性运算符</h2>
<p>加减法运算符通过<code>a - b === a + (-b)</code>可以互相转换</p>
<h3 id="加法"><a class="markdownIt-Anchor" href="#加法"></a> 加法</h3>
<p>加法运算符<code>op1 + op2</code>执行字符串连接，或者数字加法。</p>
<ul>
<li>加法运算符使用<code>ToPrimitive</code>将操作数转换为原始值<code>op1Prim</code>和<code>op2Prim</code>，如果有任何一个是字符串，则返回<code>ToString(op1Prim)</code>与<code>ToString(op2Prim)</code>连接的结果。</li>
<li>如果都不是字符串，加法运算符将<code>op1Prim</code>和<code>op2Prim</code>使用<code>ToNumeric</code>抽象操作转换为<code>Number</code>或<code>BigInt</code>类型后再进行计算，如果转换后两个操作数的类型不同，则抛出异常。
<ul>
<li>如果转换后类型是<code>Number</code>，执行双精度浮点加法运算：
<ul>
<li>如果任一操作数为<code>NaN</code>，则结果为<code>NaN</code>。</li>
<li>两个相反符号的无穷大之和为<code>NaN</code></li>
<li>两个相同符号的无穷大之和为该符号的无穷大。</li>
<li>无穷大与有限值之和等于该符号的无穷大</li>
<li>两个负零之和为<code>-0</code></li>
<li>两个正零或两个符号相反的零的和为<code>+0</code></li>
<li>零和非零有限值之和等于该非零操作数</li>
<li>模相同符号相反的两个非零有限值的和为<code>+0</code></li>
</ul>
</li>
<li>如果转换后类型是<code>BigInt</code>，执行整数加法运算：
<ul>
<li>不管得到的结果有多大，永远返回精确的数学值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="减法"><a class="markdownIt-Anchor" href="#减法"></a> 减法</h3>
<p>减法运算符<code>op1 - op2</code>执行数字减法。<br />
减法运算符将两个操作数使用<code>ToNumeric</code>抽象操作转换为<code>Number</code>或<code>BigInt</code>类型后再进行计算，如果转换后两个操作数的类型不同，则抛出异常。</p>
<ul>
<li>如果转换后类型是<code>Number</code>：
<ul>
<li>返回<code>ToNumeric(op1) + (-ToNumeric(op2))</code></li>
</ul>
</li>
<li>如果转换后类型是<code>BigInt</code>，执行整数减法运算：
<ul>
<li>不管得到的结果有多大，永远返回精确的数学值</li>
</ul>
</li>
</ul>
<h2 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h2>
<p>关系运算符返回一个布尔值。</p>
<h3 id="小于"><a class="markdownIt-Anchor" href="#小于"></a> 小于(&lt;)</h3>
<p>小于运算符<code>op1 &lt; op2</code>，将两个操作数转为原始值。</p>
<ul>
<li>如果原始值都是<code>String</code>，则进行字符串比较。</li>
<li>如果一个是<code>String</code>，一个是<code>BigInt</code>，则将<code>String</code>转为<code>BigInt</code>再比较，要注意如果<code>String</code>转换中间结果是<code>NaN</code>，则返回<code>false</code>。</li>
<li>如果一个是<code>Number</code>，一个是<code>BigInt</code>：
<ul>
<li>若<code>Number</code>是<code>NaN</code>则返回<code>false</code></li>
<li>若<code>Number</code>是无穷，则将其当成无穷值与<code>BigInt</code>比较</li>
<li>其他情况比较两个数的数学值大小</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>&lt;(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lVal = ToPrimitive(op1, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> rVal = ToPrimitive(op2, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lVal.startsWith(rVal)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal.startsWith(lVal)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> i = firstDifferentChar(lVal, rVal);</span><br><span class="line">    <span class="keyword">return</span> codeUnit(lVal[i]) &lt; codeUnit(rVal[i]);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;BigInt&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 不允许无穷、小数点和e</span></span><br><span class="line">      <span class="comment">// 如果结果是NaN就返回NaN</span></span><br><span class="line">      <span class="comment">// 如果不是NaN，返回用BigInt表示的精确值</span></span><br><span class="line">      <span class="keyword">let</span> rValBigInt = StringToBigInt(rVal);</span><br><span class="line">      <span class="keyword">if</span>(rValBigInt is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> mathLess(lVal, rValBigInt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;BigInt&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> lValBigInt = StringToBigInt(rVal);</span><br><span class="line">      <span class="keyword">if</span>(lValBigInt is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> mathLess(lValBigInt, rVal);</span><br><span class="line">    &#125;</span><br><span class="line">    lVal = ToNumeric((lVal);</span><br><span class="line">    rVal = ToNumeric(rVal);</span><br><span class="line">    <span class="keyword">if</span>(Type(lVal) == Type(rVal)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;Number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal === rVal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is +<span class="number">0</span> &amp;&amp; rVal is -<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is -<span class="number">0</span> &amp;&amp; rVal is +<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is +oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rVal is +oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(rVal is -oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is -oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> mathLess(lVal, rVal);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mathLess(lVal, rVal);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断言：一个Number一个BigInt</span></span><br><span class="line">    <span class="comment">// 如果Number那个值是NaN</span></span><br><span class="line">    <span class="keyword">if</span>(lVal is <span class="literal">NaN</span> || rVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果Number那个值是左负无穷，或者右正无穷</span></span><br><span class="line">    <span class="keyword">if</span>(lVal is -oo || rVal is +oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is +oo || rVal is -oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> mathLess(lVal, rVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大于"><a class="markdownIt-Anchor" href="#大于"></a> 大于(&gt;)</h3>
<p>大于运算符<code>op1 &gt; op2</code>返回<code>op2 &lt; op1</code>，但求值顺序仍然是先<code>op1</code>后<code>op2</code></p>
<h3 id="小于等于"><a class="markdownIt-Anchor" href="#小于等于"></a> 小于等于(&lt;=)</h3>
<p>小于等于运算符<code>op1 &lt;= op2</code>返回<code>op2 &gt;= op1</code>，但求值顺序仍然是先<code>op1</code>后<code>op2</code></p>
<h3 id="大于等于"><a class="markdownIt-Anchor" href="#大于等于"></a> 大于等于(&gt;=)</h3>
<p>大于等于运算符<code>op1 &gt;= op2</code><br />
除了任何一个操作数被转为<code>NaN</code>的情况外，等于<code>!(op1 &lt; op2)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>&gt;=(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lVal = ToPrimitive(op1, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> rVal = ToPrimitive(op2, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lVal.startsWith(rVal)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(rVal.startsWith(lVal)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> i = firstDifferentChar(lVal, rVal);</span><br><span class="line">    <span class="keyword">return</span> !(codeUnit(lVal[i]) &lt; codeUnit(rVal[i]));</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;BigInt&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 不允许无穷、小数点和e</span></span><br><span class="line">      <span class="comment">// 如果结果是NaN就返回NaN</span></span><br><span class="line">      <span class="comment">// 如果不是NaN，返回用BigInt表示的精确值</span></span><br><span class="line">      <span class="keyword">let</span> rValBigInt = StringToBigInt(rVal);</span><br><span class="line">      <span class="keyword">if</span>(rValBigInt is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> !(mathLess(lVal, rValBigInt));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(rVal) == <span class="string">&#x27;BigInt&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> lValBigInt = StringToBigInt(rVal);</span><br><span class="line">      <span class="keyword">if</span>(lValBigInt is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> !(mathLess(lValBigInt, rVal));</span><br><span class="line">    &#125;</span><br><span class="line">    lVal = ToNumeric((lVal);</span><br><span class="line">    rVal = ToNumeric(rVal);</span><br><span class="line">    <span class="keyword">if</span>(Type(lVal) == Type(rVal)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Type(lVal) == <span class="string">&#x27;Number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal === rVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is +<span class="number">0</span> &amp;&amp; rVal is -<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is -<span class="number">0</span> &amp;&amp; rVal is +<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is +oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(rVal is +oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rVal is -oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(lVal is -oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> !(mathLess(lVal, rVal));</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(mathLess(lVal, rVal));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断言：一个Number一个BigInt</span></span><br><span class="line">    <span class="comment">// 如果Number那个值是NaN</span></span><br><span class="line">    <span class="keyword">if</span>(lVal is <span class="literal">NaN</span> || rVal is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果Number那个值是左负无穷，或者右正无穷</span></span><br><span class="line">    <span class="keyword">if</span>(lVal is -oo || rVal is +oo) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(lVal is +oo || rVal is -oo) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> !(mathLess(lVal, rVal));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof"><a class="markdownIt-Anchor" href="#instanceof"></a> instanceof</h3>
<p><code>instanceof</code>运算符<code>O instanceof C</code>用于确定<code>O</code>是否是<code>C</code>的实例。<br />
首先尝试调用<code>C</code>的<code>Symbol.hasInstance</code>方法。<br />
如果没有，就检查<code>C.prototype</code>是否在<code>O</code>的原型链上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">O, C</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> C[<span class="built_in">Symbol</span>.hasInstance] == <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToBoolean(C[<span class="built_in">Symbol</span>.hasInstance](O));</span><br><span class="line">  <span class="keyword">if</span>(Type(O) !== <span class="string">&#x27;Object&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    O = O.__proto__</span><br><span class="line">    <span class="keyword">if</span>(O === C.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(O !== <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="in"><a class="markdownIt-Anchor" href="#in"></a> in</h3>
<p><code>in</code>运算符<code>prop in obj</code>将<code>prop</code>操作数转为原始值，然后转换为<code>Symbol</code>或<code>String</code>类型的属性键<code>propKey</code>，最后检查对象<code>obj</code>是否具有自有属性或继承属性<code>propKey</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">in</span>(<span class="params">prop, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> key = ToPrimitive(prop, <span class="string">&#x27;string&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(Type(key) != <span class="string">&#x27;Symbol&#x27;</span>)</span><br><span class="line">    key = ToString(key);</span><br><span class="line">  <span class="keyword">while</span>(obj !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.HasOwnProperty(key))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    obj = obj.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相等运算符"><a class="markdownIt-Anchor" href="#相等运算符"></a> 相等运算符</h2>
<p>相等运算符返回一个布尔值。</p>
<h3 id="相等"><a class="markdownIt-Anchor" href="#相等"></a> 相等(==)</h3>
<p>相等运算符<code>op1 == op2</code>对于类型相同的两个变量会调用严格相等运算符，对于类型不同的变量会进行类型转换然后再次调用相等运算符。</p>
<ol>
<li>一个操作数为<code>Null</code>，另一个操作数为<code>Undefined</code>，结果为<code>true</code></li>
<li>一个操作数为<code>Number</code>，另一个操作数为<code>String</code>，使用<code>ToNumber</code>抽象操作将字符串转为数字，再次调用相等运算符比较。</li>
<li>一个操作数为<code>BigInt</code>，另一个操作数为<code>String</code>，使用<code>StringToBigInt</code>抽象操作将字符串转为数字（结果可能是<code>NaN</code>也可能是<code>BigInt</code>值），如果结果是<code>NaN</code>则返回<code>false</code>，否则将两个<code>BigInt</code>值再次调用相等运算符比较。</li>
<li>任意一个操作数为<code>Boolean</code>，使用<code>ToNumber</code>抽象操作将布尔值转为数字，再次调用相等运算符比较。</li>
<li>一个操作数为<code>String|Number|BigInt|Symbol</code>，另一个操作数为<code>Object</code>，使用<code>ToPrimitive</code>抽象操作将对象转换为原始值，再次调用相等运算符比较。</li>
<li>一个操作数为<code>BigInt</code>，另一个操作数为<code>Number</code>，如果<code>Number</code>为<code>NaN</code>、<code>+oo</code>或<code>-oo</code>，则返回<code>false</code>，否则比较两个值的数学值是否相等。</li>
<li>其他情况，返回<code>false</code></li>
</ol>
<p>由于类型转换，相等运算符不总是可传递的，例如<code>new String(&quot;a&quot;) == &quot;a&quot;</code>为<code>true</code>，但<code>new String(&quot;a&quot;) == new String(&quot;a&quot;)</code>为<code>false</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>==(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Same(Type(op1), Type(op2))) <span class="keyword">return</span> op1 === op2;</span><br><span class="line">  <span class="keyword">if</span>(op1 is <span class="literal">null</span> &amp;&amp; op2 is <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(op1 is <span class="literal">undefined</span> &amp;&amp; op2 is <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Number&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;String&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op1 == ToNumber(op2);</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToNumber(op1) == op2;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;BigInt&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 不允许无穷、小数点和e</span></span><br><span class="line">    <span class="comment">// 如果结果是NaN就返回NaN</span></span><br><span class="line">    <span class="comment">// 如果不是NaN，返回用BigInt表示的精确值</span></span><br><span class="line">    <span class="keyword">let</span> op2BigInt = StringToBigInt(op2);</span><br><span class="line">    <span class="keyword">if</span>(op2BigInt is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> op1 == op2BigInt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;String&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;BigInt&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op2 == op1;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Boolean&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToNumber(op1) == op2;</span><br><span class="line">  <span class="keyword">if</span>(Type(op2) is <span class="string">&#x27;Boolean&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op1 == ToNumber(op2);</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;String|Number|BigInt|Symbol&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;Object&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op1 == ToPrimitive(op2);</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Object&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;String|Number|BigInt|Symbol&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ToPrimitive(op1) == op2;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;BigInt&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;Number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(op2 is <span class="literal">NaN</span> || op2 is +oo | op2 is -oo)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> MathEqual(op1, op2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Number&#x27;</span> &amp;&amp; Type(op2) is <span class="string">&#x27;BigInt&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> op2 == op1;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不等"><a class="markdownIt-Anchor" href="#不等"></a> 不等(!=)</h3>
<p>不等运算符<code>op1 != op2</code>返回<code>!(op1 == op2)</code>。</p>
<h3 id="严格相等"><a class="markdownIt-Anchor" href="#严格相等"></a> 严格相等(===)</h3>
<p>严格相等运算符<code>op1 === op2</code>的基本要求是两个变量类型相同，值也相同。如果变量类型不相同，它不会进行类型转换，而是直接返回<code>false</code>。<br />
8种基本类型中：</p>
<ul>
<li><code>Number</code>类型：
<ul>
<li>任何一个操作数是<code>NaN</code>，则返回<code>false</code>，即<code>NaN</code>不和任何数字相等。</li>
<li>两个数学值相等的<code>Number</code>是相等的。</li>
<li><code>+0</code>和<code>-0</code>也被认为是相等的。</li>
</ul>
</li>
<li><code>BigInt</code>类型的值相同，意味着二者的数学值相等</li>
<li><code>Undefined</code>类型的值总是相同的，因为该类型只有一个值。</li>
<li><code>Null</code>类型的值总是相同的，因为该类型只有一个值。</li>
<li><code>String</code>类型的值相同意味着字符串长度相同，代码单元也完全相同。</li>
<li><code>Boolean</code>类型的值相同意味着同为<code>true</code>或同为<code>false</code>。</li>
<li><code>Symbol</code>类型的值相同意味着二者是同一个<code>Symbol</code>，即两者在内存中的地址相同。</li>
<li><code>Object</code>类型的值相同意味着二者是同一个<code>Object</code>，即两者在内存中的地址相同。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operator</span>===(<span class="params">op1, op2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(notSame(Type(op1), Type(op2))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(op1 is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(op2 is <span class="literal">NaN</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(mathEqual(op1,op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(op1 is +<span class="number">0</span> &amp;&amp; op2 is -<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(op1 is -<span class="number">0</span> &amp;&amp; op2 is +<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;BigInt&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> MathEqual(op1, op2);</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Undefined&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Null&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;String&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(codeUnitAllSame(op1, op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Boolean&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(op1 is <span class="literal">true</span> &amp;&amp; op2 is <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(op1 is <span class="literal">false</span> &amp;&amp; op2 is <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Symbol&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sameSymbol(op1, op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(Type(op1) is <span class="string">&#x27;Object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sameObject(op1, op2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理nan与0的严格相等"><a class="markdownIt-Anchor" href="#处理nan与0的严格相等"></a> 处理NaN与0的严格相等</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(op1, op2)</span><br></pre></td></tr></table></figure>
<p>与<code>===</code>运算符的区别在于：</p>
<ul>
<li>如果<code>op1</code>和<code>op2</code>都是<code>NaN</code>，返回<code>true</code>。</li>
<li>如果<code>op1</code>和<code>op2</code>一个是<code>+0</code>，一个是<code>-0</code>，返回<code>false</code></li>
</ul>
<h3 id="严格不等"><a class="markdownIt-Anchor" href="#严格不等"></a> 严格不等(!==)</h3>
<p>严格不等运算符<code>op1 !== op2</code>返回<code>!(op1 === op2)</code>。<br />
和关系运算符不同，<code>NaN</code>不会做特别处理，任何一个操作数为<code>NaN</code>则为<code>true</code>。</p>
<h2 id="条件运算符"><a class="markdownIt-Anchor" href="#条件运算符"></a> 条件运算符</h2>
<p>条件运算符<code>condition ? trueResult : falseResult</code>，首先使用<code>ToBoolean</code>将<code>condition</code>转换为布尔值，若为<code>true</code>则返回<code>trueResult</code>，否则返回<code>falseResult</code></p>
<h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h2>
<p>赋值运算符<code>op1 = op2</code>返回<code>op2</code>。<br />
它的副作用是将<code>op2</code>的值赋给引用<code>op1</code>。<br />
当<code>op1</code>是对象字面值，或者数组字面值时，进行解构赋值。</p>
<p>组合赋值运算符<code>op1 @= op2</code>中的<code>@=</code>可以是以下的形式之一，它返回<code>op1 @ op2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x3D; &#x2F;&#x3D; %&#x3D; **&#x3D; +&#x3D; -&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</span><br></pre></td></tr></table></figure>
<p>它的副作用是将<code>op1 @ op2</code>的值赋给引用<code>op1</code>。<br />
因此<code>op1 += op2</code>等价于<code>op1 = op1 + op2</code></p>
<h3 id="解构赋值"><a class="markdownIt-Anchor" href="#解构赋值"></a> 解构赋值</h3>
<p>解构赋值是ES6提供的用于赋值的新语法。<br />
当赋值表达式的等号左侧是一个类似于对象字面值，或者类似于数组字面值的语法产生式时，触发解构赋值。根据它的形式，可以将其分成对象解构赋值，和数组解构赋值。</p>
<p>注意解构赋值是赋值运算符的一部分，因此它也返回等号右侧的值。</p>
<h4 id="对象解构赋值"><a class="markdownIt-Anchor" href="#对象解构赋值"></a> 对象解构赋值</h4>
<p>对象解构赋值可以取出对象中的多个属性值，赋给若干个引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为任何引用赋值</span></span><br><span class="line">&#123;&#125; = op2;</span><br><span class="line"><span class="comment">// 根据op2的一个属性，为一个引用赋值</span></span><br><span class="line">&#123; 属性赋值<span class="number">1</span> &#125; = op2;</span><br><span class="line"><span class="comment">// 将op2的多个属性分别赋给多个引用，最后的逗号是可选的</span></span><br><span class="line">&#123; 属性赋值<span class="number">1</span>, 属性赋值<span class="number">2</span>, &#125; = op2;</span><br><span class="line"><span class="comment">// 剩余属性赋值，忽略已经处理过的op2的属性</span></span><br><span class="line">&#123; 剩余属性赋值 &#125; = op2</span><br><span class="line">&#123; 属性赋值<span class="number">1</span>, 属性赋值<span class="number">2</span>, 剩余属性赋值 &#125; = op2</span><br></pre></td></tr></table></figure>
<p>等号右侧的<code>op2</code>会被调用<code>ToObject</code>抽象操作转换为一个对象。</p>
<p>属性赋值有三种形式：</p>
<ul>
<li>第一种：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标识符</span><br><span class="line">标识符 = 默认值</span><br></pre></td></tr></table></figure>
<p>这种形式会将对象<code>op2</code>中属性键为<code>标识符</code>的属性的值，赋给运行中的执行上下文（当前作用域）的词法环境中名称为<code>标识符</code>的变量。<br />
如果对象<code>op2</code>中属性键为<code>标识符</code>的属性不存在，或者属性存在但值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，会为该变量赋予<code>默认值</code>。如果没有<code>默认值</code>，则会为该变量赋予<code>undefined</code>。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; myAge &#125; = srcObj <span class="comment">// 即myAge = srcObj.myAge</span></span><br><span class="line">&#123; myAge = <span class="number">18</span> &#125; = srcObj</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:左值表达式</span><br><span class="line">属性名:左值表达式 = 默认值</span><br></pre></td></tr></table></figure>
<p>属性名在【数据属性-&gt;Object-&gt;创建对象】一节已经说过有四种形式，左值表达式的结果是一个引用，例如<code>o['name']</code>。<br />
这种形式会获取对象<code>op2</code>中属性键为<code>属性名</code>的属性的值，将该值赋给<code>左值表达式</code>。<br />
如果对象<code>op2</code>中属性键为<code>属性名</code>的属性不存在，或者属性存在但值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，会为<code>左值表达式</code>赋予<code>默认值</code>。如果没有<code>默认值</code>，则会为<code>左值表达式</code>赋予<code>undefined</code>。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">myAge</span>: newAge &#125; = srcObj; <span class="comment">// 即newAge = srcObj.myAge</span></span><br><span class="line">&#123; <span class="attr">myAge</span>: newAge = <span class="number">18</span> &#125; = srcObj;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:解构赋值</span><br><span class="line">属性名:解构赋值 = 默认值</span><br></pre></td></tr></table></figure>
<p>这种形式会获取对象<code>op2</code>中属性键为<code>属性名</code>的属性的值，将该值作为内层<code>解构赋值</code>的等号右侧的对象。<br />
如果对象<code>op2</code>中属性键为<code>属性名</code>的属性不存在，或者属性存在但值为<code>undefined</code>，那么在有<code>默认值</code>的情况下，将<code>默认值</code>作为内层<code>解构赋值</code>的等号右侧的对象。如果没有<code>默认值</code>，则抛出异常。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="number">2016</span>: &#123; <span class="attr">gdp</span>: GDP2016 &#125; &#125; = srcObj <span class="comment">// 即GDP2016 = srcObj[&#x27;2016&#x27;].gdp</span></span><br><span class="line">&#123; <span class="number">2016</span>: &#123; <span class="attr">gdp</span>: GDP2016 &#125; = &#123;<span class="attr">gdp</span>: <span class="literal">undefined</span>&#125; &#125; = srcObj</span><br></pre></td></tr></table></figure>
<p>剩余属性赋值只有一种形式，它只能出现在对象解构赋值的最右边，它的右边不允许再出现属性赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...左值表达式</span><br></pre></td></tr></table></figure>
<p>它会将<code>op2</code>中没有在之前的属性赋值中处理过的自有属性，拷贝到一个原型为<code>Object.prototype</code>的新对象里，然后将这个新对象赋给<code>左值表达式</code>。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="number">2016</span>: &#123; <span class="attr">gdp</span>: GDP2016 &#125;, ...exclude2016 &#125; = srcObj</span><br><span class="line"><span class="comment">// 即GDP2016 = srcObj[&#x27;2016&#x27;].gdp</span></span><br><span class="line"><span class="comment">// exclude2016 = &#123;2015: &#123;&#125;, 2017: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>由于解构赋值和对象字面值的语法类似，解构赋值经常被误认为是对象字面值语法，导致抛出SyntaxError异常，此时需要用括号将其作为一个整体表达式执行。<br />
示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line">&#123; <span class="attr">name</span>: obj[<span class="string">&#x27;oName&#x27;</span>], <span class="attr">age</span>:obj[<span class="string">&#x27;oAge&#x27;</span>] &#125; = person</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">(&#123; <span class="attr">name</span>: obj[<span class="string">&#x27;oName&#x27;</span>], <span class="attr">age</span>:obj[<span class="string">&#x27;oAge&#x27;</span>] &#125; = person)</span><br></pre></td></tr></table></figure>
<p>解构赋值的过程可能抛出异常，但此前已完成的赋值操作不会回滚，因此可能出现部分引用被正确赋值，部分引用没被正确赋值的情况。</p>
<h4 id="数组解构赋值"><a class="markdownIt-Anchor" href="#数组解构赋值"></a> 数组解构赋值</h4>
<p>数组解构赋值可以将可迭代对象（不仅仅是数组）的迭代值，按顺序赋给若干个引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为任何引用赋值，也不调用next()</span></span><br><span class="line">[] = iterable;</span><br><span class="line"><span class="comment">// 调用一次next()，用其结果为一个引用赋值</span></span><br><span class="line">[ 元素赋值<span class="number">1</span> ] = iterable;</span><br><span class="line"><span class="comment">// 调用两次next()，结果分别为两个引用赋值，最后的逗号是可选的</span></span><br><span class="line">[ 元素赋值<span class="number">1</span>, 元素赋值<span class="number">2</span>, ] = iterable;</span><br><span class="line"><span class="comment">// 留空的元素赋值，调用两次next()，第二次的结果为一个引用赋值</span></span><br><span class="line">[ , 元素赋值<span class="number">1</span>, ]</span><br><span class="line"><span class="comment">// 剩余元素赋值，接受剩余next()的结果</span></span><br><span class="line">[ 剩余元素赋值 ]</span><br><span class="line">[ 元素赋值<span class="number">1</span>, 剩余元素赋值]</span><br><span class="line">[ , , , 剩余元素赋值 ]</span><br></pre></td></tr></table></figure>
<p>元素赋值有以下几种形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">左值表达式</span><br><span class="line">左值表达式 = 默认值</span><br><span class="line">解构绑定</span><br><span class="line">解构绑定 = 默认值</span><br><span class="line">  <span class="comment">// 留空</span></span><br></pre></td></tr></table></figure>
<p>剩余元素赋值有两种形式，它只能出现在数组解构赋值的最右边，它的右边不允许再出现逗号或者元素赋值语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...左值表达式</span><br><span class="line">...解构赋值</span><br></pre></td></tr></table></figure>
<p>数组解构赋值执行以下过程：</p>
<ol>
<li>调用等号右侧对象的<code>Symbol.iterator</code>方法获取一个迭代器<code>iterator</code>。</li>
<li>对每个<code>元素赋值</code>表达式，调用一次<code>iterator.next()</code>方法：
<ol>
<li>如果迭代结果（<code>IteratorResult</code>对象）的<code>done</code>为<code>false</code>，且迭代值<code>value</code>不为<code>undefined</code>：
<ul>
<li>如果<code>元素赋值</code>是<code>左值表达式</code>，则将<code>value</code>赋给<code>左值表达式</code></li>
<li>如果<code>元素赋值</code>是<code>解构赋值</code>，则将<code>value</code>作为内层<code>解构赋值</code>的关联对象<code>op2</code>。</li>
</ul>
</li>
<li>否则：
<ol>
<li>如果<code>元素赋值</code>表达式有<code>默认值</code>：
<ul>
<li>如果<code>元素赋值</code>是<code>左值表达式</code>，则将<code>默认值</code>赋给<code>左值表达式</code></li>
<li>如果<code>元素赋值</code>是<code>解构赋值</code>，则将<code>默认值</code>作为内层<code>解构赋值</code>的关联对象<code>op2</code>。</li>
</ul>
</li>
<li>否则：
<ul>
<li>如果<code>元素赋值</code>是<code>左值表达式</code>，则将<code>undefined</code>赋给<code>左值表达式</code></li>
<li>如果<code>元素赋值</code>是<code>解构赋值</code>，则抛出异常</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>如果有<code>剩余元素赋值</code>表达式，则创建一个新数组，不断调用<code>iterator.next()</code>，将迭代值添加到这个新数组中，直到迭代结果的<code>done</code>为<code>true</code>。
<ul>
<li>最后将这个新数组，赋值给<code>左值表达式</code>。</li>
<li>如果<code>剩余元素赋值</code>是<code>...左值表达式</code>，则将新数组赋给<code>左值表达式</code></li>
<li>如果<code>剩余元素赋值</code>是<code>...解构赋值</code>，则将新数组作为内层<code>解构赋值</code>的关联对象</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ul>
<li><code>元素赋值</code>语句可能为空，即使逗号前留空也会调用<code>next()</code>，只是忽略迭代值，不对结果做赋值操作。因此，如果加上最后可选的逗号，那么每个逗号都会导致一次<code>next()</code>调用，其结果要么被忽略，要么被赋予逗号前的<code>元素赋值</code>语句的<code>左值表达式</code>或者用作内层<code>解构赋值</code>的关联对象。</li>
</ul>
<p>基于数组解构赋值语法可以方便的交换变量的值，等号右侧使用数组字面值创建了一个可迭代对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>
<h2 id="逗号运算符"><a class="markdownIt-Anchor" href="#逗号运算符"></a> 逗号运算符</h2>
<p>逗号运算符<code>op1 , op2</code>从左到右依次求值，返回<code>GetValue(op2)</code></p>
<h2 id="new运算符"><a class="markdownIt-Anchor" href="#new运算符"></a> new运算符</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> F(arg1, arg2);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">F, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = F.prototype;</span><br><span class="line">  <span class="keyword">if</span>(Type(proto) != <span class="string">&#x27;Object&#x27;</span>)</span><br><span class="line">    proto = <span class="built_in">Object</span>.prototype;</span><br><span class="line">  <span class="keyword">let</span> thisArgument = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">  <span class="keyword">let</span> result = F.call(thisArgument, ...args);</span><br><span class="line">  <span class="keyword">if</span>(Type(result) == <span class="string">&#x27;Object&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> thisArgument;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new运算符获取其后面的构造函数的<code>prototype</code>属性，以这个属性的值作为原型创建新对象，若这个值不是对象则采用默认原型<code>Object.prototype</code>。<br />
以创建出的新对象作为<code>this</code>值调用构造函数并传递参数，如果构造函数返回了一个对象，则直接返回该对象。如果没有返回对象，则返回之前创建的作为构造函数<code>this</code>值的对象。<br />
<code>new.target</code>操作符可以引用函数式环境记录的<code>[[NewTarget]]</code>对象，当使用<code>new</code>调用函数时，<code>new.target</code>返回的是构造函数对象。当不用<code>new</code>直接调用函数时，<code>new.target</code>为<code>undefined</code>。<br />
通过<code>new.target</code>进行判断，可以阻止函数被<code>new</code>或者阻止直接调用。</p>
<h2 id="可选链运算符"><a class="markdownIt-Anchor" href="#可选链运算符"></a> 可选链运算符</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">op?.(参数)</span><br><span class="line">op?.[表达式]</span><br><span class="line">op?.标识符名</span><br></pre></td></tr></table></figure>
<p>可选链运算符当<code>?.</code>左侧的<code>op</code>为<code>null</code>或<code>undefined</code>（包括属性不存在的情况，但不是属性引用的无法解析的引用会抛出异常）时，直接返回<code>undefined</code>。<br />
只有当<code>op</code>不是<code>null</code>也不是<code>undefined</code>时，才会执行函数调用、属性访问或标识符查找。<br />
等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(op === <span class="literal">null</span> || op === <span class="literal">undefined</span>) ? <span class="literal">undefined</span> : op(参数)</span><br><span class="line">(op === <span class="literal">null</span> || op === <span class="literal">undefined</span>) ? <span class="literal">undefined</span> : op[表达式]</span><br><span class="line">(op === <span class="literal">null</span> || op === <span class="literal">undefined</span>) ? <span class="literal">undefined</span> : op.标识符名</span><br></pre></td></tr></table></figure>
<p>注意：如果左操作数<code>op</code>是一个无法解析的引用，但不是一个属性引用，则会抛出异常。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> val = o?.a?.x;</span><br></pre></td></tr></table></figure>
<p>该运算符可以避免访问深层可能不存在的属性时进行额外的检查。</p>
<h1 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h1>
<p>ECMAScript 中的语句以分号结尾。末尾的分号可以省略，省略分号意味着由解析器确定语句在哪里结尾。</p>
<h2 id="空语句"><a class="markdownIt-Anchor" href="#空语句"></a> 空语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>
<p>空语句就是一个分号，它声明也不做，只起到占位符的作用。任何使用语句的地方都可以使用空语句。</p>
<h2 id="debugger语句"><a class="markdownIt-Anchor" href="#debugger语句"></a> debugger语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">debugger</span>;</span><br></pre></td></tr></table></figure>
<p>如果实现定义的调试工具是可用的，并且已经启用了，则会启动调试。<br />
否则<code>debugger;</code>就和空语句<code>;</code>效果一样，什么也不做。</p>
<h2 id="块语句"><a class="markdownIt-Anchor" href="#块语句"></a> 块语句</h2>
<p>多条语句可以合并成一个块语句。块语句由一个左花括号（<code>&#123;</code>）标识开始，一个右<br />
花括号（<code>&#125;</code>）标识结束。</p>
<p>块语句会创建新的<code>LexicalEnvironment</code>词法环境，退出代码块时会回到之前的<code>LexicalEnvironment</code>词法环境。<br />
块语句不会创建新的<code>VariableEnvironment</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">var</span> o = &#123; <span class="comment">// 闭包</span></span><br><span class="line">    <span class="function"><span class="title">getter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">setter</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">      i = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.getter()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h2>
<p>if语句有两种格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 表达式 ) 语句<span class="number">1</span> <span class="keyword">else</span> 语句<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> ( 表达式 ) 语句<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>若<code>ToBoolean(表达式)</code>为<code>true</code>，则执行<code>语句1</code>，否则执行<code>语句2</code></p>
<h2 id="do-while语句"><a class="markdownIt-Anchor" href="#do-while语句"></a> do-while语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> 语句 <span class="keyword">while</span> ( 表达式 ) ;</span><br></pre></td></tr></table></figure>
<ol>
<li>执行<code>语句</code></li>
<li>若<code>ToBoolean(表达式)</code>为<code>false</code>则结束。</li>
<li>回到第1步。</li>
</ol>
<h2 id="while语句"><a class="markdownIt-Anchor" href="#while语句"></a> while语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( 表达式 ) 语句</span><br></pre></td></tr></table></figure>
<ol>
<li>若<code>ToBoolean(表达式)</code>为<code>false</code>则结束。</li>
<li>执行<code>语句</code></li>
<li>回到第1步</li>
</ol>
<h2 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( 可选的初始化语句 ; 可选的条件表达式 ; 可选的完成表达式 ) 语句</span><br></pre></td></tr></table></figure>
<p><code>可选的初始化表达式语句</code>有以下几种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">表达式</span><br><span class="line"><span class="keyword">var</span> 标识符</span><br><span class="line"><span class="keyword">var</span> 标识符 = 初始化表达式</span><br><span class="line"><span class="keyword">var</span> 解构绑定 = 初始化表达式</span><br><span class="line"><span class="keyword">let</span> 标识符</span><br><span class="line"><span class="keyword">let</span> 标识符 = 初始化表达式</span><br><span class="line"><span class="keyword">let</span> 解构绑定 = 初始化表达式</span><br><span class="line"><span class="keyword">const</span> 标识符 = 初始化表达式</span><br><span class="line"><span class="keyword">const</span> 解构绑定 = 初始化表达式</span><br></pre></td></tr></table></figure>
<ol>
<li>执行<code>可选的初始化语句</code>（不存在则执行下一步）</li>
<li>若<code>可选的条件表达式</code>存在且<code>ToBoolean(可选的条件表达式)</code>为<code>false</code>则结束（也就是说如果不存在就会继续执行，可以理解为不存在等于<code>true</code>）</li>
<li>执行<code>语句</code></li>
<li>执行<code>可选的完成表达式</code>（不存在则执行下一步）</li>
<li>回到第2步</li>
</ol>
<h3 id="词法环境-2"><a class="markdownIt-Anchor" href="#词法环境-2"></a> 词法环境</h3>
<p><code>for</code>语句执行各个部分时，词法环境（作用域）的变化值得注意：<br />
如果<code>可选的初始化语句</code>是以下几种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表达式</span><br><span class="line"><span class="keyword">var</span> 标识符</span><br><span class="line"><span class="keyword">var</span> 标识符 = 初始化表达式</span><br><span class="line"><span class="keyword">var</span> 解构绑定 = 初始化表达式</span><br></pre></td></tr></table></figure>
<p>则<code>for</code>语句执行时的词法环境如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env(包围<span class="keyword">for</span>的词法环境)</span><br><span class="line">  执行[可选的初始化语句]</span><br><span class="line">  测试[可选的条件表达式]</span><br><span class="line">  执行[语句]</span><br><span class="line">  执行[可选的完成表达式]</span><br></pre></td></tr></table></figure>
<p>也就是说它没有创建新的词法环境，在它各个部分使用<code>var</code>声明的变量就跟在<code>for</code>语句外面声明变量一样。例如下列代码将输出5个<code>5</code>，因为每轮循环中创建的匿名函数中引用的<code>i</code>是同一个词法环境中的<code>i</code>，这个<code>i</code>也是在<code>for</code>语句中递增的那个<code>i</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>可选的初始化语句</code>是以下几种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 标识符 = 初始化表达式</span><br><span class="line"><span class="keyword">const</span> 解构绑定 = 初始化表达式</span><br></pre></td></tr></table></figure>
<p>则<code>for</code>语句执行时的词法环境如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env(包围<span class="keyword">for</span>的词法环境)</span><br><span class="line">  forEnv(执行<span class="keyword">for</span>时创建的LexicalEnvironment)</span><br><span class="line">    执行[可选的初始化语句]</span><br><span class="line">    测试[可选的条件表达式]</span><br><span class="line">    执行[语句]</span><br><span class="line">    执行[可选的完成表达式]</span><br></pre></td></tr></table></figure>
<p>此时<code>for</code>语句会创建一个名为<code>forEnv</code>的<code>LexicalEnvironment</code>词法环境，它的外部词法环境是包围<code>for</code>语句的词法环境，当执行完<code>for</code>语句后，运行中的执行上下文的<code>LexicalEnvironment</code>词法环境又会重新设置为<code>env</code>，这意味着当<code>for</code>语句执行完毕后，<code>初始化语句</code>中创建的<code>const</code>变量都不能访问了，除了这一点都十分类似之前的<code>var</code>声明。<br />
考虑另一个问题，如果我在<code>语句</code>部分不使用块语句，而用<code>const</code>声明一个变量，这个变量在<code>完成表达式</code>部分是可访问的吗？<br />
按照前文所述，它们的词法环境相同，理论上是可访问的。但实际上不行，因为<code>语句</code>里只能进行<code>var</code>声明，而<code>let</code>和<code>const</code>声明必须在块语句内，而块语句创建了新的<code>LexicalEnvironment</code>，所以你没法做到让它们的词法环境相同。如果哪天ECMAScript允许在<code>语句</code>里进行<code>const</code>声明，那你确实能使变量在<code>完成表达式</code>部分可访问。</p>
<p>如果<code>可选的初始化语句</code>是以下几种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 标识符</span><br><span class="line"><span class="keyword">let</span> 标识符 = 初始化表达式</span><br><span class="line"><span class="keyword">let</span> 解构绑定 = 初始化表达式</span><br></pre></td></tr></table></figure>
<p>则<code>for</code>语句执行时的词法环境如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">env(包围<span class="keyword">for</span>的词法环境)</span><br><span class="line">  forEnv(执行<span class="keyword">for</span>时创建的LexicalEnvironment)</span><br><span class="line">    执行[可选的初始化语句]</span><br><span class="line">  forBodyEnv1(第一轮循环创建的LexicalEnvironment)</span><br><span class="line">    测试[可选的条件表达式]</span><br><span class="line">    执行[语句]</span><br><span class="line">  forBodyEnv2(第二轮循环创建的LexicalEnvironment)</span><br><span class="line">    执行[可选的完成表达式]</span><br><span class="line">    测试[可选的条件表达式]</span><br><span class="line">    执行[语句]</span><br><span class="line">  forBodyEnv3(第三轮循环创建的LexicalEnvironment)</span><br><span class="line">    执行[可选的完成表达式]</span><br><span class="line">    测试[可选的条件表达式]</span><br><span class="line">    执行[语句]</span><br></pre></td></tr></table></figure>
<p>此时<code>for</code>语句会创建一个名为<code>forEnv</code>的<code>LexicalEnvironment</code>词法环境，它的外部词法环境是包围<code>for</code>语句的词法环境，当执行完<code>for</code>语句后，运行中的执行上下文的<code>LexicalEnvironment</code>词法环境又会重新设置为<code>env</code>，这意味着当<code>for</code>语句执行完毕后，<code>初始化语句</code>中创建的<code>let</code>变量都不能访问了。<br />
另外，每一轮循环之前都会创建名为<code>forBodyEnv</code>新的<code>LexicalEnvironment</code>词法环境，它的外部词法环境也是包围<code>for</code>语句的词法环境。新的<code>forBodyEnv</code>在创建时，会将之前的<code>LexicalEnvironment</code>中与<code>初始化语句</code>声明的变量同名的那些变量，在新的<code>forBodyEnv</code>中重新绑定一遍。<br />
例如下列代码将输出<code>b 0</code>,<code>a 1</code>,<code>b 1</code>, <code>a 2</code>, <code>b 2</code>, <code>a 3</code>，因为每轮循环中创建的匿名函数中引用的<code>i</code>是不同词法环境中的变量<code>i</code>，尽管它们的名称都是<code>i</code>，但它们不是同一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++, <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>,i)&#125;, <span class="number">2000</span>)) &#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, i);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>词法环境分析如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">env(包围<span class="keyword">for</span>的词法环境)</span><br><span class="line">  forEnv(执行<span class="keyword">for</span>时创建的LexicalEnvironment)</span><br><span class="line">    执行[<span class="keyword">let</span> i = <span class="number">0</span>;]</span><br><span class="line">  forBodyEnv1(<span class="keyword">let</span> i = <span class="number">0</span>)</span><br><span class="line">    测试[i &lt; <span class="number">3</span>]</span><br><span class="line">    执行[定义引用i的函数]输出b <span class="number">0</span></span><br><span class="line">  forBodyEnv2(<span class="keyword">let</span> i = <span class="number">0</span>)</span><br><span class="line">    执行[i++,此时i=<span class="number">1</span>,定义引用i的函数]输出a <span class="number">1</span></span><br><span class="line">    测试[i &lt; <span class="number">3</span>]</span><br><span class="line">    执行[定义引用i的函数]输出b <span class="number">1</span></span><br><span class="line">  forBodyEnv3(<span class="keyword">let</span> i = <span class="number">1</span>)</span><br><span class="line">    执行[i++,此时i=<span class="number">2</span>,定义引用i的函数]输出a <span class="number">2</span></span><br><span class="line">    测试[i &lt; <span class="number">3</span>]</span><br><span class="line">    执行[定义引用i的函数]输出b <span class="number">2</span></span><br><span class="line">  forBodyEnv3(<span class="keyword">let</span> i = <span class="number">2</span>)</span><br><span class="line">    执行[i++,此时i=<span class="number">3</span>,定义引用i的函数]输出a <span class="number">3</span></span><br><span class="line">    测试[i &lt; <span class="number">3</span>]</span><br><span class="line">    结束</span><br></pre></td></tr></table></figure>
<h2 id="for-in语句"><a class="markdownIt-Anchor" href="#for-in语句"></a> for-in语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( 左值语句 <span class="keyword">in</span> 表达式 ) 语句</span><br></pre></td></tr></table></figure>
<p><code>左值语句</code>有以下几种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">左值表达式</span><br><span class="line"><span class="keyword">var</span> 标识符</span><br><span class="line"><span class="keyword">var</span> 解构绑定</span><br><span class="line"><span class="keyword">let</span> 标识符</span><br><span class="line"><span class="keyword">let</span> 解构绑定</span><br><span class="line"><span class="keyword">const</span> 标识符</span><br><span class="line"><span class="keyword">const</span> 解构绑定</span><br></pre></td></tr></table></figure>
<ol>
<li>计算<code>表达式</code>，但<code>左值语句</code>的不同导致进行计算的作用域也不同：
<ul>
<li>如果是<code>let</code>或<code>const</code>声明，创建新的<code>LexicalEnvironment</code>词法环境<code>newEnv</code>，它的外部词法环境是包围<code>for-in</code>语句的词法环境<code>env</code>。在<code>newEnv</code>下计算<code>表达式</code>得到<code>exprValue</code>。将运行中的执行上下文的<code>LexicalEnvironment</code>切换回之前的词法环境<code>env</code>。</li>
<li>如果是<code>var</code>声明或<code>左值表达式</code>，计算<code>表达式</code>得到<code>exprValue</code>。</li>
</ul>
</li>
<li>如果<code>exprValue</code>为<code>null</code>或<code>undefined</code>，结束<code>for-in</code>语句。</li>
<li>调用<code>EnumerateObjectProperties(ToObject(exprValue))</code>得到迭代器<code>iterator</code>。</li>
<li>调用<code>iterator.next()</code>直到迭代结果对象的<code>done</code>为<code>true</code>：
<ol>
<li>如果<code>左值语句</code>是<code>let</code>或<code>const</code>声明，每次迭代创建新的<code>LexicalEnvironment</code>词法环境<code>iterationEnv</code>，它的外部词法环境是包围<code>for-in</code>语句的词法环境<code>env</code>。如果<code>左值语句</code>是<code>var</code>声明或<code>左值表达式</code>，忽略这一步。</li>
<li>用迭代值初始化<code>左值语句</code>中的声明语句，或者为<code>左值表达式</code>赋值。</li>
<li>执行<code>语句</code></li>
<li>如果<code>左值语句</code>是<code>let</code>或<code>const</code>声明，将运行中的执行上下文的<code>LexicalEnvironment</code>切换回之前的词法环境<code>env</code>。如果<code>左值语句</code>是<code>var</code>声明或<code>左值表达式</code>，忽略这一步。</li>
</ol>
</li>
</ol>
<p>由上述过程可见，<code>for-in</code>语句实际上就是特殊的<code>for-of</code>语句，基本上等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( 左值语句 <span class="keyword">of</span> EnumerateObjectProperties(ToObject(表达式) ) 语句</span><br></pre></td></tr></table></figure>
<p>因此理解<code>for-in</code>语句关键在于<code>EnumerateObjectProperties</code>函数的行为：</p>
<ul>
<li>调用<code>EnumerateObjectProperties</code>得到的迭代器，其迭代值是对象<code>obj</code>的可枚举属性的字符串属性键，包括自有属性和继承属性的属性键，迭代值不会重复。</li>
<li>具体而言，首先是<code>obj</code>的自有、可枚举属性的字符串属性键（先是按数字升序的整数索引，再是按创建顺序排列的其他字符串属性键），然后是<code>obj</code>的原型的自有、可枚举属性的字符串属性键（先是按数字升序的整数索引，再是按创建顺序排列的其他字符串属性键，以此类推。</li>
<li>如果原型链上的对象的可枚举属性的属性键，在之前已经被迭代器返回过，则不会再次返回。</li>
</ul>
<p>它的一种实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">EnumerateObjectProperties</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&quot;symbol&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">const</span> desc = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">    <span class="keyword">if</span> (desc) &#123;</span><br><span class="line">      visited.add(key);</span><br><span class="line">      <span class="keyword">if</span> (desc.enumerable) <span class="keyword">yield</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proto = <span class="built_in">Reflect</span>.getPrototypeOf(obj);</span><br><span class="line">  <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> protoKey <span class="keyword">of</span> EnumerateObjectProperties(proto)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited.has(protoKey)) <span class="keyword">yield</span> protoKey;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-of语句"><a class="markdownIt-Anchor" href="#for-of语句"></a> for-of语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( 左值语句 <span class="keyword">of</span> 可迭代对象表达式 ) 语句</span><br></pre></td></tr></table></figure>
<p><code>左值语句</code>有以下几种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">左值表达式</span><br><span class="line"><span class="keyword">var</span> 标识符</span><br><span class="line"><span class="keyword">var</span> 解构绑定</span><br><span class="line"><span class="keyword">let</span> 标识符</span><br><span class="line"><span class="keyword">let</span> 解构绑定</span><br><span class="line"><span class="keyword">const</span> 标识符</span><br><span class="line"><span class="keyword">const</span> 解构绑定</span><br></pre></td></tr></table></figure>
<ol>
<li>计算<code>可迭代对象表达式</code>，但<code>左值语句</code>的不同导致进行计算的作用域也不同：
<ul>
<li>如果是<code>let</code>或<code>const</code>声明，创建新的<code>LexicalEnvironment</code>词法环境<code>newEnv</code>，它的外部词法环境是包围<code>for-of</code>语句的词法环境<code>env</code>。在<code>newEnv</code>下计算<code>可迭代对象表达式</code>得到<code>exprValue</code>。将运行中的执行上下文的<code>LexicalEnvironment</code>切换回之前的词法环境<code>env</code>。</li>
<li>如果是<code>var</code>声明或<code>左值表达式</code>，计算<code>可迭代对象表达式</code>得到<code>exprValue</code>。</li>
</ul>
</li>
<li>如果<code>exprValue</code>为<code>null</code>或<code>undefined</code>，结束<code>for-of</code>语句。</li>
<li>调用<code>exprValue[Symbol.iterator]()</code>得到迭代器<code>iterator</code>。</li>
<li>调用<code>iterator.next()</code>直到迭代结果对象的<code>done</code>为<code>true</code>：
<ol>
<li>如果<code>左值语句</code>是<code>let</code>或<code>const</code>声明，每次迭代创建新的<code>LexicalEnvironment</code>词法环境<code>iterationEnv</code>，它的外部词法环境是包围<code>for-of</code>语句的词法环境<code>env</code>。如果<code>左值语句</code>是<code>var</code>声明或<code>左值表达式</code>，忽略这一步。</li>
<li>用迭代值初始化<code>左值语句</code>中的声明语句，或者为<code>左值表达式</code>赋值。</li>
<li>执行<code>语句</code></li>
<li>如果<code>左值语句</code>是<code>let</code>或<code>const</code>声明，将运行中的执行上下文的<code>LexicalEnvironment</code>切换回之前的词法环境<code>env</code>。如果<code>左值语句</code>是<code>var</code>声明或<code>左值表达式</code>，忽略这一步。</li>
</ol>
</li>
</ol>
<h2 id="with语句"><a class="markdownIt-Anchor" href="#with语句"></a> with语句</h2>
<p>注：严格模式不允许使用<code>with</code>语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ( 表达式 ) 语句</span><br></pre></td></tr></table></figure>
<ol>
<li>计算<code>ToObject(表达式)</code>得到<code>obj</code></li>
<li>创建新的<code>LexicalEnvironment</code>词法环境<code>newEnv</code>，它的外部词法环境是包围<code>with</code>语句的词法环境<code>env</code>。同时将词法环境<code>newEnv</code>的关联对象设为<code>obj</code>，这使得在<code>newEnv</code>没有找到的标识符，会在<code>obj</code>的属性中查找（可以进行<code>get</code>和<code>set</code>访问）。</li>
<li>执行<code>语句</code></li>
<li>将运行中的执行上下文的<code>LexicalEnvironment</code>词法环境恢复为<code>obj</code></li>
</ol>
<ul>
<li>在<code>语句</code>中通过<code>var</code>声明的变量、以及通过标识符访问的变量，如果和<code>obj</code>中的属性名相同，则操作的是同一个变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span> : <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="function"><span class="title">with</span>(<span class="params">o</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">  b += <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// o.a == 5 o.b == 12</span></span><br></pre></td></tr></table></figure>
<h2 id="switch语句"><a class="markdownIt-Anchor" href="#switch语句"></a> switch语句</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( 表达式<span class="number">0</span> ) &#123;</span><br><span class="line">  <span class="keyword">case</span> 表达式<span class="number">1</span> : 可选语句</span><br><span class="line">  <span class="keyword">case</span> 表达式<span class="number">2</span> : 可选语句</span><br><span class="line">  <span class="keyword">default</span> : 可选语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>case</code>子句可以有零个或任意个。<br />
<code>default</code>子句可以有0个或1个。</p>
<ol>
<li>计算<code>表达式0</code></li>
<li>创建新的<code>LexicalEnvironment</code>词法环境<code>blockEnv</code>，其外部词法环境引用为包围<code>switch</code>语句的<code>LexicalEnvironment</code>词法环境<code>env</code></li>
<li>从上到下依次执行所有<code>case</code>子句：
<ol>
<li>计算<code>表达式1</code></li>
<li>使用严格相等运算符比较<code>表达式0 === 表达式1</code></li>
<li>如果为<code>true</code>则执行这个<code>case</code>子句后面的<code>可选语句</code>。</li>
</ol>
</li>
<li>如果存在某个<code>case</code>子句使用严格相等运算符比较<code>表达式0 === 表达式1</code>的结果为<code>true</code>，则结束<code>switch</code>语句。如果不存在，则执行<code>default</code>子句，执行<code>default</code>的<code>可选语句</code>。</li>
</ol>
<p>在执行<code>可选语句</code>时，如果遇到了<code>break</code>，则结束<code>switch</code>语句，而不会继续执行下一个<code>case</code>或<code>default</code>子句。</p>
<p><code>switch</code>语句类似下列<code>if</code>语句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> ( 表达式<span class="number">0</span> === 表达式<span class="number">1</span> ) &#123;</span><br><span class="line">  found = <span class="literal">true</span>;</span><br><span class="line">  可选语句;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( 表达式<span class="number">0</span> === 表达式<span class="number">2</span> ) &#123;</span><br><span class="line">  found = <span class="literal">true</span>;</span><br><span class="line">  可选语句;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!found) &#123;</span><br><span class="line">  <span class="keyword">default</span>可选语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标签语句"><a class="markdownIt-Anchor" href="#标签语句"></a> 标签语句</h2>
<p>语句前面可以加标签，任何标识符都可以作为标签，标签仅用于 <code>break</code> 和 <code>continue</code> 语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标识符 : Statement</span><br><span class="line">标识符 : FunctionDeclaration</span><br></pre></td></tr></table></figure>
<h2 id="break和continue语句"><a class="markdownIt-Anchor" href="#break和continue语句"></a> break和continue语句</h2>
<p><code>break</code>和<code>continue</code>语句用于<code>do-while</code>、<code>while</code>、<code>for</code>、<code>for-in</code>、<code>for-of</code>等循环语句的<code>语句</code>部分。<br />
<code>break</code>语句还可以用于<code>switch</code>语句内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">break</span> 标签名 ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">continue</span> 标签名 ;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>break</code>语句：
<ul>
<li><code>break</code>语句可以结束循环语句，直接执行包围<code>break</code>的循环语句的后面的语句。</li>
<li><code>break</code>语句位于<code>switch</code>语句中的<code>case</code>或<code>default</code>子句内时，会结束<code>switch</code>语句，并执行<code>switch</code>语句后面的语句。</li>
<li>带标签的<code>break</code>语句可以结束标签所对应的循环语句（这个循环语句必须是包围<code>break</code>的循环语句），通常用于嵌套循环内直接退出外层循环。</li>
</ul>
</li>
<li><code>continue</code>语句：
<ul>
<li><code>continue</code>语句可以结束本轮循环中的<code>语句</code>部分，然后从本轮<code>语句</code>部分后面继续执行循环。</li>
<li>带标签的<code>continue</code>语句可以结束标签所对应循环中的<code>语句</code>部分，然后从后面继续执行循环。</li>
</ul>
</li>
</ul>
<h2 id="return语句"><a class="markdownIt-Anchor" href="#return语句"></a> return语句</h2>
<p><code>return</code>语句必须写在函数内部，用于使一个函数停止执行，并返回一个值给调用者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>; <span class="comment">// 等价于 return undefined;</span></span><br><span class="line"><span class="keyword">return</span> 表达式;</span><br></pre></td></tr></table></figure>
<h2 id="throw语句"><a class="markdownIt-Anchor" href="#throw语句"></a> throw语句</h2>
<p><code>throw</code>语句用于将<code>表达式</code>的计算结果作为异常抛出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 表达式;</span><br></pre></td></tr></table></figure>
<h2 id="try语句"><a class="markdownIt-Anchor" href="#try语句"></a> try语句</h2>
<p><code>try</code>语句一共有三种形式：<br />
第一种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// try-block</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(标识符或解构绑定) &#123;</span><br><span class="line"> <span class="comment">// catch-block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// try-block</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// finally-block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// try-block</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(标识符或解构绑定) &#123;</span><br><span class="line"> <span class="comment">// catch-block</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// finally-block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其含义是：</p>
<ol>
<li>执行<code>try-block</code>块</li>
<li>如果<code>try-block</code>块中抛出了异常，则用该异常对象初始化<code>catch</code>子句中的<code>标识符</code>或<code>解构绑定</code>（如果没有则不初始化），然后执行<code>catch-block</code>块。如果没有抛出异常则什么也不做。</li>
<li>执行<code>finally-block</code>块（不管上一步是否抛出了异常）</li>
</ol>
<p>注意：</p>
<ul>
<li><code>catch</code>子句也可以写成<code>catch &#123; &#125;</code>，即省略掉<code>(标识符或解构绑定)</code>，此时如果<code>try-block</code>块抛出了异常，那么异常对象会被忽略，然后执行<code>catch-block</code>块。</li>
<li>由于<code>try</code>语句中<code>try-block</code>、<code>catch-block</code>和<code>finally-block</code>都是块语句，它们都创建了新的<code>LexicalEnvironment</code>词法环境。因此<code>try-block</code>中通过<code>let</code>或<code>const</code>声明的变量，在<code>catch-block</code>或<code>finally-block</code>中是无法访问的。</li>
</ul>
<h1 id="异步编程"><a class="markdownIt-Anchor" href="#异步编程"></a> 异步编程</h1>
<p>JavaScript中有大量异步操作，它不是立刻执行的，而是将来某个时机或满足某个条件后才执行。异步的优点是不会阻塞线程，缺点是无法准确的预知异步操作会何时执行。<br />
异步操作在ECMAScript执行流程中表现为任务，当没有运行中的执行上下文，且执行上下文栈为空时，才会轮到任务代码执行。</p>
<h2 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h2>
<p>回调函数是作为参数传给另一个函数<code>F</code>，并在函数<code>F</code>内被调用，用来完成某些任务的函数。<br />
异步操作通常被封装为回调函数，传给用于安排异步任务的内置函数（如<code>setTimeout</code>），内置函数执行时将回调函数添加到任务队列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安排异步任务：300毫秒后执行callback</span></span><br><span class="line"><span class="built_in">setTimeout</span>(callback, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 安排异步任务：点击按钮后执行callback</span></span><br><span class="line">button.addEventListener(<span class="string">&quot;click&quot;</span>, callback)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，上述<code>setTimeout</code>或<code>addEventListener</code>函数的作用仅仅是安排异步任务，而不是执行回调函数中的代码，当<code>setTimeout</code>或<code>addEventListener</code>执行完毕时，回调函数被添加到任务队列中，但还没有开始执行。<br />
因此其自身的返回值，和回调函数的返回值完全无关。对函数进行try-catch也捕获不到回调函数抛出的异常。</p>
<h3 id="处理返回值和异常"><a class="markdownIt-Anchor" href="#处理返回值和异常"></a> 处理返回值和异常</h3>
<p>要想获得回调函数的返回值，或者处理回调函数中的错误，需要在回调函数代码内进行操作。例如在完成任务后，调用用于成功处理的函数，这个成功处理函数一般是由外部代码提供的，它接受成功时回调函数的返回值，然后对返回值进行相应处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      success(<span class="number">2</span> * value);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> successHandler = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> failureHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;failure: &quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>, successHandler, failureHandler);</span><br><span class="line">double(<span class="string">&#x27;b&#x27;</span>, successHandler, failureHandler);</span><br></pre></td></tr></table></figure>
<h3 id="串联执行回调函数"><a class="markdownIt-Anchor" href="#串联执行回调函数"></a> 串联执行回调函数</h3>
<p>如果回调函数需要串联执行，例如执行完任务1后执行任务2，则需要将回调函数嵌套很多层，难以维护。这种难以维护的嵌套回调常被人称为“回调地狱”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; ,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> Promise</h2>
<p>为了避免回调地狱，开发者创造了新的异步编程模式，即使用Promise。<br />
Promise对象是一个表示异步计算结果的占位符，详细内容见【Promise】一文。<br />
比起回调函数的嵌套，Promise使串联执行异步任务能够写为多个函数的连续调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;<span class="comment">/*异步任务1*/</span>&#125;)</span><br><span class="line">.then( <span class="function">(<span class="params">prevResult</span>)=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve ,reject</span>)=&gt;</span>&#123;<span class="comment">/*异步任务2*/</span>&#125;) )</span><br><span class="line">.then( <span class="function">(<span class="params">prevResult</span>)=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve ,reject</span>)=&gt;</span>&#123;<span class="comment">/*异步任务3*/</span>&#125;) )</span><br></pre></td></tr></table></figure>
<h2 id="async函数"><a class="markdownIt-Anchor" href="#async函数"></a> async函数</h2>
<p>在Promise的基础上，结合生成器函数暂停与恢复执行上下文的能力，有了新的异步编程模式：async函数（异步函数）<br />
这种模式最大的特点是能够将异步代码写成类似于同步代码的形式，其中<code>await</code>表达式会暂停执行函数，等待Promise所表示的异步计算完成后，才会继续执行函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;<span class="comment">/*异步任务1*/</span>&#125;);</span><br><span class="line">  <span class="comment">// 此时异步任务1已完成</span></span><br><span class="line">  result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;<span class="comment">/*异步任务2*/</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="执行保存在字符串中的代码"><a class="markdownIt-Anchor" href="#执行保存在字符串中的代码"></a> 执行保存在字符串中的代码</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(codeStr)</span><br></pre></td></tr></table></figure>
<p>将字符串<code>codeStr</code>作为JavaScript代码执行，代码会在调用<code>eval</code>函数的执行上下文中运行，返回代码的运行结果，如果<code>codeStr</code>不是字符串，则直接返回<code>codeStr</code>。<br />
<code>eval</code>在执行代码时会创建新的<code>LexicalEnvironment</code>词法环境，因此<code>codeStr</code>中的<code>let</code>、<code>const</code>或<code>class</code>声明都只能在<code>codeStr</code>中使用，执行完<code>eval</code>后就无法使用。而<code>var</code>声明的变量可以在外面使用。<br />
但当调用<code>eval</code>函数的执行上下文是严格模式，或<code>codeStr</code>中指定了严格模式，那么<code>eval</code>在执行代码时还会创建新的<code>VariableEnvironment</code>，此时<code>codeStr</code>中<code>var</code>声明的变量也只能在<code>codeStr</code>中使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;console.log(&quot;Hello&quot;)&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/JavaScript基础.html">https://rcocco.github.io/categories/计算机/编程语言/JavaScript语言/JavaScript基础.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E8%AF%AD%E8%A8%80/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"><i class="fa fa-chevron-left">  </i><span>常见问题</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript%E8%AF%AD%E8%A8%80/%E5%AD%97%E7%AC%A6%E4%B8%B2.html"><span>字符串</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>