<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="文档对象模型"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>文档对象模型 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E8%AE%BF%E9%97%AE%E7%BB%93%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text"> 搜索与访问结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%BB%93%E7%82%B9%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text"> 修改结点树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%93%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text"> 创建结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text"> 访问和修改属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E5%B1%80"><span class="toc-number">5.</span> <span class="toc-text"> 布局</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text"> 样式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">7.</span> <span class="toc-text"> 动画</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#htmlinputelement"><span class="toc-number">8.</span> <span class="toc-text"> HTMLInputElement</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">186</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">文档对象模型</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">文档对象模型</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Node接口是DOM API的抽象基类，实现该接口的常用类有<code>Document</code>、<code>Element</code>和<code>DocumentFragment</code>。另外，每种DOM结点也实现了该接口，例如<code>Attr</code>, <code>CharacterData</code> (<code>Text</code>, <code>Comment</code>, <code>CDATASection</code>), <code>ProcessingInstruction</code>, <code>DocumentType</code>, <code>Notation</code>, <code>Entity</code>, <code>EntityReference</code></p>
<span id="more"></span>
<p>每个元素（包括匿名文本和注释）都是对象，全局变量<code>document</code>的<code>documentElement</code>属性可以访问到根元素，<code>document.body</code>也可以访问到<code>body</code>元素。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性/方法</th>
<th style="text-align:left">元素结点</th>
<th style="text-align:left">文本结点</th>
<th style="text-align:left">注释结点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nodeName</td>
<td style="text-align:left">大写标签名</td>
<td style="text-align:left">#text</td>
<td style="text-align:left">（未知）</td>
</tr>
<tr>
<td style="text-align:left">nodeType</td>
<td style="text-align:left"><code>document.ELEMENT_NODE</code>(数字1)</td>
<td style="text-align:left"><code>document.TEXT_NODE</code>（数字3）</td>
<td style="text-align:left"><code>document.COMMENT_NODE</code>（数字8）</td>
</tr>
<tr>
<td style="text-align:left">nodeValue</td>
<td style="text-align:left">null</td>
<td style="text-align:left">文本结点的内容</td>
<td style="text-align:left">注释结点的内容</td>
</tr>
</tbody>
</table>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/NodeValue">https://developer.mozilla.org/en-US/docs/Web/API/Node/NodeValue</a></p>
<h1 id="搜索与访问结点"><a class="markdownIt-Anchor" href="#搜索与访问结点"></a> 搜索与访问结点</h1>
<p>具有ID属性的结点在全局对象<code>window</code>中有一个和ID名相同的属性指向该结点对象。</p>
<p>一个结点(Node)的拥有的部分属性如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">childNodes</td>
<td style="text-align:left">返回一个包括元素、文本、注释结点的类数组NodeList对象</td>
</tr>
<tr>
<td style="text-align:left">firstChild</td>
<td style="text-align:left">返回childNodes中的第一个子结点，若不存在返回null</td>
</tr>
<tr>
<td style="text-align:left">lastChild</td>
<td style="text-align:left">返回childNodes中的最后一个子结点，若不存在返回null</td>
</tr>
<tr>
<td style="text-align:left">nextSibling</td>
<td style="text-align:left">返回DOM树中后一个兄弟结点，若不存在返回null</td>
</tr>
<tr>
<td style="text-align:left">previousSibling</td>
<td style="text-align:left">返回DOM树中前一个兄弟结点，若不存在返回null</td>
</tr>
<tr>
<td style="text-align:left">parentNode</td>
<td style="text-align:left">返回该结点的父结点</td>
</tr>
<tr>
<td style="text-align:left">parentElement</td>
<td style="text-align:left">返回该结点的父元素结点，若没有父结点或不是元素返回null</td>
</tr>
<tr>
<td style="text-align:left">textContent</td>
<td style="text-align:left">获取或设置一个元素的文本内容（包括后代结点）</td>
</tr>
</tbody>
</table>
<p><code>ParentNode</code>接口（<code>Element</code>、<code>Document</code>、<code>DocumentFragment</code>实现了它）有以下方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">children</td>
<td style="text-align:left">只读。返回所有子结点中的Element组成的类数组HTMLCollection对象</td>
</tr>
<tr>
<td style="text-align:left">firstElementChild</td>
<td style="text-align:left">只读。返回第一个既是子结点又是Element的结点，若不存在返回null</td>
</tr>
<tr>
<td style="text-align:left">lastElementChild</td>
<td style="text-align:left">只读。返回最后一个既是子结点又是Element的结点，若不存在返回null</td>
</tr>
</tbody>
</table>
<p><code>NonDocumentTypeChildNode</code>接口（<code>Element</code>、<code>CharacterData</code>实现了它）有以下方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nextElementSibling</td>
<td style="text-align:left">返回DOM树中后一个兄弟元素结点，若不存在返回null</td>
</tr>
<tr>
<td style="text-align:left">previousElementSibling</td>
<td style="text-align:left">返回DOM树中前一个兄弟元素结点，若不存在返回null</td>
</tr>
</tbody>
</table>
<p>元素(Element)对象（例如HTMLElement和SVGElement）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">innerHTML</td>
<td style="text-align:left">获取或修改元素标签之间的HTML代码</td>
</tr>
<tr>
<td style="text-align:left">outerHTML</td>
<td style="text-align:left">获取或修改包括元素标签的HTML代码</td>
</tr>
<tr>
<td style="text-align:left">tagName</td>
<td style="text-align:left">只读。返回元素的标签名</td>
</tr>
<tr>
<td style="text-align:left">getElementsByTagName(name)</td>
<td style="text-align:left">返回标签名为name的后代元素组成的类数组HTMLCollection对象</td>
</tr>
<tr>
<td style="text-align:left">getElementsByClassName(names)</td>
<td style="text-align:left">返回类名包含names中所有类名的后代元素组成的类数组HTMLCollection对象</td>
</tr>
<tr>
<td style="text-align:left">querySelector(css_selector)</td>
<td style="text-align:left">返回选择器选中的第一个后代元素Node对象，不存在则返回null</td>
</tr>
<tr>
<td style="text-align:left">querySelectorAll(css_selector)</td>
<td style="text-align:left">返回选择器选中的所有后代元素组成的静态NodeList</td>
</tr>
<tr>
<td style="text-align:left">matches(selectorString)</td>
<td style="text-align:left">返回布尔值。表示元素是否与给定的CSS选择器相匹配。</td>
</tr>
</tbody>
</table>
<p>HTML元素(HTMLElement)对象</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">innerText</td>
<td style="text-align:left">获取或设置节点及其后代的&quot;已渲染&quot;(受CSS影响，如压缩空白符等)文本内容</td>
</tr>
<tr>
<td style="text-align:left">outerText</td>
<td style="text-align:left">获取时和innerText相同，设置时会将标签也作为被删除文本的一部分。</td>
</tr>
</tbody>
</table>
<p><code>document</code>对象有一个<code>getElementById</code>方法，接受一个ID参数，返回具有该id的结点。</p>
<p>注意，通常NodeList和HTMLCollection对象是动态变化的（特别说明的除外），当文档被修改了之后，它的内容也会自动变化，因此在遍历时如果要改变结点需要特别注意（例如4个元素，删除第一个，剩下三个元素的索引会变成0、1、2而不是原来的1、2、3，因此可以考虑倒序遍历）<br />
上述方法返回的列表是动态变化的，如果在遍历时要进行修改，需要反向遍历。否则在移除列表第一个元素后，列表会丢失第一个元素。要获得稳定不变的结点集合，可以使用数组的<code>slice</code>方法将其转换成实际的数组，如<code>Array.prototype.slice.call(arrayish, 0)</code><br />
<code>Array.from(arrayish)</code><br />
<code>Array.apply(null, arrayish)</code></p>
<p><code>document</code>对象和元素结点定义了<code>querySelector</code>和<code>querySelectorAll</code>方法，该方法接受一个字符串，用于书写选择器，前者返回一个匹配的元素结点（不存在时返回null)，后者返回所有匹配的元素结点的数组。</p>
<h1 id="修改结点树"><a class="markdownIt-Anchor" href="#修改结点树"></a> 修改结点树</h1>
<p>一个结点(Node)的拥有的部分方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">appendChild(childNode)</td>
<td style="text-align:left">将参数结点添加到子结点的末尾，若参数结点已在DOM树上，则会被从目前位置移除然后添加到当前结点上。</td>
</tr>
<tr>
<td style="text-align:left">removeChild(childNode)</td>
<td style="text-align:left">删除当前结点的子结点中和参数结点完全相同的那个，如果参数结点不是子结点则会抛出异常。返回被删除的结点，即childNode。</td>
</tr>
<tr>
<td style="text-align:left">insertBefore(insertNode, childNode = null)</td>
<td style="text-align:left">将第一个参数结点插入到第二个参数结点前面，若为null则将其插入子结点的末尾</td>
</tr>
<tr>
<td style="text-align:left">replaceChild(newChild, oldChild)</td>
<td style="text-align:left">将一个子结点替换为另一个结点，第一个参数是新结点，第二个参数是等待替换的子结点。返回被替换掉的结点，即oldChild。</td>
</tr>
<tr>
<td style="text-align:left">cloneNode(deep = false)</td>
<td style="text-align:left">返回一个结点的副本，若deep为true则它的后代包括文本结点也会复制，若为false则只复制自身不包括任何子结点</td>
</tr>
<tr>
<td style="text-align:left">normalize()</td>
<td style="text-align:left">将该结点及其子树规范化，使得没有空的，也没有相邻的文本结点（合并了）</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = root.childNodes.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root.childNodes[i].nodeType == <span class="built_in">document</span>.TEXT_NODE) &#123;</span><br><span class="line">      <span class="keyword">if</span>(root.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        root.parentNode.removeChild(root);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        root</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加或插入结点的方法有副作用，由于一个结点只能存在于文档树中的一个位置，如果元素已经在文档中，则会被从当前位置移除。</p>
<p><code>ParentNode</code>接口（<code>Element</code>、<code>Document</code>、<code>DocumentFragment</code>实现了它）有以下方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">append(…nodesOrDOMStrings)</td>
<td style="text-align:left">接受结点或字符串，将若干个结点和由字符串自动生成的文本节点添加到当前结点的子结点的最后</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneNode</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.nodeType == <span class="built_in">document</span>.TEXT_NODE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(node.nodeValue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.nodeType == <span class="built_in">document</span>.ELEMENT_NODE) &#123;</span><br><span class="line">        <span class="keyword">var</span> copy = <span class="built_in">document</span>.createElement(node.tagName)</span><br><span class="line">        <span class="keyword">var</span> attrNames = node.getAttributeNames()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> attrName <span class="keyword">of</span> attrNames) &#123;</span><br><span class="line">            <span class="keyword">var</span> attrVal = node.getAttribute(attrName)</span><br><span class="line">            copy.setAttribute(attrName, attrVal)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> child <span class="keyword">of</span> node.childNodes) &#123;</span><br><span class="line">            copy.appendChild(cloneNode(child))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建结点"><a class="markdownIt-Anchor" href="#创建结点"></a> 创建结点</h1>
<p><code>Document</code>对象有以下方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">createElement(tagName)</td>
<td style="text-align:left">返回一个新创建的特定标签的Element对象</td>
</tr>
<tr>
<td style="text-align:left">createTextNode(text)</td>
<td style="text-align:left">返回一个新创建的具有text内容的文本结点</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elt</span>(<span class="params">tagName, attrs, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">document</span>.createElement(tagName);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> attr <span class="keyword">of</span> attrs) &#123;</span><br><span class="line">    node.setAttribute(attr, attrs[attr]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">    node.append(child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="访问和修改属性"><a class="markdownIt-Anchor" href="#访问和修改属性"></a> 访问和修改属性</h1>
<p>某些元素结点的常用属性可以直接通过属性名访问，例如<code>src</code>或<code>href</code>。<br />
有一个常用属性<code>class</code>由于与JS保留字冲突（曾经）无法用属性名访问（ES5及之后可以），而改成了<code>className</code>。<br />
对于label标签有for属性，它需要用htmlFor<br />
更多的属性无法采用这种方式访问。<br />
更一般的，元素（<code>Element</code>）对象可以采用以下方法访问和修改属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getAttributeNames()</td>
<td style="text-align:left">返回属性名字符串组成的数组(Array)</td>
</tr>
<tr>
<td style="text-align:left">getAttribute(attributeName)</td>
<td style="text-align:left">返回属性attributeName的属性值，不存在返回null(旧的实现返回空串)</td>
</tr>
<tr>
<td style="text-align:left">setAttribute(name, value)</td>
<td style="text-align:left">将属性name的值设为value，其中name会自动转为小写，非字符串的value会自动转为字符串</td>
</tr>
<tr>
<td style="text-align:left">className</td>
<td style="text-align:left">获取或修改class属性的值</td>
</tr>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">获取或修改id属性的值</td>
</tr>
<tr>
<td style="text-align:left">classList</td>
<td style="text-align:left">只读。返回类名组成的类数组DOMTokenList对象</td>
</tr>
</tbody>
</table>
<p>node.getAttribute(‘src’)和node.src的区别在于，前者会给出源代码中书写的属性值，而后者会给出目前实际的计算值。类似的，对于value属性，前者读出的是源代码中所写的初始值，而后者读出的是实时计算值。然而某些属性例如<code>node.src</code>的修改会在HTML代码中进行修改，使得getAttribute的值也会读到新值。</p>
<p><code>HTMLOrForeignElement</code>接口有一个<code>dataset</code>属性，它将所有<code>data-*</code>的属性和对应的值组成了一个DOMStringMap，HTML代码中的破折号形式会被转为js中的驼峰命名，反过来也一样，例如<code>data-sku-id</code>在js中为<code>dataset.skuId</code>，反过来<code>dataset.userName</code>被转为<code>data-user-name</code></p>
<p><code>DOMTokenList</code>有一个<code>toggle(token)</code>方法，当列表中存在参数的token时删除它并返回false，当列表中不存在参数的token时添加它并返回true。</p>
<h1 id="布局"><a class="markdownIt-Anchor" href="#布局"></a> 布局</h1>
<p><code>HTMLElement</code>接口有以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">offsetWidth</td>
<td style="text-align:left">只读。返回border box四舍五入后的整数宽度像素。若<code>display:none</code>则返回0。</td>
</tr>
<tr>
<td style="text-align:left">offsetHeight</td>
<td style="text-align:left">只读。返回border box四舍五入后的整数高度像素。若<code>display:none</code>则返回0。</td>
</tr>
</tbody>
</table>
<p><code>Element</code>接口有以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">clientWidth</td>
<td style="text-align:left">只读。返回padding box(不包括滚动条)四舍五入后的整数宽度像素。若是行内元素则为0。</td>
</tr>
<tr>
<td style="text-align:left">clientHeight</td>
<td style="text-align:left">只读。返回padding box(不包括滚动条)四舍五入后的整数高度像素。若是行内元素则为0。</td>
</tr>
<tr>
<td style="text-align:left">scrollWidth</td>
<td style="text-align:left">只读。返回使得元素不会显示滚动条的最小宽度。</td>
</tr>
<tr>
<td style="text-align:left">scrollHeight</td>
<td style="text-align:left">只读。返回使得元素不会显示滚动条的最小高度。</td>
</tr>
<tr>
<td style="text-align:left">getBoundingClientRect()</td>
<td style="text-align:left">返回一个DOMRect对象，它包含border box距离视口左上角的位置四属性<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>，以及border box的小数宽高像素<code>width</code>和<code>height</code></td>
</tr>
</tbody>
</table>
<p><code>Window</code>接口有以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">pageXOffset</td>
<td style="text-align:left">只读。返回文档从原点开始的水平滚动小数像素数。正值表示视口向右滚动。</td>
</tr>
<tr>
<td style="text-align:left">pageYOffset</td>
<td style="text-align:left">只读。返回文档从原点开始的垂直滚动小数像素数。正值表示视口向下滚动。</td>
</tr>
<tr>
<td style="text-align:left">innerWidth</td>
<td style="text-align:left">只读。返回视口宽度（包括垂直滚动条）</td>
</tr>
<tr>
<td style="text-align:left">innerHeight</td>
<td style="text-align:left">只读。返回视口高度（包括水平滚动条）</td>
</tr>
<tr>
<td style="text-align:left">scroll(x,y)/scrollTo(options)</td>
<td style="text-align:left">将视口左上角与由x和y或options对象指定的绝对位置(像素)对齐，<code>options=&#123;top: y, left: x, behavior: 'smooth'&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">scrollBy(x,y or options)</td>
<td style="text-align:left">在当前视口的基础上滚动x和y或options对象指定的像素数</td>
</tr>
</tbody>
</table>
<p>注：当滚动到最下面时，此时<code>document.body.scrollHeight == window.pageYOffset + window.innerHeight</code>，因为<code>pageYOffset</code>是滚动的距离，最后一屏是没有滚动的，因此刚好少一个视口高度。</p>
<h1 id="样式"><a class="markdownIt-Anchor" href="#样式"></a> 样式</h1>
<p>元素结点的<code>style</code>属性是一个对象，该对象存储了元素的所有行内样式。<br />
可以用两种方法访问和修改样式：</p>
<ul>
<li><code>elem.style.fontSize = &quot;20px&quot;</code></li>
<li><code>elem.style[&quot;font-size&quot;] = &quot;20px&quot;</code></li>
</ul>
<p>由于减号<code>-</code>不是有效的IdentifierName的组成部分，因此DOM对其重新命名，将每个减号<code>-</code>后面的第一个字母大写，然后去掉减号。<br />
或者使用字符串来访问属性，字符串可以既可以使用CSS属性名，也可以使用DOM重新命名后的名字。<br />
属性值是一个<code>DOMString</code>字符串。</p>
<p>要获取元素样式的计算值，可以通过<code>window.getComputedStyle(element [, pseudoElt]);</code></p>
<h1 id="动画"><a class="markdownIt-Anchor" href="#动画"></a> 动画</h1>
<p>注意：推荐使用CSS动画，CSS动画会单独开一个线程，不会阻塞其他任务。而JS脚本，同一时间只能运行一个。</p>
<p>当在一个函数中修改元素样式来实现动画效果后，还需要在函数末尾调用<code>window.requestAnimationFrame(callback);</code>方法来通知浏览器在下一次重绘之前调用你的动画函数。如果不使用该函数，在执行JS过程中不会刷新页面来重绘内容。<br />
<code>callback</code>接受一个时间参数，表示从time origin（如页面加载的时刻）到开始执行回调函数所经过的毫秒数。这个时间用来控制动画的进度，如果不采用时间来控制动画，默认情况最小化浏览器后动画是不会继续执行的，但用户可能会期望后台也在执行，我们并不需要真的在后台执行，而只需要根据时间使其处于应该在的位置。<br />
在动画函数外部也需要调用<code>window.requestAnimationFrame(callback)</code>来开始。<br />
和定时器一样，requestAnimationFrame也返回一个整数标识符，使用<code>cancelAnimationFrame</code>可以取消它。</p>
<p>另一种方法是使用定时器setTimeout。实际上<code>requestAnimationFrame(callback)</code>类似<code>setTimeout(16, callback)</code>，16是每秒60帧计算出来的（1000/60）。区别在于它会把每一帧的所有DOM操作集中起来，并且绘制的间隔取决于刷新频率。同时，在隐藏和不可见的元素中，这个函数不会进行绘制，在最小化浏览器的过程中也不会绘制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="built_in">document</span>.querySelector(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> angle = <span class="number">0</span>, lastTime = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lastTime != <span class="literal">null</span>)</span><br><span class="line">    angle += (time - lastTime) * <span class="number">0.001</span>;</span><br><span class="line">  lastTime = time;</span><br><span class="line">  cat.style.top = (<span class="built_in">Math</span>.sin(angle) * <span class="number">20</span>) + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  cat.style.left = (<span class="built_in">Math</span>.cos(angle) * <span class="number">200</span>) + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animate);</span><br></pre></td></tr></table></figure>
<p>当cat是相对定位时，以左上角为原点建立坐标系，向右为正x轴，向下为正y轴（它的图形是一般坐标轴中的图形沿x轴翻转得到的）。<br />
top即是纵坐标y，left即是横坐标x（实际上是元素左上角的坐标），动画的轨迹实际上是向量值函数<code>r(t)=(x(t),y(t))</code><br />
上面的<code>x(t)=sin(t)*20</code>，<code>y(t)=cos(t)*20</code></p>
<p>设太阳的中心坐标是(a,b)，注意<code>top</code>、<code>left</code>只是左上角的坐标。<br />
地球的运动轨迹是<code>(x-a)^2+(y-b)^2=r^2</code>，令<code>(sint)^2+(cost)^2=1</code>公式可分解为<code>x=rcost+a</code>、<code>y=rsint+b</code>，于是得到地球的中心坐标，我们需要求得地球元素左上角坐标，还需要减去高度的一半和宽度的一半。<br />
月球的轨迹也是圆，圆心是地球的坐标，设地球坐标为<code>(ex, ey)</code>，则<br />
<code>(x-ex)^2+(y-ey)^2=R^2</code>分解为<code>x=Rcosθ+ex</code>、<code>y=Rsinθ+ey</code>，于是得到月球的中心坐标。由于地球365.24219天公转一周，而月球27.32天公转一周，因此月球公转的速度是地球的<code>365.24219/27.32=13.37</code>倍</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sun</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.earth</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.moon</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// t是一个时间参数，对于圆，它每6.28单位转一圈</span></span><br><span class="line"><span class="keyword">let</span> lastTime = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> sun = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div.sun&#x27;</span>);;</span><br><span class="line"><span class="keyword">let</span> earth = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div.earth&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> moon = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div.moon&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">earthMove</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// time是从当前到页面加载时刻所经过的毫秒数，除以1000是秒</span></span><br><span class="line">  <span class="keyword">if</span>(lastTime != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 为什么不直接用time作为时间参数？</span></span><br><span class="line">    <span class="comment">// 因为动画开始的瞬间未必是当前页面加载的瞬间，两者基准点不一样</span></span><br><span class="line">    <span class="comment">// 为什么不在函数开始时记录一下动画开始时刻？</span></span><br><span class="line">    <span class="comment">// 然后每次t=time-startTime?</span></span><br><span class="line">    <span class="comment">// 应该是可以的</span></span><br><span class="line">    <span class="comment">// t = lastT + time - lastTime;</span></span><br><span class="line">    <span class="comment">// t = time - (lastTime - lastT)</span></span><br><span class="line">    t += (time-lastTime) * <span class="number">0.001</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lastTime = time;</span><br><span class="line">  <span class="keyword">let</span> earthCX = <span class="number">100</span>*<span class="built_in">Math</span>.cos(t)+<span class="number">175</span>;</span><br><span class="line">  <span class="keyword">let</span> earthCY = <span class="number">100</span>*<span class="built_in">Math</span>.sin(t)+<span class="number">175</span>;</span><br><span class="line">  earth.style.top = earthCY - <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  earth.style.left = earthCX - <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> moonCX = <span class="number">20</span>*<span class="built_in">Math</span>.cos(<span class="number">13.37</span>*t) + earthCX;</span><br><span class="line">  <span class="keyword">let</span> moonCY = <span class="number">20</span>*<span class="built_in">Math</span>.sin(<span class="number">13.37</span>*t) + earthCY;</span><br><span class="line">  moon.style.top = moonCY - <span class="number">5</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  moon.style.left = moonCX - <span class="number">5</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  requestAnimationFrame(earthMove);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(earthMove);</span><br></pre></td></tr></table></figure>
<h1 id="htmlinputelement"><a class="markdownIt-Anchor" href="#htmlinputelement"></a> HTMLInputElement</h1>
<p><code>selectionStart</code>：所选文本的起始索引</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/前端/文档对象模型/文档对象模型.html">https://rcocco.github.io/categories/计算机/前端/文档对象模型/文档对象模型.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/CSS%E6%A0%B7%E5%BC%8F%E8%AF%AD%E8%A8%80/sass.html"><i class="fa fa-chevron-left">  </i><span>sass</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DOM%E6%A6%82%E8%BF%B0.html"><span>DOM概述</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>