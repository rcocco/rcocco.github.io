<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="2 事件"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>2 事件 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text"> 2 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-dom%E4%BA%8B%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text"> 2.1 DOM事件介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-event-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text"> 2.2 Event 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-window%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%81%97%E7%95%99%E6%89%A9%E5%B1%95"><span class="toc-number">1.3.</span> <span class="toc-text"> 2.3 Window接口的遗留扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-customevent%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text"> 2.4 CustomEvent接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-eventtarget%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.</span> <span class="toc-text"> 2.7 EventTarget接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E8%A7%82%E5%AF%9F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text"> 2.8 观察事件监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#211-%E8%A1%8C%E5%8A%A8vs%E5%8F%91%E7%94%9F"><span class="toc-number">1.7.</span> <span class="toc-text"> 2.11 行动vs发生</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">203</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">2 事件</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/DOM/">DOM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/DOM/DOM%E6%A0%87%E5%87%86/">DOM标准</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="2-事件"><a class="markdownIt-Anchor" href="#2-事件"></a> 2 事件</h1>
<h2 id="21-dom事件介绍"><a class="markdownIt-Anchor" href="#21-dom事件介绍"></a> 2.1 DOM事件介绍</h2>
<p>在整个web平台中，事件被派发(发送)到对象来表示某个事情的发生，如网络活动或用户交互。这些对象实现了<code>EventTarget</code>接口，因此可以通过调用<code>addEventListener()</code>添加事件监听器来观察事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.addEventListener(<span class="string">&quot;load&quot;</span>, imgFetched)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgFetched</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// great success</span></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件监听器可以通过调用<code>removeEventListener()</code>方法并传递相同的参数来删除。</p>
<p>另外，事件监听器可以通过传递<code>AbortSignal</code>到<code>addEventListener()</code>并在拥有该信号的控制器上调用<code>abort()</code>来删除。</p>
<p>事件也是对象，并且实现了<code>Event</code>接口（或一个派生接口）。在上面的例子中，<code>ev</code>是事件。<code>ev</code>被作为参数传递给事件监听器的回调（通常是一个JavaScript函数，如上所示）。事件监听器键入事件的<code>type</code>属性值（上例中的 <code>&quot;load&quot;</code>）。事件的<code>target</code>属性值返回事件被派发到的对象（上面的<code>obj</code>）。</p>
<p>尽管事件通常由用户代理派发，作为用户交互或完成某些任务的结果，但应用程序可以通过使用通常被称为合成事件的方式来自行派发事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add an appropriate event listener</span></span><br><span class="line">obj.addEventListener(<span class="string">&quot;cat&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; process(e.detail) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// create and dispatch the event</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&quot;cat&quot;</span>, &#123;<span class="string">&quot;detail&quot;</span>:&#123;<span class="string">&quot;hazcheeseburger&quot;</span>:<span class="literal">true</span>&#125;&#125;)</span><br><span class="line">obj.dispatchEvent(event)</span><br></pre></td></tr></table></figure>
<p>除了信号，事件有时也被用来让应用程序控制一个操作的下一步发生什么。例如，作为表单提交的一部分，一个<code>type</code>属性值为 <code>&quot;submit&quot;</code>的事件被派发。如果这个事件的<code>preventDefault()</code>方法被调用，表单提交将被终止。希望通过应用程序派发的事件（合成事件）利用这一功能的应用程序可以利用<code>dispatchEvent()</code>方法的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.dispatchEvent(event)) &#123;</span><br><span class="line">  <span class="comment">// event was not canceled, time for some magic</span></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个事件被派发到一个参与了树的对象（例如，一个元素）时，它也可以到达该对象的祖先上的事件监听器。实际上，首先会按照树顺序，调用该对象的所有包含祖先的捕获(captrue)为<code>true</code>的事件监听器。然后，如果事件的<code>bubbles</code>为<code>true</code>，则会按照逆序树顺序，调用该对象的所有包含祖先的捕获为<code>false</code>的事件监听器。</p>
<p>让我们来看看事件在树中如何工作的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;Boring example&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;p&gt;Hello &lt;span id=x&gt;world&lt;<span class="regexp">/span&gt;!&lt;/</span>p&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     debug(e.target, e.currentTarget, e.eventPhase)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">document</span>.addEventListener(<span class="string">&quot;hey&quot;</span>, test, &#123;<span class="attr">capture</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">   <span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;hey&quot;</span>, test)</span><br><span class="line">   <span class="keyword">var</span> ev = <span class="keyword">new</span> Event(<span class="string">&quot;hey&quot;</span>, &#123;<span class="attr">bubbles</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&quot;x&quot;</span>).dispatchEvent(ev)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>debug</code>函数将被调用两次。每一次时事件的<code>target</code>特性值都是span元素。第一次<code>currentTarget</code>特性的值是文档，第二次是body元素。 <code>eventPhase</code>特性的值从<code>CAPTURING_PHASE</code>切换到<code>BUBBLING_PHASE</code>。如果为span元素注册了一个事件监听器，<code>eventPhase</code>属性的值将是<code>AT_TARGET</code>。</p>
<h2 id="22-event-接口"><a class="markdownIt-Anchor" href="#22-event-接口"></a> 2.2 Event 接口</h2>
<p>Event构造器在主线程(window)、Worker、AudioWorklet中可用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[Exposed&#x3D;(Window,Worker,AudioWorklet)]</span><br><span class="line">interface Event &#123;</span><br><span class="line">  constructor(DOMString type, optional EventInit eventInitDict &#x3D; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  readonly attribute DOMString type;</span><br><span class="line">  readonly attribute EventTarget? target;</span><br><span class="line">  readonly attribute EventTarget? srcElement; &#x2F;&#x2F; legacy</span><br><span class="line">  readonly attribute EventTarget? currentTarget;</span><br><span class="line">  sequence&lt;EventTarget&gt; composedPath();</span><br><span class="line"></span><br><span class="line">  const unsigned short NONE &#x3D; 0;</span><br><span class="line">  const unsigned short CAPTURING_PHASE &#x3D; 1;</span><br><span class="line">  const unsigned short AT_TARGET &#x3D; 2;</span><br><span class="line">  const unsigned short BUBBLING_PHASE &#x3D; 3;</span><br><span class="line">  readonly attribute unsigned short eventPhase;</span><br><span class="line"></span><br><span class="line">  undefined stopPropagation();</span><br><span class="line">           attribute boolean cancelBubble; &#x2F;&#x2F; legacy alias of .stopPropagation()</span><br><span class="line">  undefined stopImmediatePropagation();</span><br><span class="line"></span><br><span class="line">  readonly attribute boolean bubbles;</span><br><span class="line">  readonly attribute boolean cancelable;</span><br><span class="line">           attribute boolean returnValue;  &#x2F;&#x2F; legacy</span><br><span class="line">  undefined preventDefault();</span><br><span class="line">  readonly attribute boolean defaultPrevented;</span><br><span class="line">  readonly attribute boolean composed;</span><br><span class="line"></span><br><span class="line">  [LegacyUnforgeable] readonly attribute boolean isTrusted;</span><br><span class="line">  readonly attribute DOMHighResTimeStamp timeStamp;</span><br><span class="line"></span><br><span class="line">  undefined initEvent(DOMString type, optional boolean bubbles &#x3D; false, optional boolean cancelable &#x3D; false); &#x2F;&#x2F; legacy</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dictionary EventInit &#123;</span><br><span class="line">  boolean bubbles &#x3D; false;</span><br><span class="line">  boolean cancelable &#x3D; false;</span><br><span class="line">  boolean composed &#x3D; false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个<code>Event</code>对象简称为事件(event)。它允许发出信号，表明某些事情已经发生，例如，一个图像已经完成下载。</p>
<p>潜在的事件目标(potential event target)是<code>null</code>或者一个<code>EventTarget</code>对象。</p>
<p>一个事件有一个关联的<code>target</code>(潜在的事件目标)，除非另有说明，否则它是<code>null</code>。</p>
<p>一个事件有一个关联的<code>relatedTarget</code>(潜在的事件目标)，除非另有说明，否则它是<code>null</code>。</p>
<p>注意：其他规范使用<code>relatedTarget</code>来定义<code>realtedTarget</code>特性。[UIEVENTS]</p>
<p>一个事件有一个关联的<code>touch target list</code>(零个或多个潜在的事件目标组成的列表)，除非另有说明，否则它是空列表。</p>
<p><code>touch target list</code>是专门用于定义<code>TouchEvent</code>接口和相关接口的。[TOUCH-EVENTS]</p>
<p>一个事件有一个关联的<code>path</code>。<code>path</code>是一个<code>structs</code>的列表。每个<code>struct</code>由调用目标invocation target（<code>EventTarget</code>对象）、影子树中的调用目标invocation-target-in-shadow-tree（布尔值）、影子调整目标shadow-adjusted target（潜在事件目标）、relatedTarget（潜在事件目标）、touch target list（潜在事件目标列表）、封闭树根root-of-closed-tree（布尔值）和封闭树槽slot-in-closed-tree（布尔值）组成。一个<code>path</code>最初是空列表。</p>
<p>——————<br />
对于Web开发者：<br />
<code>event = new Event(type [, eventInitDict])</code><br />
返回一个新event，其<code>type</code>特性被设为参数<code>type</code>。<code>eventInitDict</code>参数允许通过同名的对象成员设置<code>bubbles</code>和<code>cancelable</code>特性</p>
<p><code>event . type</code><br />
返回event的类型，例如<code>&quot;click&quot;</code>、<code>&quot;hashchange&quot;</code>或<code>&quot;submit&quot;</code></p>
<p><code>event . target</code><br />
返回事件派发的对象(target)</p>
<p><code>event . currentTarget</code><br />
返回一个对象，其事件监听器的回调目前正被调用</p>
<p><code>event . composedPath()</code><br />
返回事件的<code>path</code>的调用目标(invocation target)对象（也就是将调用监听器的对象），但影子树中任何影子根的<code>mode</code>为<code>&quot;closed&quot;</code>，且不能从事件的<code>currentTarget</code>到达的结点除外</p>
<p><code>event . eventPhase</code><br />
返回事件的阶段，值是<code>NONE</code>, <code>CAPTURING_PHASE</code>, <code>AT_TARGET</code>和 <code>BUBBLING_PHASE</code>其中之一。</p>
<p><code>event . stopPropagation()</code><br />
当在树中派发时，调用这个方法可以防止事件到达除当前对象以外的任何对象。</p>
<p><code>event . stopImmediatePropagation()</code><br />
调用这个方法可以防止事件在当前的事件监听器运行结束后，到达任何注册过的事件监听器（也就是说当前对象的其他监听器），当在一个树中派发时，也会防止事件到达任何其他对象。</p>
<p><code>event . bubbles</code><br />
根据事件的初始化方式，返回<code>true</code>或<code>false</code>。如果事件会以逆序的树顺序通过其target的祖先，则为<code>true</code>；否则为<code>false</code>。</p>
<p><code>event . cancelable</code><br />
根据事件的初始化方式，返回<code>true</code>或<code>false</code>。它的返回值并不总是有意义的，但是<code>true</code>可以表示在事件被派发的过程中，部分操作可以通过调用<code>preventDefault()</code>方法来取消。</p>
<p><code>event . preventDefault()</code><br />
如果在<code>cancelable</code>特性值为<code>true</code>时调用，并且在执行事件的监听器时，<code>passive</code>被设为<code>false</code>，则向导致事件被派发的操作发出信号表明它需要被取消。</p>
<p><code>event . defaultPrevented</code><br />
如果<code>preventDefault()</code>被成功调用，返回<code>true</code>表示已取消；否则返回<code>false</code>。</p>
<p><code>event . composed</code><br />
根据事件的初始化方式，返回<code>true</code>或<code>false</code>。如果事件经过一个<code>ShadowRoot</code>结点的监听器，且这个结点是target的根，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p><code>event . isTrusted</code><br />
如果事件是由用户代理派发的，返回<code>true</code>，否则返回<code>false</code></p>
<p><code>event . timeStamp</code><br />
以相对于时间原点(time origin)测量的毫秒数形式返回事件的时间戳。<br />
——————</p>
<p><code>type</code>特性必须返回它被初始化的值。当一个事件被创建时，该特性必须被初始化为空字符串。</p>
<p><code>target</code> getter步骤会返回Event接口的<code>target</code></p>
<p><code>srcElement</code>getter步骤会返回Event接口的<code>target</code></p>
<p><code>currentTarget</code>特性必须返回它被初始化的值。当一个事件被创建时，该特性必须被初始化为<code>null</code>。</p>
<p><code>composedPath()</code>方法步骤：</p>
<ol>
<li>令<code>composedPath</code>为空列表</li>
<li>令<code>path</code>为<code>this.path</code></li>
<li>如果<code>path</code>为空，则返回<code>composedPath</code></li>
<li>令<code>currentTarget</code>为<code>this.currentTarget</code>特性值</li>
<li>将<code>currentTarget</code>添加到<code>composedPath</code></li>
<li>令<code>currentTargetIndex</code>为<code>0</code></li>
<li>令<code>currentTargetHiddenSubtreeLevel</code>为<code>0</code></li>
<li>令<code>index</code>为<code>path.size</code>再减1</li>
<li>只要<code>index &gt;= 0</code>：
<ol>
<li>如果<code>path[index]</code>的<code>root-of-closed-tree</code>为<code>true</code>，则将<code>currentTargetHiddenSubtreeLevel</code>加1</li>
<li>如果<code>path[index]</code>的<code>invocation target</code>为<code>currentTarget</code>，则将<code>currentTargetIndex</code>设为<code>index</code>然后跳出循环</li>
<li>如果<code>path[index]</code>的<code>slot-in-closed-tree</code>为<code>true</code>，则将<code>currentTargetHiddenSubtreeLevel</code>减<code>1</code></li>
<li>将<code>index</code>减<code>1</code></li>
</ol>
</li>
<li>令<code>currentHiddenLevel</code>和<code>maxHiddenLevel</code>为<code>currentTargetHiddenSubtreeLevel</code></li>
<li>将<code>index</code>设为<code>currentTargetIndex − 1</code></li>
<li>只要<code>index &gt;= 0</code>：
<ol>
<li>如果<code>path[index]</code>的<code>root-of-closed-tree</code>为<code>true</code>，则<code>currentHiddenLevel += 1</code></li>
<li>如果<code>currentHiddenLevel &lt;= maxHiddenLevel</code>，则将<code>path[index]</code>的<code>invocation target</code>添加到<code>composedPath</code>前面</li>
<li>如果<code>path[index]</code>的<code>slot-in-closed-tree</code>为<code>true</code>，则：
<ol>
<li><code>currentHiddenLevel -= 1</code></li>
<li>如果<code>currentHiddenLevel &lt; maxHiddenLevel</code>，则将<code>maxHiddenLevel</code>设为<code>currentHiddenLevel</code></li>
</ol>
</li>
<li><code>index -= 1</code></li>
</ol>
</li>
<li>将<code>currentHiddenLevel</code>和<code>maxHiddenLevel</code>设为<code>currentTargetHiddenSubtreeLevel</code></li>
<li>将<code>index</code>设为<code>currentTargetIndex + 1</code></li>
<li>只要<code>index &lt; path.size</code>
<ol>
<li>如果<code>path[index]</code>的<code>slot-in-closed-tree</code>为<code>true</code>，则<code>currentHiddenLevel += 1</code></li>
<li>如果<code>currentHiddenLevel &lt;= maxHiddenLevel</code>，则将<code>path[index]</code>的<code>invocation target</code>添加到<code>composedPath</code></li>
<li>如果<code>path[index]</code>的<code>root-of-closed-tree</code>为<code>true</code>，则
<ol>
<li><code>currentHiddenLevel -= 1</code></li>
<li>如果<code>currentHiddenLevel &lt; maxHiddenLevel</code>，则将<code>maxHiddenLevel</code>设为<code>currentHiddenLevel</code></li>
</ol>
</li>
<li><code>index += 1</code></li>
</ol>
</li>
<li>返回<code>composedPath</code></li>
</ol>
<p><code>eventPhase</code>特性必须返回它被初始化的值，必须是下列之一：</p>
<ul>
<li><code>NONE</code>（数字值0）：当前没有派发的事件处于此阶段。</li>
<li><code>CAPTURING_PHASE</code>（数字值1）：当一个事件被派发给一个参与了树的对象时，在它到达目标(target)之前，它将处于这个阶段。</li>
<li><code>AT_TARGET</code>（数字值2）：当一个事件被派发时，当它在目标(target)上时，它将处于这个阶段。</li>
<li><code>BUBBLING_PHASE</code>（数字值3）：当一个事件被派发给一个参与了树的对象时，在它到达目标(target)之后，它将处于这个阶段。</li>
</ul>
<p>此特性最初被初始化为<code>NONE</code></p>
<p>每个Event有下列关联标志(flag)，最初都没有设置：</p>
<ul>
<li>stop propagation flag</li>
<li>stop immediate propagation flag</li>
<li>canceled flag</li>
<li>in passive listener flag</li>
<li>composed flag</li>
<li>initialized flag</li>
<li>dispatch flag</li>
</ul>
<p><code>stopPropagation()</code>方法步骤会设置stop propagation flag</p>
<p><code>cancelBubble</code>getter步骤当stop propagation flag被设置时返回<code>true</code>，否则返回<code>false</code></p>
<p><code>cancelBubble</code>setter在给定值为<code>true</code>时设置stop propagation flag，否则什么也不做</p>
<p><code>stopImmediatePropagation()</code>方法步骤设置stop propagation flag和stop immediate propagation flag</p>
<p><code>bubbles</code>和<code>cancelable</code>特性必须返回它们初始化时的值</p>
<p>为了设置canceled flag，给定事件<code>event</code>，如果<code>event</code>的<code>cancelable</code>特性值为<code>true</code>且<code>event</code>的in passive listener flag没有设置，则设置<code>event</code>的canceled flag。否则什么也不做。</p>
<p><code>returnValue</code>getter步骤会在 canceled flag被设置时返回<code>false</code>，否则返回<code>true</code></p>
<p><code>returnValue</code>setter步骤会在给定值为<code>false</code>时设置canceled flag，否则什么也不做</p>
<p><code>preventDefault()</code>方法步骤会设置canceled flag</p>
<p>注意：在某些情况下，调用<code>preventDefault()</code>没有效果。我们鼓励用户代理在开发者控制台中记录准确的原因，以帮助调试。</p>
<p><code>defaultPrevented</code>getter步骤会在canceled flag被设置时返回<code>true</code>，否则返回<code>false</code></p>
<p><code>composed</code>getter步骤会在composed flag被设置时返回<code>true</code>，否则返回<code>false</code></p>
<p><code>isTrusted</code>特性必须返回它被初始化时的值。当事件被创建时此特性被初始化为<code>false</code>。</p>
<p>注意：<code>isTrusted</code>是一种便利的工具，它表示一个事件是否由用户代理派发（与使用<code>dispatchEvent()</code>相反）。唯一的例外是<code>click()</code>，它导致用户代理派发一个<code>isTrusted</code>属性被初始化为<code>false</code>的事件。</p>
<p><code>timeStamp</code>特性必须返回它被初始化时的值。</p>
<p>要使用<code>type</code>, <code>bubbles</code>, <code>cancelable</code>初始化一个事件<code>event</code>，执行以下步骤：</p>
<ol>
<li>设置<code>event</code>的initialized flag</li>
<li>取消设置<code>event</code>的stop propagation flag, stop immediate propagation flag, 和 canceled flag</li>
<li>将<code>event</code>的<code>isTrusted</code>特性设为<code>false</code></li>
<li>将<code>event</code>的<code>target</code>设为<code>null</code></li>
<li>将<code>event</code>的<code>type</code>特性设为<code>type</code></li>
<li>将<code>event</code>的<code>bubbles</code>特性设为<code>bubbles</code></li>
<li>将<code>event</code>的<code>cancelable</code>特性设为<code>cancelable</code></li>
</ol>
<p><code>initEvent(type, bubbles, cancelable)</code>方法步骤为：</p>
<ol>
<li>如果dispatch flag被设置了，则返回</li>
<li>使用<code>type</code>, <code>bubbles</code>, <code>cancelable</code>初始化事件</li>
</ol>
<p>注意：<code>initEvent()</code> 对于事件构造函数来说是多余的，并且无法设置<code>composed</code>。 但为了旧内容必须支持。</p>
<h2 id="23-window接口的遗留扩展"><a class="markdownIt-Anchor" href="#23-window接口的遗留扩展"></a> 2.3 Window接口的遗留扩展</h2>
<p>[Replaceable]只能用在readonly上，它的set访问器会将该属性转为数据属性，导致接口中规定的属性被替换而失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">partial interface Window &#123;</span><br><span class="line">  [Replaceable] readonly attribute (Event or undefined) event; &#x2F;&#x2F; legacy</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个<code>Window</code>对象有一个关联的当前事件(current event)（<code>undefined</code>或<code>Event</code>对象）。除非另有说明，否则它是<code>undefined</code>的。</p>
<p><code>event</code>getter步骤会返回它的当前事件。</p>
<p>注意：我们强烈建议Web开发者转而依赖传递给事件监听器的<code>Event</code>对象，因为这将使代码有更好的可移植性。这个特性在worker或worklet中是不可用的，对于影子树中派发的事件是不准确的。</p>
<h2 id="24-customevent接口"><a class="markdownIt-Anchor" href="#24-customevent接口"></a> 2.4 CustomEvent接口</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Exposed&#x3D;(Window,Worker)]</span><br><span class="line">interface CustomEvent : Event &#123;</span><br><span class="line">  constructor(DOMString type, optional CustomEventInit eventInitDict &#x3D; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  readonly attribute any detail;</span><br><span class="line"></span><br><span class="line">  undefined initCustomEvent(DOMString type, optional boolean bubbles &#x3D; false, optional boolean cancelable &#x3D; false, optional any detail &#x3D; null); &#x2F;&#x2F; legacy</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dictionary CustomEventInit : EventInit &#123;</span><br><span class="line">  any detail &#x3D; null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用<code>CustomEvent</code>接口的事件可以携带自定义数据</p>
<p>——————<br />
对于Web开发者：<br />
<code>event = new CustomEvent(type [, eventInitDict])</code><br />
除了<code>eventInitDict</code>参数现在也允许设置<code>detail</code>特性外，其作用与Event的构造函数类似。</p>
<p><code>event . detail</code><br />
返回创建事件时使用的任何自定义数据。通常用于合成事件。<br />
——————</p>
<p><code>detail</code>特性必须返回它被初始化时的值。</p>
<p><code>initCustomEvent(type, bubbles, cancelable, detail)</code>方法步骤：</p>
<ol>
<li>如果设置了<code>dispatch flag</code>，返回</li>
<li>使用<code>type</code>, <code>bubbles</code>和<code>cancelable</code>初始化</li>
<li>将<code>detail</code>特性设为参数<code>detail</code></li>
</ol>
<h2 id="27-eventtarget接口"><a class="markdownIt-Anchor" href="#27-eventtarget接口"></a> 2.7 EventTarget接口</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Exposed=(Window,Worker,AudioWorklet)]</span><br><span class="line">interface EventTarget &#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span>);</span><br><span class="line"></span><br><span class="line">  <span class="literal">undefined</span> addEventListener(DOMString type, EventListener? callback, optional (AddEventListenerOptions or boolean) options = &#123;&#125;);</span><br><span class="line">  <span class="literal">undefined</span> removeEventListener(DOMString type, EventListener? callback, optional (EventListenerOptions or boolean) options = &#123;&#125;);</span><br><span class="line">  boolean dispatchEvent(Event event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">callback interface EventListener &#123;</span><br><span class="line">  <span class="literal">undefined</span> handleEvent(Event event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dictionary EventListenerOptions &#123;</span><br><span class="line">  boolean capture = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dictionary AddEventListenerOptions : EventListenerOptions &#123;</span><br><span class="line">  boolean passive = <span class="literal">false</span>;</span><br><span class="line">  boolean once = <span class="literal">false</span>;</span><br><span class="line">  AbortSignal signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>EventTarget</code>对象表示在某事情发生时，事件所派发到的目标。</p>
<p>每个<code>EventTarget</code>对象有关联的事件监听器列表（零个或多个事件监听器）。它最初被初始化为空列表。</p>
<p>一个事件监听器用来观察特定的事件，它由下列内容组成：</p>
<ul>
<li><code>type</code>（类型，是一个字符串）</li>
<li><code>callback</code>（回调函数，是<code>null</code>或<code>EventListener</code>对象）</li>
<li><code>capture</code>（布尔值，最初为<code>false</code>）</li>
<li><code>passive</code>（布尔值，最初为<code>false</code>）</li>
<li><code>once</code>（布尔值，最初为<code>false</code>）</li>
<li><code>signal</code>（信号，<code>null</code>或<code>AbortSignal</code>对象）</li>
<li><code>removed</code>（布尔值，用于记录，最初为<code>false</code>）</li>
</ul>
<p>注意：尽管<code>callback</code>是<code>EventListener</code>对象，但事件监听器是一个更广泛的概念，正如上面所述。</p>
<p>每个<code>EventTarget</code>对象有一个关联的<code>get the parent</code>算法，它接受一个事件<code>event</code>，并返回<code>EventTarget</code>对象。除非另有说明，否则它返回<code>null</code>。</p>
<p>注意：<code>Nodes</code>、<code>shadow roots</code>和<code>documents</code>重写了<code>get the parent</code>算法</p>
<p>每个<code>EventTarget</code>对象有一个关联的<code>activation behavior</code>算法，<code>activation behavior</code>算法被传递一个事件，如<code>dispatch</code>算法中所示。</p>
<p>注意：它的存在是因为用户代理对某些<code>EventTarget</code>对象（例如，<code>area</code>元素）执行某些动作，以响应<code>type</code>属性为<code>click</code>的合成<code>MouseEvent</code>事件。Web兼容性阻止了它被删除，现在它是定义某个东西的激活的规范方式。[HTML]</p>
<p>每个有<code>activation behavior</code>的<code>EventTarget</code>对象，都可以同时拥有（而不是任一）<code>legacy-pre-activation behavior</code>算法和<code>legacy-canceled-activation behavior</code>算法。</p>
<p>注意：这些算法只存在于复选框和单选<code>input</code>元素，不能用在其他地方[HTML]</p>
<p>——————<br />
对于Web开发者：<br />
<code>target = new EventTarget();</code><br />
创建一个新的<code>EventTarget</code>对象，可以被开发者用来派发和监听事件。</p>
<p><code>target . addEventListener(type, callback [, options])</code><br />
为<code>type</code>特性值为参数<code>type</code>的事件添加一个事件监听器。<code>callback</code>参数设置了事件监听器的<code>callback</code>，并且在事件被派发时将被会调用它。<br />
<code>options</code>参数设置监听器特定的选项。为了兼容，它可以是一个布尔值，在这种情况下，该方法的行为与指定了<code>options</code>的<code>capture</code>完全一样。<br />
当<code>options.capture</code>为<code>true</code>时，会在事件的<code>eventPhase</code>特性值为<code>BUBBLING_PHASE</code>时阻止<code>callback</code>的调用；当<code>options.capture</code>为<code>false</code>或不存在时，会在事件的<code>eventPhase</code>特性值为<code>CAPTURING_PHASE</code>时阻止<code>callback</code>的调用。无论如何，如果事件的<code>eventPhase</code>特性值是<code>AT_TARGET</code>，<code>callback</code>将被调用。<br />
当<code>options.passive</code>为<code>true</code>时，它表示<code>callback</code>将不会因为调用<code>preventDefault()</code>而被取消。这是用来实现 2.8 观察事件监听器中描述的性能优化的。<br />
当<code>options.once</code>为<code>true</code>时，它表示<code>callback</code>只会被调用一次，随后事件监听器将被移除。<br />
如果一个<code>AbortSignal</code>被传递给<code>options.signal</code>，那么当信号被终止时，事件监听器将被移除。<br />
事件监听器被追加到目标的事件监听器列表中，如果它有相同的<code>type</code>、<code>callback</code>和<code>capture</code>，则不会被追加。</p>
<p><code>target . removeEventListener(type, callback [, options])</code><br />
移除目标的事件监听器列表中具有相同<code>type</code>、<code>callback</code>和<code>options</code>的事件监听器。</p>
<p><code>target . dispatchEvent(event)</code><br />
向<code>target</code>派发一个合成事件<code>event</code>，如果<code>event.cancelable</code>特性为<code>false</code>或者它的<code>preventDefault()</code>方法没被调用过，返回<code>true</code>，否则返回<code>false</code></p>
<p>为了<code>flatten</code> options，执行以下步骤：</p>
<ol>
<li>如果<code>options</code>是布尔值，返回<code>options</code></li>
<li>返回 <code>options['capture']</code></li>
</ol>
<p>为了<code>flattern more</code> options，执行以下步骤：</p>
<ol>
<li>令<code>capture</code>为<code>flatten</code>options的结果</li>
<li>令<code>once</code>和<code>passive</code>为<code>false</code></li>
<li>令<code>signal</code>为<code>null</code></li>
<li>如果<code>options</code>是字典，则：
<ol>
<li>将<code>passive</code>设为<code>options['passive']</code>，将<code>once</code>设为<code>options['once']</code></li>
<li>如果<code>options['signal']</code>存在，将<code>signal</code>设为<code>options['signal']</code></li>
</ol>
</li>
<li>返回<code>capture</code>, <code>passive</code>, <code>once</code>和<code>signal</code></li>
</ol>
<p><code>new EventTarget()</code>构造步骤什么也不做。</p>
<p>注意：由于其他地方的默认值，返回的<code>EventTarget</code>的<code>get the parent</code>算法将返回<code>null</code>，并且它将没有<code>activation behavior</code>, <code>legacy-pre-activation behavior</code>, 或<code>legacy-canceled-activation behavior</code></p>
<p>注意：在未来，我们可以允许自定义<code>get the parent</code>算法。如果这对你的程序有用，请告诉我们。目前，所有作者创建的<code>EventTarget</code>都不参与树结构。</p>
<p>为了<code>add an event listener</code>，给定<code>EventTarget</code>对象<code>eventTarget</code>和事件监听器<code>listener</code>，执行以下步骤：</p>
<ol>
<li>如果<code>eventTarget</code>是<code>ServiceWorkerGlobalScope</code>对象，且<code>service worker</code>的<code>script resource</code>的<code>has ever been evaluated flag</code>被设置，并且监听器的类型与任何一个<code>service worker events</code>的<code>type</code>特性值相匹配，则向控制台报告一个警告，即这可能不会得到预期的结果。</li>
<li>如果<code>signal</code>不是<code>null</code>并且它的<code>aborted flag</code>被设置，则返回</li>
<li>如果<code>listener.callback</code>为<code>null</code>，则返回</li>
<li>如果<code>eventTarget</code>的事件监听器列表不包含一个<code>type</code>为<code>listener.type</code>，<code>callback</code>为<code>listener.callback</code>，<code>capture</code>为<code>listener.capture</code>的事件监听器，则将<code>listener</code>添加到<code>eventTarget</code>的事件监听器列表中。</li>
<li>如果<code>listener.signal</code>不为<code>null</code>，则为它添加下列终止步骤：
<ol>
<li>使用<code>eventTarget</code>和<code>listener</code>移除事件监听器</li>
</ol>
</li>
</ol>
<p>注意：<code>add an event listener</code>概念的存在是为了确保事件处理程序使用相同的代码路径。[HTML]</p>
<p><code>addEventListener(type, callback, options)</code>方法步骤：</p>
<ol>
<li>令<code>capture</code>, <code>passive</code>和<code>once</code>为<code>flattening more</code>options的结果</li>
<li>使用<code>this</code>和一个<code>type</code>为<code>type</code>, <code>callback</code>为<code>callback</code>, <code>capture</code>为<code>capture</code>, <code>passive</code>为<code>passive</code>, <code>once</code>为<code>once</code>, <code>signal</code>为<code>signal</code>的事件监听器执行<code>Add an event listener</code></li>
</ol>
<p>为了<code>remove an event listener</code>，给定<code>EventTarget</code>对象<code>eventTarget</code>和事件监听器<code>listener</code>，执行以下步骤：</p>
<ol>
<li>如果<code>eventTarget</code>是<code>ServiceWorkerGlobalScope</code>对象，且<code>service worker</code>的<code>set of event types to handle</code>包含<code>type</code>，则向控制台报告一个警告，即这可能不会得到预期的结果。[SERVEICE-WORKERS]</li>
<li>将<code>listener.removed</code>设为<code>true</code>，然后从<code>eventTarget</code>的事件监听器列表中移除<code>listener</code></li>
</ol>
<p>注意：HTML需要此项来定义事件处理程序[HTML]</p>
<p>为了<code>remove all event listeners</code>，给定<code>EventTarget</code>对象<code>eventTarget</code>，对<code>eventTarget</code>的事件监听器列表中的每个<code>listener</code>，使用<code>eventTarget</code>和<code>listener</code>执行<code>remove an event listener</code></p>
<p>注意：HTML需要此项来定义<code>document.open()</code>[HTML]</p>
<p><code>removeEventListener(type, callback, options)</code>方法步骤：</p>
<ol>
<li>令<code>capture</code>为<code>flattening</code>options的结果</li>
<li>如果<code>this</code>的事件监听器列表包含一个事件监听器，其<code>type</code>为<code>type</code>，<code>callback</code>为<code>callback</code>，<code>capture</code>为<code>capture</code>，则用<code>this</code>和这个事件监听器执行<code>remove an event listener</code></li>
</ol>
<p>注意：事件监听器列表不会包含多个具有相同<code>type</code>、<code>callback</code>和<code>capture</code>的事件监听器，因为<code>add an event listener</code>时阻止了这种情况。</p>
<p><code>dispatchEvent(event)</code>方法步骤：</p>
<ol>
<li>如果<code>event</code>的<code>dispatch flag</code>被设置，或如果它的<code>initialized flag</code>没设置，则抛出<code>InvalidStateError</code>异常</li>
<li>将<code>event</code>的<code>isTrusted</code>初始化为<code>false</code></li>
<li>返回向<code>this</code>派发<code>event</code>的结果</li>
</ol>
<h2 id="28-观察事件监听器"><a class="markdownIt-Anchor" href="#28-观察事件监听器"></a> 2.8 观察事件监听器</h2>
<p>一般来说，开发者并不期望事件监听器的存在可以被观察到。事件监听器的影响是由其回调决定的。也就是说，一个开发者添加一个无操作的事件监听器不会期望它有任何副作用。</p>
<p>不幸的是，一些事件API被设计成有效地实现它们需要观察事件监听器。这可以使监听器的存在被观察到，即使是空的监听器也会对应用程序的行为产生巨大的性能影响。例如，触摸和滚轮事件，可以用来阻止异步滚动。在某些情况下，这个问题可以通过指定事件只有在至少有一个非<code>passive</code>监听器的情况下才可以取消而得到缓解。例如，非<code>passive</code>的TouchEvent监听器必须阻止滚动，但如果所有的监听器都是被动的，那么可以通过使TouchEvent不可取消来允许滚动开始（这样对<code>preventDefault()</code>的调用就被忽略了）。因此，调度事件的代码能够观察到非<code>passive</code>的监听器的不存在，并使用它来清除被调度的事件的<code>cancelable</code>属性。</p>
<p>理想情况下，任何新的事件API被定义为不需要这个属性（使用public-script-coord@w3.org 来讨论）。</p>
<h2 id="211-行动vs发生"><a class="markdownIt-Anchor" href="#211-行动vs发生"></a> 2.11 行动vs发生</h2>
<p>一个事件表示一个发生，而不是一个行动。换句话说，它代表来自一个算法的通知，可以用来影响该算法的未来进程（例如，通过调用<code>preventDefault()</code>）。事件不能被用作导致某些算法开始运行的行动或启动器。这不是它们的作用。</p>
<p>注意：这里特别指出，因为以前的DOM迭代有一个与事件相关的 &quot;默认行动 &quot;的概念，给了人们所有错误的想法。事件不代表或导致行动，它们只能被用来影响正在进行的行动。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/前端/DOM/DOM标准/2 事件.html">https://rcocco.github.io/categories/计算机/前端/DOM/DOM标准/2 事件.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/DOM/DOM%E6%A0%87%E5%87%86/1%20%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD.html"><i class="fa fa-chevron-left">  </i><span>1 基础设施</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/DOM/DOM%E6%A0%87%E5%87%86/4%20Nodes.html"><span>4 Nodes</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>