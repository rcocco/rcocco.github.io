<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Vue"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>Vue | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text"> Vue实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9"><span class="toc-number">2.1.</span> <span class="toc-text"> 选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 挂载目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 字符串模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.5.</span> <span class="toc-text"> 计算属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text"> 侦听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">2.1.7.</span> <span class="toc-text"> 生命周期钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.8.</span> <span class="toc-text"> 使用的子组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.</span> <span class="toc-text"> 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text"> 内置属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.</span> <span class="toc-text"> Vue模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#html%E6%A0%87%E7%AD%BE"><span class="toc-number">3.1.</span> <span class="toc-text"> HTML标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html%E6%96%87%E6%9C%AC"><span class="toc-number">3.2.</span> <span class="toc-text"> HTML文本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 插值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html%E5%B1%9E%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text"> HTML属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC-2"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 插值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.</span> <span class="toc-text"> 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 属性绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">3.4.2.1.</span> <span class="toc-text"> 条件渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%98%BE%E7%A4%BA"><span class="toc-number">3.4.2.2.</span> <span class="toc-text"> 条件显示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">3.4.4.</span> <span class="toc-text"> 事件绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.4.1.</span> <span class="toc-text"> 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.4.1.1.</span> <span class="toc-text"> 键盘事件修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.4.1.2.</span> <span class="toc-text"> 鼠标事件修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.4.1.3.</span> <span class="toc-text"> 系统键修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">3.4.5.</span> <span class="toc-text"> 双向数据绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6-2"><span class="toc-number">3.4.5.1.</span> <span class="toc-text"> 修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.6.</span> <span class="toc-text"> 自定义指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text"> Vue组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%84%E4%BB%B6%E5%90%8D"><span class="toc-number">4.1.</span> <span class="toc-text"> 关于组件名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.2.</span> <span class="toc-text"> 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 内联模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-2"><span class="toc-number">4.3.</span> <span class="toc-text"> 选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%E5%90%8D"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 内部组件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 引用其他组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7-2"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#html%E5%B1%9E%E6%80%A7-2"><span class="toc-number">4.3.4.</span> <span class="toc-text"> HTML属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF"><span class="toc-number">4.3.5.</span> <span class="toc-text"> 属性继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.6.</span> <span class="toc-text"> 双向绑定指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%A5%96%E5%85%88%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.7.</span> <span class="toc-text"> 访问祖先组件数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%85%A5%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9"><span class="toc-number">4.3.8.</span> <span class="toc-text"> 混入其他选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">4.3.9.</span> <span class="toc-text"> 函数式组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.3.10.</span> <span class="toc-text"> 过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">4.4.</span> <span class="toc-text"> 消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%90%91%E5%A4%96%E4%BC%A0%E9%80%92"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 组件向外传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%90%91%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 外部向组件传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A-2"><span class="toc-number">4.5.</span> <span class="toc-text"> 双向数据绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%AE%80%E5%86%99"><span class="toc-number">4.5.1.</span> <span class="toc-text"> 修饰符简写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.</span> <span class="toc-text"> v-model指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD"><span class="toc-number">4.6.</span> <span class="toc-text"> 插槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 命名插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.6.3.</span> <span class="toc-text"> 可访问的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%8F%92%E6%A7%BD%E5%90%8D"><span class="toc-number">4.6.4.</span> <span class="toc-text"> 动态插槽名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7-2"><span class="toc-number">4.7.</span> <span class="toc-text"> 内置属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">4.7.1.</span> <span class="toc-text"> 事件监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.2.</span> <span class="toc-text"> 事件侦听方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7"><span class="toc-number">4.7.3.</span> <span class="toc-text"> 继承属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">4.7.4.</span> <span class="toc-text"> Vue实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.7.5.</span> <span class="toc-text"> 父组件实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.7.6.</span> <span class="toc-text"> 子组件实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD%E5%86%85%E5%AE%B9"><span class="toc-number">4.7.7.</span> <span class="toc-text"> 插槽内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">4.8.</span> <span class="toc-text"> 动态组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">4.9.</span> <span class="toc-text"> 异步组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6"><span class="toc-number">4.10.</span> <span class="toc-text"> 递归组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">4.11.</span> <span class="toc-text"> 循环引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5"><span class="toc-number">5.</span> <span class="toc-text"> 全局混入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%B7%E5%85%A5%E7%AD%96%E7%95%A5"><span class="toc-number">5.1.</span> <span class="toc-text"> 自定义混入策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">6.</span> <span class="toc-text"> 过渡动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%B4%A0%E7%BB%84%E4%BB%B6%E8%BF%87%E6%B8%A1"><span class="toc-number">6.1.</span> <span class="toc-text"> 单元素&#x2F;组件过渡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">7.</span> <span class="toc-text"> 虚拟DOM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text"> 渲染函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.</span> <span class="toc-text"> 常用指令的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6-3"><span class="toc-number">8.2.</span> <span class="toc-text"> 修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jsx"><span class="toc-number">8.3.</span> <span class="toc-text"> JSX</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-2"><span class="toc-number">8.4.</span> <span class="toc-text"> 函数式组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text"> 插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">9.1.</span> <span class="toc-text"> 使用插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6"><span class="toc-number">9.2.</span> <span class="toc-text"> 开发插件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8-2"><span class="toc-number">10.</span> <span class="toc-text"> 过滤器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text"> 单文件组件</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">188</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Vue</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/">前端</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p>Vue是一个JavaScript框架，它不止包含了Pug和Liquid等模板引擎的功能，还实现了许多基于JavaScript的额外功能，例如数据与渲染元素的绑定等等。</p>
<span id="more"></span>
<h1 id="vue实例"><a class="markdownIt-Anchor" href="#vue实例"></a> Vue实例</h1>
<p>每个Vue组件或者说渲染出的元素都是一个Vue实例。<br />
要创建一个Vue实例，需要调用<code>Vue</code>构造函数，它接受一个表示选项的对象，对象的每个属性对应一个选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(option);</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a class="markdownIt-Anchor" href="#选项"></a> 选项</h2>
<h3 id="挂载目标"><a class="markdownIt-Anchor" href="#挂载目标"></a> 挂载目标</h3>
<p><code>el</code>选项用于指定挂载目标，一个Vue实例对应的视图（渲染出的元素），最终需要替换掉页面上已存在的某个元素才能显示出来。<code>el</code>选项就是用来指定这个被替换掉的元素。<br />
它可以是一个CSS选择器字符串，也可以是一个DOM中的HTMLElement对象。<br />
如果在创建Vue实例时没有提供这个选项，则Vue实例将处于未挂载状态，不会显示在页面上，需要手动调用<code>vm.$mount(el)</code>来挂载到某个元素上。</p>
<h3 id="字符串模板"><a class="markdownIt-Anchor" href="#字符串模板"></a> 字符串模板</h3>
<p><code>template</code>选项用于指定此Vue实例渲染元素所使用的字符串模板。<br />
当<code>template</code>的值是一个以<code>#</code>开头的字符串时，它被理解为一个CSS选择器，被选中的元素的innerHTML会作为字符串模板。<br />
当<code>template</code>的值不以<code>#</code>开头时，它被理解为Vue模板的源代码字符串。<br />
当不提供此选项时，<code>template</code>的值会从挂载目标<code>el</code>的outerHTML中得到。</p>
<p>写在<code>template</code>的优点是不会像写在HTML正文中预先被浏览器解析一遍，因为浏览器解析时会把元素的属性名小写，并且无法正确处理非原生的自闭合标签。<br />
另外，有些元素例如<code>ul</code>、<code>table</code>等对能出现在内部的元素类型有限制，如果在内部放置自定义组件，会导致被浏览器拿出去。</p>
<p>注意：模板中的HTML代码只能有一个最外层元素。</p>
<h3 id="数据属性"><a class="markdownIt-Anchor" href="#数据属性"></a> 数据属性</h3>
<p><code>data</code>选项用于为Vue实例添加数据属性，<code>data</code>是一个对象，它的每个属性都会被加入到Vue的响应式系统中（递归的变为getter/setter访问器属性），当这些属性的值发生变化时，视图也将会自动更新为变化后的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> customData = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  c: <span class="string">&quot;qwer&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: customData</span><br><span class="line">&#125;);</span><br><span class="line">vm.b === data.b; <span class="comment">// true，它们是同一个对象</span></span><br></pre></td></tr></table></figure>
<p>只有在通过<code>data</code>选项添加的数据属性才会被加入到Vue响应式系统中，如果你之后通过<code>vm.d = 2</code>这样的形式直接为Vue实例添加属性，它的改动将不会触发视图更新。<br />
因此，即使在创建Vue实例时无法确定一个之后要使用的数据属性的值，也要把它添加到<code>data</code>选项里，为其赋予<code>null</code>等表示空的值，以便响应式系统在将来能够跟踪到这些数据属性的变化。</p>
<p>数据属性创建后，可以通过<code>vm.$data</code>访问原始数据对象。也可以通过<code>vm</code>访问，例如<code>vm.a</code>等价于<code>vm.$data.a</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 将obj所有属性改成get和set，在set时调用callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = obj[key];</span><br><span class="line">    <span class="keyword">if</span>(val &amp;&amp; <span class="keyword">typeof</span> val == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      observe(val);</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(newVal === val) <span class="keyword">return</span>;</span><br><span class="line">          val = observe(newVal, callback);</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(newVal === val) <span class="keyword">return</span>;</span><br><span class="line">          val = newVal;</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a.p = 2</span></span><br><span class="line"><span class="comment">// a.p = &#123; x:1, y:2 &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">let</span> val = obj[key];</span><br><span class="line">      observe(val, callback);</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(newVal === val) <span class="keyword">return</span>;</span><br><span class="line">          val = observe(newVal, callback);</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Vue自带的函数可以使新增属性被监听。<br />
Vue.set(app.$data.todos, 2, {done:false, content: ‘999’})</p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<p><code>methods</code>选项用于为Vue实例添加方法。<code>methods</code>属性是一个对象，它的每个属性键都对应一个函数。这些函数的<code>this</code>指向Vue实例（不要用箭头函数来定义方法，否则<code>this</code>不是Vue实例）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">plus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.a++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：方法内多次更新同一个数据属性，例如<code>this.a++;this.a++</code>，最终只会修改一次DOM，因为数据属性的更新是被安排成异步任务的。<br />
所以如果有一个条件渲染的<code>&lt;input id=&quot;editBox&quot; v-if=&quot;editingIdx == idx&quot;&gt;</code>元素，在Vue中下列写法无法找到对应元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">startEdit</span>(<span class="params">idx</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.editingIdx = idx;</span><br><span class="line">  <span class="comment">// 此时视图还没有更新，也就没有#editBox元素</span></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#editBox&#x27;</span>).focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议：不要修改传递进来的值，如果想要修改， 就先将其赋给自己（组件）的数据属性，再修改自己的数据属性。因为Vue的数据与视图绑定，修改传递进来的值很可能导致视图更新，如果父组件视图更新，那么方法所属的子组件也会被更新。</p>
<h3 id="计算属性"><a class="markdownIt-Anchor" href="#计算属性"></a> 计算属性</h3>
<p><code>computed</code>选项用于为Vue实例添加计算属性。计算属性是一个基于已有数据计算得到的新数据，每当已有数据发生了变化，计算属性的值也会自动改变。<br />
计算属性实际上是一个访问器属性，每当访问或设置该属性时，会执行相应的函数。<br />
可以通过Vue实例访问到计算属性，就和访问数据属性一样。</p>
<p><code>computed</code>选项是一个对象，它的每个属性键都对应一个函数或者一个对象。<br />
在选项中定义计算属性的有两种方法：<br />
第一种是定义为<code>computed</code>对象的方法，方法名就是计算属性名，这种形式只能定义计算属性的get方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">norm</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第二种是在<code>computed</code>对象中定义一个对象属性，属性名是计算属性名，属性值是一个对象，该对象包含名为<code>get</code>的方法（作为get访问器函数）和名为<code>set</code>的方法（作为set访问器函数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = v - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这些函数的<code>this</code>指向Vue实例，所以不要用箭头函数来定义方法，否则<code>this</code>不是Vue实例，但你可以将Vue实例作为方法的第一个参数来在箭头函数中引用Vue实例（get可行，set呢？）</p>
<p>注意：计算属性最终是访问器属性，但你不能直接在<code>comptued</code>选项中直接定义访问器属性，Vue无法理解你的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 下面的定义不行</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">reversedMessage</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>计算属性的一个常见用途是用于插值表达式：<br />
插值中的表达式如果有复杂的逻辑，会导致代码很长，难以维护。例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了计算属性后，就可以将前面复杂的插值表达式变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; reversedMessage &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>计算属性作为执行函数的访问器属性，自然也可以用<code>methods</code>选项中定义的方法实现。<br />
但二者最根本的区别是，Vue的计算属性是基于它们的响应式依赖进行缓存的，也就是说如果相关依赖（第一次调用时就能知道要读取哪些数据属性，因为数据属性是get访问器属性）没有修改，计算属性不会被重新求值。而方法不会进行缓存，每次渲染都会被调用。</p>
<p>如下面的例子，由于<code>Date.now()</code>不是响应式依赖，因此计算属性的<code>now</code>只在第一次渲染时被求值，之后的值不会改变。而<code>nowMethod</code>每一次渲染时都会求值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">nowMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">now</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>缓存有利于节约计算耗费的时间，如果不希望缓存，就不要使用计算属性，而是使用方法。</p>
<p>注意，计算属性仅在第一次执行时记录它依赖的所有数据属性，如果其中使用了条件语句，那么第一次执行时只会读取<code>x</code>和<code>str</code>，之后只有当这两个数据发生变化时计算属性才会改变。而<code>str2</code>改变时计算属性不会自动变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">h</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.str;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.str2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="侦听器"><a class="markdownIt-Anchor" href="#侦听器"></a> 侦听器</h3>
<p><code>watch</code>选项用于为Vue实例添加侦听器。侦听器是某个数据属性发生变化时要执行的函数。与方法的区别在于，侦听器不是主动调用的，而是数据变化时回调。<br />
常见的用法是根据数据变化执行异步操作，根据异步操作的结果修改数据。</p>
<p><code>watch</code>选项是一个对象，它的每个属性键都是要监听的表达式（例如计算属性<code>a</code>或者表达式<code>a.value</code>），属性值可以是一个函数、字符串、对象或数组。<br />
在选项中定义侦听器方法有四种：<br />
第一种：属性值是函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第二种：属性值是字符串，表示一个方法名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">plusA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.a++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    b: <span class="string">&quot;plusA&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第三种：属性值是一个对象。对象的<code>handler</code>属性是必须的，它的属性值一个函数或字符串，表示要执行的函数。<code>deep</code>布尔值属性是可选的，表示是否监听对象内部值的变化，仅在监听的表达式是一个对象时才有意义，数组不需要设置。<code>immediate</code>布尔值属性是可选的，表示是否立即调用该回调（以表达式的当前值触发）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">      deep: <span class="literal">true</span>,</span><br><span class="line">      immediate: <span class="literal">true</span>,</span><br><span class="line">      handler: <span class="string">&#x27;myMethod&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第四种：属性值是一个数组，表示多个要执行的回调，每个元素可以是上述的字符串、函数或对象，三种形式可以混用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: [ <span class="string">&quot;func1&quot;</span>,</span><br><span class="line">         <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(a);</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           deep: <span class="literal">true</span>,</span><br><span class="line">           immediate: <span class="literal">true</span>,</span><br><span class="line">           handler: <span class="string">&#x27;myMethod&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：侦听器内的<code>this</code>指向Vue实例，所以不要用箭头函数定义侦听器。</p>
<p>建议：不要在侦听器里改变全局变量。</p>
<h3 id="生命周期钩子"><a class="markdownIt-Anchor" href="#生命周期钩子"></a> 生命周期钩子</h3>
<p>生命周期中的一个阶段执行完后，Vue会去调用红框所指向的方法（也叫钩子函数），这些方法可以在选项中覆盖，这样用户就介入到Vue实例的创建到销毁的过程。例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="comment">// Init Events &amp; Lifecyle已执行完</span></span><br><span class="line">    <span class="comment">// 即将执行Init injections &amp; reactivity</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a is: &#x27;</span> + <span class="built_in">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意不要把钩子函数定义为箭头函数，否则它的<code>this</code>会是定义箭头函数时包围箭头函数的词法环境的<code>this</code>，在这里由于是全局作用域，<code>this</code>会是<code>window</code>，而不是<code>vm</code>实例。</p>
<p>除了通过选项去执行相应的生命周期钩子函数，还可以通过事件监听器来执行。<br />
在生命周期过程中，每当到达即将触发钩子函数的流程，Vue内部就会派发一个<code>hook:钩子函数名</code>的事件，例如<code>hook:created</code>，你可以监听该事件然后进行相应的处理。</p>
<h3 id="使用的子组件"><a class="markdownIt-Anchor" href="#使用的子组件"></a> 使用的子组件</h3>
<p><code>components</code>选项用于指明Vue实例中要使用的子组件。<code>components</code>是一个对象，属性名是赋予子组件的名字，属性值是子组件的选项对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h2>
<p>一个Vue实例从创建到销毁有以下阶段：<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/_v_images/20210316155855497_20536.png" alt="" width="621" /><br />
Vue.js 带编译器的版本<br />
Vue.runtime.js 不带编译器的版本Vue.compilie<br />
编译器占用将近30K，运行只需要编译器编译出的渲染函数即可。<br />
编译好的函数在app.$options.render<br />
编译器是将模板转换为一个函数，该函数输入<code>options</code>能够输出Vnode虚拟结点。</p>
<p>编译函数就是形如下面的函数，它会被多次调用，Vue会自动比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params">createVnode</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> createVnode(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="built_in">this</span>.str])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init Events &amp; lifecyle 之后，就可以用$on方法<br />
init injections &amp; reactivity 将 选项中的data变成了响应式数据</p>
<h2 id="内置属性"><a class="markdownIt-Anchor" href="#内置属性"></a> 内置属性</h2>
<p><code>vm.$forceUpdate()</code>：强制重新渲染实例本身和插入插槽内容的子组件（而不是所有子组件）</p>
<h1 id="vue模板"><a class="markdownIt-Anchor" href="#vue模板"></a> Vue模板</h1>
<p>渲染HTML元素离不开模板，Vue也有自己的模板语法。</p>
<h2 id="html标签"><a class="markdownIt-Anchor" href="#html标签"></a> HTML标签</h2>
<p>在Vue模板中书写一个HTML元素的方法，和在HTML文件中书写一个HTML元素的方法完全相同。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一个元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意如果模板没有写在<code>template</code>选项中，而是作为HTML代码写在了文档中，那么这些代码首先会被浏览器解析，属性名会被小写，然后才会被Vue通过outerHTML得到模板字符串。</p>
<h2 id="html文本"><a class="markdownIt-Anchor" href="#html文本"></a> HTML文本</h2>
<p>Vue中的文本，就是HTML标签内的文本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这里是文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插值"><a class="markdownIt-Anchor" href="#插值"></a> 插值</h3>
<p>在文本中使用<code>&#123;&#123; 表达式 &#125;&#125;</code>可以进行转义插值。插值内可以通过<code>|</code>使用过滤器。<br />
表达式会在Vue实例的<code>$data</code>对象作用域下解析（<code>with(vm.$data)</code>）。<br />
表达式会被放到沙盒中，除了Vue实例的相关属性，只能访问有限的全局变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="built_in">isFinite</span>, <span class="built_in">isNaN</span>,</span><br><span class="line"><span class="built_in">parseFloat</span>, <span class="built_in">parseInt</span>, <span class="built_in">decodeURI</span>, <span class="built_in">decodeURIComponent</span>,</span><br><span class="line"><span class="built_in">encodeURI</span>, <span class="built_in">encodeURIComponent</span>, <span class="built_in">Math</span>, <span class="built_in">Number</span>, <span class="built_in">Date</span>,</span><br><span class="line"><span class="built_in">Array</span>, <span class="built_in">Object</span>, <span class="built_in">Boolean</span>, <span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Map</span>, <span class="built_in">Set</span>,</span><br><span class="line"><span class="built_in">JSON</span>, <span class="built_in">Intl</span>, <span class="built_in">require</span></span><br></pre></td></tr></table></figure>
<p>默认的插值会绑定到相应的表达式上，当表达式的值发生变化时，插值内容也将被自动修改。如果不想进行绑定，可以为元素添加<code>v-once</code>属性。</p>
<p>插值的内容默认会被解释为文本，如果想将插值内容当成HTML代码，可以为元素添加<code>v-html</code>属性。被插值的HTML代码不会被Vue模板渲染，因此在里面书写Vue相关逻辑是无效的，所以也就不能使用<code>v-html</code>来实现其他模板中的导入功能。另外当成HTML代码进行插值也容易导致XSS攻击。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="html属性"><a class="markdownIt-Anchor" href="#html属性"></a> HTML属性</h2>
<p>Vue中的HTML属性，就是HTML代码中的属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插值-2"><a class="markdownIt-Anchor" href="#插值-2"></a> 插值</h3>
<p>文本中的插值语法不能用在属性中。<br />
要对属性的值进行插值，需要使用<code>v-bind</code>指令，将要插值的数据与元素属性进行绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=<span class="string">&quot;dynamicId&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h2>
<p>Vue通过HTML元素上以<code>v-</code>开头的属性实现各种指令，例如<code>v-if</code>用于实现条件渲染。</p>
<p>某些指令可以接受一个参数，参数写在指令名称之后，用冒号分隔，例如<code>v-bind:href</code>。<br />
参数也可以是一个中括号括起来的表达式，表达式的值必须是字符串或<code>null</code>。正常情况是字符串，异常情况是<code>null</code>。例如<code>v-bind:[myattrname]</code>。如果是表达式则有一些特殊限制，它不能有空格和引号。</p>
<p>指令的最后也可以有修饰符，用于指明一个指令应该以特殊方式绑定。修饰符以<code>.</code>开头，例如<code>v-on:sumbit.prevent</code>告诉<code>v-on</code>指令对于触发的事件调用<code>event.preventDefault()</code>。<br />
修饰符类似于过滤器。</p>
<h3 id="属性绑定"><a class="markdownIt-Anchor" href="#属性绑定"></a> 属性绑定</h3>
<p>属性绑定指令<code>v-bind</code>是将表达式与HTML元素属性进行绑定，每当表达式的值发生变化时，HTML元素的属性值也会跟着改变。<br />
该指令常用于属性插值。</p>
<p>属性绑定指令有两种语法：</p>
<ul>
<li><code>v-bind:属性名=&quot;表达式&quot;</code>，这种语法用于将指定的属性名与表达式关联，其中<code>v-bind</code>也可以省略，写为<code>:属性名=&quot;表达式&quot;</code>。表达式内可以通过<code>|</code>使用过滤器。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>v-bind=&quot;对象表达式&quot;</code>，这种语法用于同时设置多个属性名与表达式的关联。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123;href: url, title: &#x27;链接&#x27;&#125;&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">v-bind-title</span>=<span class="string">&quot;&#x27;链接&#x27;&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于布尔值属性，如果表达式的值是<code>null</code>、<code>undefined</code>或<code>false</code>（其他会被ToBoolean转为<code>false</code>的值不在此列），则此属性会被删除，不会出现在HTML元素上</p>
<p>当所绑定的属性是<code>class</code>或<code>style</code>时，表达式也可以是一个对象或数组。</p>
<ol>
<li>对于<code>class</code>属性：
<ul>
<li>当表达式是一个对象时（作为数据属性的对象或者字面值，又或者返回对象的计算属性），如果此对象某个属性的值被转换为布尔值后为<code>true</code>，则该属性的名字就会被添加到类名上。</li>
<li>当表达式是一个数组时，每个元素的值会被添加到类名上。数组元素也可以是一个对象，这使得可以混合使用对象语法和值语法。</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; classObj &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用在组件上：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A">https://cn.vuejs.org/v2/guide/class-and-style.html#用在组件上</a></p>
<ol start="2">
<li>对于<code>style</code>属性：
<ul>
<li>当表达式是一个对象时（作为数据属性的对象或者字面值，又或者返回对象的计算属性），属性值是CSS属性名（驼峰或引号引起来的连字符格式都可），属性值为CSS属性值。当属性值是一个数组CSS属性值数组时，Vue会依次测试每个值浏览器是否支持，最终的值为浏览器支持的第一个值。</li>
<li>当表达式是一个数组时，每个元素都必须是前述样式对象，这些样式对象会被应用到同一个元素上。</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; &#x27;font-family&#x27;: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[&#123;&#x27;color&#x27;: &#x27;red&#x27;&#125;, &#123;&#x27;font-size&#x27;: &#x27;20px&#x27;&#125;]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="条件"><a class="markdownIt-Anchor" href="#条件"></a> 条件</h3>
<h4 id="条件渲染"><a class="markdownIt-Anchor" href="#条件渲染"></a> 条件渲染</h4>
<p>条件渲染指令<code>v-if</code>用于有条件的渲染元素，只有当表达式被转换为布尔值后为<code>true</code>时，才会最终生成的HTML文档中存在该元素。</p>
<p>条件渲染指令的基本语法是：<code>v-if=&quot;表达式&quot;</code>、<code>v-else-if=&quot;表达式&quot;</code>、<code>v-else</code>。<br />
如果存在<code>v-else-if</code>和<code>v-else</code>，那么指令所属元素必须是<code>v-if</code>所属元素的相邻兄弟元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>C<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于指令必须写在元素上，因此如果想在使<code>v-if</code>条件性的渲染多个元素，可以使用<code>&lt;template&gt;</code>元素，最终它不会被渲染。<br />
另外，对于一组<code>v-if</code>中不同的条件块，如果是相同标签的元素会被复用。即下面的<code>label</code>和<code>input</code>实际上是同一个，只不过被修改了属性。因此在<code>v-if</code>的<code>input</code>中输入的内容，切换到<code>v-else</code>的<code>input</code>仍然存在。<br />
如果不想让Vue复用相同标签的元素，可以为每个元素添加一个<code>key</code>属性，指定不同的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>复用元素<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>不复用元素<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="条件显示"><a class="markdownIt-Anchor" href="#条件显示"></a> 条件显示</h4>
<p>条件显示指令<code>v-show</code>用于有条件的设置元素的<code>display</code>属性，以控制是否显示在文档流中，但元素始终存在于最终生成的HTML文档中。当表达式被转换为布尔值后为<code>false</code>时，其属性被设置为<code>display: none</code>。</p>
<p>条件渲染指令的基本语法是：<code>v-show=&quot;表达式&quot;</code>。<br />
它不支持<code>v-else-if</code>、<code>v-else</code>和<code>&lt;template&gt;</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<p>循环指令<code>v-for</code>用于循环指定次数，或者遍历一个数组的元素或对象的属性，每次迭代都会渲染出一个元素。</p>
<p>对于整数，循环指令的基本语法是<code>v-for=&quot;索引 of 10&quot;</code><br />
对于数组，循环指令的基本语法是<code>v-for=&quot;元素名 of 数组对象&quot;</code>或<code>v-for=&quot;(元素名, 索引) of 数组对象&quot;</code><br />
对于对象，循环指令的基本语法是<code>v-for=&quot;属性值 in 对象&quot;</code>或<code>v-for=&quot;(属性值, 属性名) in 对象&quot;</code>。遍历对象时会按<code>Object.keys()</code>内置方法的结果顺序遍历。<br />
以上所有的<code>in</code>和<code>of</code>都可以互相替换。<br />
其中数组或对象可以是直接的数据属性，也可以是计算属性，还可以是由方法得到的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n of 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item of items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) of items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在使用循环指令的元素上，其他指令可以使用循环指令创建的迭代对象。例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item of items&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;item.done&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，当数据更新时，Vue会按照索引比较两次虚拟DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a1   a1</span><br><span class="line">a2   a3</span><br><span class="line">a3   a4</span><br><span class="line">a4</span><br><span class="line">变成</span><br><span class="line">a1   a1 ---- 相同，不修改</span><br><span class="line">a2   a3 ---- 不同，a2改成a3</span><br><span class="line">a3   a4 ---- 不同，a3改成a4</span><br><span class="line">a4      ---- 不同，删除a4</span><br><span class="line">可以在浏览器的DOM中看到闪烁的被修改内容</span><br></pre></td></tr></table></figure>
<p>这种按照索引的比较效率较低，可以在使用<code>v-for</code>指令的同时，使用<code>v-bind:key</code>为每个渲染的元素提供一个<code>key</code>属性。在具有<code>key</code>属性的情况下，两次虚拟DOM的比较会按照这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a1[key&#x3D;1]  a1[key&#x3D;1]</span><br><span class="line">a2[key&#x3D;2]  a3[key&#x3D;3]</span><br><span class="line">a3[key&#x3D;3]  a4[key&#x3D;4]</span><br><span class="line">a4[key&#x3D;4]</span><br><span class="line">变成，key相同的才对比</span><br><span class="line">a1   a1 ---- 相同，不修改</span><br><span class="line">a2      ---- 未找到相同的key，删除</span><br><span class="line">a3   a3 ---- 相同，不修改</span><br><span class="line">a4   a4 ---- 相同，不修改</span><br></pre></td></tr></table></figure>
<p>注意对每个相同元素，key不应该变化，因此不要用每次循环生成的索引，否则数据变化时key也会变化，这就导致了和不用key一样的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a1[key&#x3D;1]  a1[key&#x3D;1]</span><br><span class="line">a2[key&#x3D;2]  a3[key&#x3D;2]</span><br><span class="line">a3[key&#x3D;3]  a4[key&#x3D;3]</span><br><span class="line">a4[key&#x3D;4]</span><br><span class="line">变成</span><br><span class="line">a1   a1 ---- 相同，不修改</span><br><span class="line">a2   a3 ---- 不同，a2改成a3</span><br><span class="line">a3   a4 ---- 不同，a3改成a4</span><br><span class="line">a4      ---- 不同，删除a4</span><br></pre></td></tr></table></figure>
<p>当调用以下数组方法时，视图会更新：<br />
push()<br />
pop()<br />
shift()<br />
unshift()<br />
splice()<br />
sort()<br />
reverse()<br />
当调用<br />
filter()、concat() 和 slice()<br />
时，将数组方法如<code>filter</code>等返回的新数组赋值给原数组引用，Vue可以智能检测到这些经过处理的数组元素与上一次渲染所对应的元素。因此这种情况下没有key也可以</p>
<p>利用计算属性和循环指令，可以方便的基于一个经过处理的数组来渲染元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in evenNumbers&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line"><span class="javascript">    evenNumbers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81">风格指南</a>，不推荐<code>v-if</code>和<code>v-for</code>在一个元素上同时使用。<br />
如果一定要同时使用，注意先执行<code>v-for</code>，然后在迭代的每个元素上执行<code>v-if</code>以确定是否渲染。如果想条件性的执行循环，只能把<code>v-if</code>放到<code>v-for</code>的外层元素上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="事件绑定"><a class="markdownIt-Anchor" href="#事件绑定"></a> 事件绑定</h3>
<p>事件绑定指令<code>v-on</code>是将JavaScript代码与一个HTML元素上触发的事件进行绑定，每当事件触发时，都会执行相应的代码。</p>
<p>事件绑定指令有两类语法：</p>
<ul>
<li><code>v-on:事件名=&quot;JS代码/函数名/函数调用&quot;</code>，这种语法用于为指定的事件设置监听器，其中<code>v-on</code>也可以省略，写为<code>@事件名=&quot;JS代码/函数名/函数调用&quot;</code>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">eventname</span>]=<span class="string">&quot;doSomething($event)&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引号内的代码多数情况下（只有一种情况例外）会被封装成一个名为<code>handler</code>的函数表达式，当事件触发会实际调用的是<code>handler.apply(context, args)</code>，其中<code>args</code>是Arguments参数对象，也是一个类数组对象，它的整数索引对应着所有参数：<br />
若事件是一个原生事件（如<code>click</code>、<code>keydown</code>），则参数对象<code>args</code>只有一个元素，就是原生事件对象；<br />
若事件是一个用户通过<code>$emit(eventName, ...params)</code>派发的事件，则参数对象<code>args</code>的元素是<code>$emit</code>从第二个参数开始的所有参数。<br />
从引号内的代码得到<code>handler</code>的机制如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @事件名=&quot;JS代码&quot;</span></span><br><span class="line">handler = <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 其他预处理逻辑，例如修饰符等</span></span><br><span class="line">  JS代码</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @事件名=&quot;函数名&quot;</span></span><br><span class="line"><span class="comment">//   若是原生事件</span></span><br><span class="line">handler = <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 其他预处理逻辑，例如修饰符等</span></span><br><span class="line">  <span class="keyword">return</span> 函数名($event);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//   若是用户$emit派发的事件</span></span><br><span class="line">handler = 函数名;</span><br><span class="line"><span class="comment">// @事件名=&quot;函数调用&quot;</span></span><br><span class="line">handler = <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 其他预处理逻辑，例如修饰符等</span></span><br><span class="line">  <span class="keyword">return</span> 函数调用;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有使用<code>@事件名=&quot;函数名&quot;</code>语法，并且事件是由<code>$emit</code>派发的，处理函数才会被直接调用而不是被封装，因此只有这种形式可以通过命名参数来接受<code>$emit</code>的多个参数。<br />
其他情况处理函数都被进行了封装，封装后的<code>handler</code>只有一个命名参数<code>$event</code>来接受第一个参数。如果你想在<code>handler</code>内使用其他未命名的参数，需要通过<code>arguments</code>关键字来得到。<br />
另外，在封装的<code>handler</code>函数内可以直接访问数据属性，而在你的函数内只能通过<code>this</code>访问数据属性。</p>
<ul>
<li><code>v-on=&quot;对象表达式&quot;</code>，这种语法用于同时设置多个事件名与监听器的关联。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123;click: foo, dblclick: function(e)&#123; &#125;&#125;&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;foo&quot;</span> @<span class="attr">dblclick</span>=<span class="string">&quot;上面那个函数对象&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该对象的属性键必须是事件名，属性值则必须是一个函数对象（有<code>apply</code>方法）<br />
这种写法的的<code>handler</code>就是属性值所对应的函数对象。</p>
<h4 id="修饰符"><a class="markdownIt-Anchor" href="#修饰符"></a> 修饰符</h4>
<p>事件修饰符用于为事件处理程序添加一些Vue预定义的操作，它免去了用户自己在事件处理程序中去写这些常用操作的麻烦。<br />
事件修饰符的语法是以<code>.</code>开头的名字，并且必须紧跟在作为参数的事件名后面。<br />
可以使用多个事件修饰符，以便为事件处理程序添加多个预定义操作，多个事件修饰符的定义顺序也是这些预定义操作的执行顺序。例如<code>v-on:click.prevent.self</code>会阻止所有的点击，而<code>v-on:click.self.prevent</code>只会阻止对元素自身的点击。</p>
<p><code>.stop</code>：阻止事件传播<br />
<code>.prevent</code>：阻止默认行为<br />
<code>.capture</code>：捕获后代元素的事件，先再此处理，再交给后代元素处理。<br />
<code>.self</code>：只在事件由此元素触发时（不是冒泡来的）才处理。<br />
<code>.once</code>：事件处理只执行一次。<br />
<code>.passive</code>：立即触发默认行为，即<code>addEventListener</code>的<code>passive</code>选项。不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你不想阻止事件的默认行为。<br />
<code>.native</code>：用于监听组件根元素的原生事件，相当于直接写在组件根元素上的事件绑定指令。<code>$emit</code>出的非原生事件会被忽略。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="键盘事件修饰符"><a class="markdownIt-Anchor" href="#键盘事件修饰符"></a> 键盘事件修饰符</h5>
<p>对于键盘事件，按键修饰符可以用来检查哪个按键触发了事件。<br />
按键修饰符的语法是点号<code>.</code>后跟<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">KeyboardEvent.key</a>中提供的按键名（驼峰命名要转换为连字符命名）。<br />
也可以通过<code>Vue.config.keyCodes</code>来（用指定的keyCode）自定义按键名，例如<code>Vue.config.keyCodes.f1 = 112</code>。</p>
<p>除了使用按键名，还可以使用按键码对应的数字（由于旧浏览器中一些键位的按键码与现在有所不同，因此能使用按键名就不要使用按键码）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="鼠标事件修饰符"><a class="markdownIt-Anchor" href="#鼠标事件修饰符"></a> 鼠标事件修饰符</h5>
<p>类似的，对于鼠标事件，按键修饰符可以用来检查哪个鼠标按键触发了事件。<br />
总共有三个鼠标事件修饰符：</p>
<p><code>.left</code>：鼠标左键<br />
<code>.right</code>：鼠标右键<br />
<code>.middle</code>：鼠标中键</p>
<h5 id="系统键修饰符"><a class="markdownIt-Anchor" href="#系统键修饰符"></a> 系统键修饰符</h5>
<p>系统键修饰符可以用于鼠标事件和键盘事件，只有当按下特定的系统键时才会执行事件处理程序。系统键修饰符包括：<br />
<code>.ctrl</code>：Ctrl键<br />
<code>.alt</code>：Alt键<br />
<code>.shift</code>：Shift键<br />
<code>.meta</code>：Meta键<br />
<code>.exact</code>：表示前面指定的系统键是精确的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.alt.67</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，在用于<code>keyup</code>事件时，事件触发时系统键必须处于按下状态。例如<code>keyup.ctrl</code>只有在按住 ctrl 的情况下释放其它按键，才能触发。而单单释放 ctrl 也不会触发事件。<br />
<code>.exact</code>表示，只有在前面的系统键被按下时才触发，任何额外的系统键都将不触发事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="双向数据绑定"><a class="markdownIt-Anchor" href="#双向数据绑定"></a> 双向数据绑定</h3>
<p>双向数据绑定指令<code>v-model</code>将组件（控件）内部的某个值与Vue实例中的数据属性进行绑定，当组件内部的值发生变化时，数据属性也会变化，当数据属性变化时，组件内部的值也会随之变化。<br />
使用了<code>v-model</code>指令的元素会将它绑定的数据属性作为初始值，而不管<code>value</code>等属性中预定义的值。</p>
<p><code>v-model</code>指令实际上是<code>v-bind</code>和<code>v-on</code>两条指令的缩写。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;msg&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;a = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>数据更新的流向是：<code>$emit -&gt; v-on -&gt; data -&gt; v-bind</code><br />
组件（控件）内部派发了一个事件和新值（但没有更新值），外部监听到了事件并将新值赋予数据属性，由于数据属性变成了新值，又作为绑定的参数被回传给了组件（控件）。</p>
<p>双向数据绑定指令的基本语法是：<code>v-model=&quot;数据属性名&quot;</code><br />
原生元素（组件）<code>v-model=&quot;a&quot;</code>指令等价于<code>v-bind:value=&quot;a&quot;</code>和<code>@input=&quot;a = $event.target.value&quot;</code><br />
自定义元素（组件）<code>v-model=&quot;a&quot;</code>指令等价于<code>v-bind:value=&quot;a&quot;</code>和<code>@input=&quot;a = $event&quot;</code></p>
<p>对于不同的表单控件元素，<code>v-model</code>监听的属性和事件不同：</p>
<ul>
<li><code>text</code> 和 <code>textarea</code> 元素： <code>value</code>属性，根据<code>input</code>、<code>compositionstart</code>和<code>compositionend</code>事件的触发修改绑定值（使用输入法过程中不会修改绑定值）。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在textarea元素内&#123;&#123;text&#125;&#125;插值无效 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用v-model代替 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>radio</code>元素：<code>value</code>属性（如果没有<code>value</code>属性则是<code>null</code>）。当选中时修改绑定值（<code>change</code>事件触发）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedRadio&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当选中时数据属性pick和a相等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pick&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>checkbox</code> 元素：若绑定的不是数组，则是<code>checked</code>属性（布尔值<code>true</code>或<code>false</code>），也可以是<code>true-value</code>属性和<code>false-value</code>属性所设置的值。若绑定的是数组，则被选中时<code>value</code>属性值（若没有则是<code>null</code>）被添加到数组中，未被选中时<code>value</code>值（若没有则是<code>null</code>）被从数组中移除，注意多个无<code>value</code>属性的多选框会共用一个<code>null</code>。当<code>change</code>事件触发时修改绑定值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedVal&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 选中时值为true-value，而不是checked属性的true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;toggle&quot;</span> <span class="attr">true-value</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">false-value</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多个复选框绑定到数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jack&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>select</code>元素：其子元素<code>&lt;option&gt;</code>的<code>value</code>属性（如无则取自元素文本），当<code>change</code>事件触发时修改绑定值。多选时绑定一个数组，被选中的元素的<code>value</code>将作为数组元素。如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，推荐将第一个<code>&lt;option&gt;</code>设为<code>disabled</code>并将<code>value</code>设为数据属性的值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定select --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-5&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;&#123; number: 123 &#125;&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="修饰符-2"><a class="markdownIt-Anchor" href="#修饰符-2"></a> 修饰符</h4>
<p><code>v-model</code>对于<code>input</code>还有三个修饰符：</p>
<ul>
<li><code>.lazy</code>：监听<code>change</code>事件而不是<code>input</code>事件</li>
<li><code>.number</code>：自动将值使用<code>parseFloat()</code>解析，如果解析出的不是数字，则返回原值。</li>
<li><code>.trim</code>：自动过滤值的首尾空白符。</li>
</ul>
<h3 id="自定义指令"><a class="markdownIt-Anchor" href="#自定义指令"></a> 自定义指令</h3>
<p>除了上述已有的指令外，还可以自定义新的指令：<br />
通过<code>Vue.directive(directiveName, directiveOption)</code>可以全局定义指令。自定义指令的名字<code>directiveName</code>中不加前缀<code>v-</code>，但使用指令时，仍然要加上<code>v-</code>前缀。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过组件选项的<code>directives</code>属性可以局部定义指令，<code>directives</code>是一个对象，它的属性键是指令的名字<code>directiveName</code>，属性值是一个指令定义对象<code>directiveOption</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    focus: &#123;</span><br><span class="line">      inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">        el.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指令定义对象<code>directiveOption</code>中是若干个可选的钩子函数，用于说明指令所完成的操作以及在何时运行：</p>
<ul>
<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。</li>
<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li>
<li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>
</ul>
<p>每个钩子函数都具有四个参数<code>(el, binding, vnode, oldVnode)</code>，其含义如下：</p>
<ul>
<li><code>el</code>是指令所绑定的元素。</li>
<li><code>binding</code>是一个对象，具有下列属性：
<ul>
<li><code>name</code>：不包括<code>v-</code>前缀的指令名</li>
<li><code>value</code>：指令的绑定值，例如<code>v-my-directive=&quot;1 + 1&quot;</code>中绑定值为<code>2</code>；<code>v-demo=&quot;&#123; color: 'white', text: 'hello!' &#125;&quot;</code>中绑定值为该对象，可以通过<code>value.color</code>访问对象中的值。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在<code>update</code>和<code>componentUpdated</code>钩子函数中可用。</li>
<li><code>expression</code>：字符串形式的指令表达式，例如<code>v-my-directive=&quot;1 + 1&quot;</code>中表达式为<code>&quot;1 + 1&quot;</code></li>
<li><code>arg</code>：传给指令的参数，例如<code>v-my-directive:foo</code>中参数为<code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象，例如<code>v-my-directive.foo.bar</code>中修饰符对象为<code>&#123; foo: true, bar: true &#125;</code></li>
</ul>
</li>
<li><code>vnode</code>：Vue编译生成的虚拟DOM。</li>
<li><code>oldVnode</code>：上一次的虚拟DOM。</li>
</ul>
<p>除了<code>el</code>外，其他参数都应该是只读的，不要进行修改。如果要在钩子函数之间共享数据，应该将数据作为<code>data-*</code>属性写在元素上，然后通过<code>el.dataset</code>读取。</p>
<p>如果你想将<code>bind</code>和<code>update</code>对应的钩子函数设为相同的，忽略所有其他钩子函数，那么自定义指令也可以进行简写，将指令定义对象改成钩子函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;color-swatch&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.backgroundColor = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="vue组件"><a class="markdownIt-Anchor" href="#vue组件"></a> Vue组件</h1>
<p>现代框架的核心功能之一，就是自定义特定功能的HTML元素，就像HTML5提供的用于播放视频的<code>&lt;video&gt;</code>一样。<br />
例如我们设计了一个名为<code>button-counter</code>的HTML元素，它是一个按钮，在点击后按钮上面的数字会递增，那么在使用时，就会是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">init-val</span>=<span class="string">&quot;5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要定义一个Vue组件，有全局注册和局部注册两种方法：<br />
全局注册使用<code>Vue.component(tagName, option)</code>函数来进行，定义之后任何通过<code>new Vue()</code>创建的Vue实例都可以使用，第一个参数是自定义元素的标签名，第二个参数是该组件的选项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;count++&quot;&gt;</span></span><br><span class="line"><span class="string">      You clicked me &#123;&#123; count &#125;&#125; times.</span></span><br><span class="line"><span class="string">    &lt;/button&gt;`</span>,</span><br><span class="line">  props: [<span class="string">&#x27;initVal&#x27;</span>],</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>局部注册是将组件写成一个对象，然后在使用该组件的实例（或组件）选项中通过<code>components</code>选项来指明要使用此组件，以及要赋予被使用的组件的名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* options */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* options */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="关于组件名"><a class="markdownIt-Anchor" href="#关于组件名"></a> 关于组件名</h2>
<p>组件本身不包含名字，使用组件的人可以给一个组件赋予任意的名字。<br />
组件的名字建议全部小写，并且用连字符分隔（kebab-case风格）。因为这种风格的组件名不管模板书写在哪里都可以正常使用。<br />
另一种组件命名风格是首字母大写的驼峰（PascalCase风格），这种风格的组件名不能直接写在DOM中，因为浏览器会将元素标签名小写。这种风格的组件名同时具有一个kebab-case风格的别名，可以在DOM中使用这个别名。</p>
<h2 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h2>
<p>组件的模板通常在组件选项的<code>template</code>属性中提供。<br />
在单文件组件中，组件的模板会写在<code>&lt;template&gt;</code>元素内。<br />
还有一种办法是写在<code>&lt;script&gt;</code>元素内，将<code>type</code>设为<code>text/x-template</code>，并且为元素设置一个<code>id</code>属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hello-world-template&quot;</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在组件选项中，<code>template</code>部分书写一个井号，外加<code>id</code>属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;hello-world&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;#hello-world-template&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="内联模板"><a class="markdownIt-Anchor" href="#内联模板"></a> 内联模板</h3>
<p>内联模板用于在使用组件时，覆盖组件自己定义的模板。<br />
通常，在使用组件时，如果在组件的开始标签和结束标签放置内容，这部分内容会替换组件的<code>&lt;slot&gt;</code>插槽元素，如果没有<code>&lt;slot&gt;</code>则会简单的抛弃。<br />
但如果在使用组件时，为组件元素添加了<code>inline-template</code>属性，则在组件开始标签和结束标签之间的内容，会被当成此组件的模板，而不是插槽。此时这部分内容会覆盖组件原本的模板。<br />
如果组件没有提供模板，通常是无法使用的，但通过内联模板，你仍然可以正常使用该组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseLayout = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123;msg&#125;&#125; 123&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#container&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    baseLayout</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;base-layout inline-template&gt;</span></span><br><span class="line"><span class="string">      &lt;section&gt;&#123;&#123;msg&#125;&#125; 456&lt;/section&gt;</span></span><br><span class="line"><span class="string">    &lt;/base-layout&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="选项-2"><a class="markdownIt-Anchor" href="#选项-2"></a> 选项</h2>
<p>选项类似于创建Vue实例时的选项，但也有一些区别。</p>
<h3 id="内部组件名"><a class="markdownIt-Anchor" href="#内部组件名"></a> 内部组件名</h3>
<p><code>name</code>选项用于给本组件设置一个内部使用的名字，以便递归使用自己。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  name: <span class="string">&quot;curComponent&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用其他组件"><a class="markdownIt-Anchor" href="#引用其他组件"></a> 引用其他组件</h3>
<p><code>components</code>选项用于指定本组件要使用的其他组件。<br />
<code>components</code>是一个对象，属性键是为被使用的组件赋予的本地名字，属性值是被使用的组件的选项对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TodoInput <span class="keyword">from</span> <span class="string">&quot;./TodoInput&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">&quot;./TodoList&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> TodoStatus <span class="keyword">from</span> <span class="string">&quot;./TodoStatus&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    renameTodoInput: TodoInput,</span><br><span class="line">    renameTodoList: TodoList,</span><br><span class="line">    renameTodoStatus: TodoStatus</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据属性-2"><a class="markdownIt-Anchor" href="#数据属性-2"></a> 数据属性</h3>
<p><code>data</code>选项需要是一个函数而不是一个对象，该函数返回的才是数据对象。因为一个自定义HTML元素可能被使用很多次，每个相同类型的自定义元素彼此的数据应该是没有任何关联的，一个组件内的计数器不应该受另一个组件内的计数器的影响。因此<code>data</code>必须是一个函数，以保证创建自定义元素时，其数据属性对象都是全新的。尽量不要定义为箭头函数，如果非要定义可以接受一个Vue实例参数<code>vm</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      leftNum: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="html属性-2"><a class="markdownIt-Anchor" href="#html属性-2"></a> HTML属性</h3>
<p>组件能够接受外部参数来进行初始化等操作，由于组件表现为一个自定义的HTML元素，为组件传递参数的语法，就是为HTML元素添加属性，例如<code>&lt;button-counter init=&quot;5&quot;&gt;&lt;/button-counter&gt;</code>。</p>
<p><code>props</code>选项用于定义它接受哪些HTML属性作为其参数，接受的参数地位等同于数据属性。</p>
<p><code>props</code>可以是一个字符串数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option1 = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>, <span class="string">&#x27;isPublished&#x27;</span>, <span class="string">&#x27;commentIds&#x27;</span>, <span class="string">&#x27;author&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>props</code>也可以是一个对象。<br />
当是一个对象时，属性键是参数的名字，属性值可以是一个构造函数、一个数组或一个对象， 用于指明此参数的类型，指明的类型提供了基础的验证，但是<code>null</code>和<code>undefined</code>会通过任何类型的验证，验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。如果希望允许任何类型，就将属性值写为对象，但不提供<code>type</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option2 = &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].indexOf(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多个类型</span></span><br><span class="line">    likes: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    isPublished: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    commentIds: <span class="built_in">Array</span>,</span><br><span class="line">    any: &#123;</span><br><span class="line">      <span class="comment">// 任何类型均可</span></span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    author: &#123;</span><br><span class="line">        type: <span class="built_in">Object</span>,</span><br><span class="line">        <span class="comment">// 若默认值是对象/数组，则必须通过函数返回</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    callback: <span class="built_in">Function</span>,</span><br><span class="line">    contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在使用时，如果不通过<code>v-bind</code>指令，则属性遵守的HTML规则，属性值会被当做字符串（不写属性值时是布尔值<code>true</code>）。如果想传递字符串以外的类型，就需要用<code>v-bind</code>语法。</p>
<p>如果传递的参数是一个变量，则这个变量是父组件的属性，这就构成了单向下行绑定：父组件对数据属性的更新，会通过参数传递到子组件上。但反之不行（对象和数组等引用类型例外）。<br />
每当父组件发生变更时，子组件中的属性都会更新。</p>
<p>建议：子组件中不要修改传递的参数，如果要修改，基于它创建数据属性或计算属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;initialCounter&#x27;</span>, <span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性继承"><a class="markdownIt-Anchor" href="#属性继承"></a> 属性继承</h3>
<p>写在HTML元素上的属性，如果没有定义为<code>props</code>中的参数，则这些属性将作为组件根元素的HTML属性，而不是作为组件的参数。<br />
这样的属性称之为继承的属性，如果属性名冲突，则继承的属性会覆盖组件作者在根元素上设置的属性。只有<code>class</code>和<code>style</code>属性例外，<code>class</code>和<code>style</code>会和手动设置的属性合并，而不是覆盖。<br />
如果你想继承属性，则不需要进行任何设置。<br />
如果不想继承属性，使用<code>inheritAttrs: false</code>选项（但<code>class</code>和<code>style</code>属性不受影响）。设置不继承仅仅是使得属性不再覆盖，如果你仍然希望访问那些继承属性，可以通过<code>vm.$attrs</code>对象，它是继承的属性名到属性值的映射（不包括<code>class</code>和<code>style</code>）。这使你可以手动设置这些属性要被用在组件内的哪个元素上，而不是默认用在根元素上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承属性不用在根元素上，而是用来input元素上</span></span><br><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="双向绑定指令"><a class="markdownIt-Anchor" href="#双向绑定指令"></a> 双向绑定指令</h3>
<p>组件表现为一个HTML元素，在其上可以使用<code>v-model</code>指令。默认情况下，<code>v-model=&quot;val&quot;</code>指令的作用是监听组件的<code>input</code>事件，然后更新变量<code>val</code>，同时将组件的<code>value</code>属性（需要是HTML属性，因为是作为HTML属性添加的）与变量<code>val</code>进行绑定。<br />
<code>model</code>选项可以让组件作者改变<code>v-model</code>指令监听的事件，以及要绑定的组件属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-input&#x27;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">    event: <span class="string">&quot;input&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="访问祖先组件数据"><a class="markdownIt-Anchor" href="#访问祖先组件数据"></a> 访问祖先组件数据</h3>
<p>组件的内置属性<code>$parent</code>可以访问到父组件的实例，但如果组件嵌套了很多层，想访问祖先组件的数据就必须<code>this.$parent.$parent.$parent...</code>，难以书写和维护。<br />
<code>provide</code>和<code>inject</code>选项配合可以实现跨层级访问祖先数据。这也称为<strong>依赖注入</strong>。<br />
要注意的是，依赖注入的属性并不是自动可响应的，除非你传入的就是一个已被监听的对象。</p>
<p>在祖先组件中，使用<code>provide</code>选项指定要提供给后代组件的数据或方法，<code>provide</code>可以是一个对象，也可以是一个返回对象的方法。对象的属性名是提供给后代的数据或方法名，属性值则是对当前组件中的数据或方法的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    getMap: <span class="built_in">this</span>.getMap,</span><br><span class="line">    longitude: <span class="built_in">this</span>.longitude</span><br><span class="line">  &#125;,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      map: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      longitude: <span class="number">120.4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">getMap</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.map;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后代组件中，使用<code>inject</code>选项指定要接收的祖先组件提供的数据或方法名，<code>inject</code>可以是一个字符串数组，也可以是一个对象。如果是对象，则属性键是后代组件给接受的数据重新起的名字。属性值可以是祖先组件<code>provide</code>选项中的名字，也可以是一个有<code>from</code>和<code>default</code>属性的对象。<code>from</code>是是祖先组件<code>provide</code>选项中的名字（省略时表示和属性键同名），<code>default</code>是不存在该属性的情况下使用的默认值，和<code>props</code>中的默认值一样，如果不是原始值则<code>default</code>应该是一个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option1 = &#123;</span><br><span class="line">  inject: [<span class="string">&#x27;getMap&#x27;</span>, <span class="string">&#x27;longitude&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> option2 = &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    localMap: <span class="string">&#x27;getMap&#x27;</span>,</span><br><span class="line">    localLongitude: &#123;</span><br><span class="line">      <span class="keyword">from</span>: <span class="string">&#x27;longitude&#x27;</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    foo: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="function">() =&gt;</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖注入类似于<code>props</code>，只是后代组件不知道被注入的属性来自哪里（<code>props</code>可以断言来自<code>$parent</code>）。</p>
<h3 id="混入其他选项"><a class="markdownIt-Anchor" href="#混入其他选项"></a> 混入其他选项</h3>
<p><code>mixins</code>属性可以将一个选项对象和当前选项对象合并。<br />
<code>mixins</code>是一个数组，它的每个元素是要被混入的选项对象。<br />
<code>data</code>、<code>methods</code>、<code>components</code>、<code>directives</code>都会被合并，同名属性的情况当前选项对象优先。<br />
钩子函数则都会被调用，但被混入的选项对象先调用，然后再调用当前选项对象的钩子函数。</p>
<h3 id="函数式组件"><a class="markdownIt-Anchor" href="#函数式组件"></a> 函数式组件</h3>
<p><code>functional</code>属性是一个布尔值，用于表示此组件是无状态（没有<code>data</code>）和无实例的（没有<code>this</code>上下文）。这类组件会用一个简单的 render 函数返回虚拟节点使它们渲染的代价更小。</p>
<h3 id="过滤器"><a class="markdownIt-Anchor" href="#过滤器"></a> 过滤器</h3>
<p><code>filters</code>属性用于定义过滤器函数，<code>filters</code>是一个对象，其属性键值过滤器名，属性值是接受参数并返回的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h2>
<h3 id="组件向外传递"><a class="markdownIt-Anchor" href="#组件向外传递"></a> 组件向外传递</h3>
<p>组件是一个独立的整体，它向外部传递信息使用的是事件机制。<br />
使用组件的人监听组件元素的事件，进行相应的处理即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-counter</span> @<span class="attr">click</span>=<span class="string">&quot;do()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>组件内部要派发一个事件，需要使用<code>$emit(eventName, ...args)</code>函数，第一个参数<code>eventName</code>是事件名称，之后所有的参数是随此事件一起传递的数据。</p>
<p>外部要监听的事件名必须完全匹配<code>eventName</code>，不同的命名风格没有用。</p>
<h3 id="外部向组件传递"><a class="markdownIt-Anchor" href="#外部向组件传递"></a> 外部向组件传递</h3>
<p>外部向组件传递信息使用的是HTML属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">:counter</span>=<span class="string">&quot;initCounter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>组件内部要接收传递的信息，使用使用<code>props</code>选项。</p>
<h2 id="双向数据绑定-2"><a class="markdownIt-Anchor" href="#双向数据绑定-2"></a> 双向数据绑定</h2>
<p>双向数据绑定是很常见的需求，当组件内部的值发生变化时，本地数据属性也随之变化。当本地数据属性发生变化时，组件内部的值也要变化。<br />
要实现这个效果，可以使用<code>v-bind</code>和<code>v-on</code>，使得数据按以下方式流动和更新：<br />
<code>$emit -&gt; v-on -&gt; data -&gt; v-bind</code><br />
组件内部使用<code>$emit</code>派发事件并传递新值，组件外部使用<code>v-on</code>监听事件并更新数据属性，组件外部通过<code>v-bind</code>指令将数据属性的值作为组件参数传回组件。<br />
例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;counter&quot;</span> <span class="attr">v-on:update:value</span>=<span class="string">&quot;counter = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="修饰符简写"><a class="markdownIt-Anchor" href="#修饰符简写"></a> 修饰符简写</h3>
<p>注：仅用于自定义组件，不能用于原生HTML控件。<br />
Vue提供了这两条指令的简写：在<code>v-bind</code>指令后使用<code>.sync</code>修饰符（引号内只能是数据属性的名字不能是表达式）。<br />
同时约定组件内<code>$emit</code>派发的事件名为<code>update:组件参数名</code>，这样Vue就会自动生成<code>v-on:update:组件参数名</code>指令，省去了我们自己书写<code>v-on</code>指令的麻烦。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-bind:value.sync</span>=<span class="string">&quot;counter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果想同时设置多个双向绑定，还可以直接用<code>v-bind.sync=&quot;对象&quot;</code>（注意不能是对象字面值），每个属性键都作为组件参数，每个属性值都是一个数据属性。</p>
<h3 id="v-model指令"><a class="markdownIt-Anchor" href="#v-model指令"></a> v-model指令</h3>
<p>另一种简写是使用<code>v-model</code>指令，同时在选项中指明组件派发的事件名，以及所绑定的组件参数。默认情况下，事件名约定为<code>input</code>，绑定的参数约定为<code>value</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;a = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-input</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>v-model</code>和<code>v-bind.sync</code>修饰符的区别在于：<br />
修饰符简写只能用于自定义组件，<code>v-model</code>指令不仅可以用于自定义组件，还可以用于原生HTML控件。<br />
修饰符简写可以设置多个双向绑定。<code>v-model</code>指令简写只能设置一个双向绑定；<br />
修饰符简写的事件名有固定的格式，必须是<code>v-bind</code>的参数，即一个组件参数名。<code>v-model</code>指令简写的事件名默认是<code>input</code>，但在选项中也可以修改成任意的。</p>
<h2 id="插槽"><a class="markdownIt-Anchor" href="#插槽"></a> 插槽</h2>
<p>自定义组件都不是自闭合标签，因此因此在使用时可以在中间放置内容。<br />
默认情况下，组件开始标签与结束标签之间的内容会被抛弃。但如果组件内部使用了<code>&lt;slot&gt;</code>占位符，则这部分内容会替换占位符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;默认值&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;text&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="默认值"><a class="markdownIt-Anchor" href="#默认值"></a> 默认值</h3>
<p><code>&lt;slot&gt;&lt;/slot&gt;</code>占位符中间可以书写内容作为默认值，如果使用组件时没有在中间放置内容，就会渲染默认值。如果使用组件时放置了内容，则会忽略默认值。</p>
<h3 id="命名插槽"><a class="markdownIt-Anchor" href="#命名插槽"></a> 命名插槽</h3>
<p>每个插槽都一个名字，名字使用<code>name</code>属性表示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>没有提供<code>name</code>属性等价于<code>name=&quot;default&quot;</code>。<br />
在使用组件时，可以通过<code>&lt;template&gt;</code>元素以及<code>v-slot</code>指令来指明这部分内容是提供给哪个插槽的。<br />
基本语法是<code>&lt;template v-slot:插槽名&gt;</code>，也可以简写为<code>&lt;template #插槽名&gt;</code>。已</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    放置在header插槽的内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>adasdas<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所有没有被放置在<code>&lt;template v-slot:插槽名&gt;</code>内的内容，都会被隐式的放到<code>&lt;template v-slot:default&gt;</code>插槽里。</p>
<p>还有两种已废弃的语法，可能出现在旧版本的Vue代码中：</p>
<ul>
<li>使用组件时通过<code>slot</code>属性而不是<code>v-slot</code>指令指明插槽，即<code>&lt;tempalte slot=&quot;插槽名&quot;&gt;</code></li>
<li>不使用<code>&lt;template&gt;</code>而直接将<code>slot</code>属性写在普通元素上，该元素就会替换特定名称的<code>&lt;slot&gt;</code>占位符。</li>
</ul>
<h3 id="可访问的属性"><a class="markdownIt-Anchor" href="#可访问的属性"></a> 可访问的属性</h3>
<p>默认情况下，使用组件时组件标签之间这部分内容是先被编译完成后，再被放入组件的<code>&lt;slot&gt;</code>中的，因此插值等语法只能访问使用组件时的作用域，而无法访问到组件内部的数据。例如下面的例子中，组件内部属性的<code>myVal</code>是无法访问到的，只能访问使用组件时的Vue实例或父组件的属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  &#123;&#123; myVal &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但组件作者也可以主动将一些属性提供给插槽使用者，使得在使用组件时能够访问组件内部的数据。只要在<code>&lt;slot&gt;</code>上定义HTML属性即可，既可以是普通的HTML属性，也可以是使用<code>v-bind</code>绑定的属性，这些属性都能够被插槽使用者所使用。插槽上的HTML属性也简称为插槽属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-layout&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="string">&quot;qwer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;slot name=&quot;header&quot; foo=&quot;abcd&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">      &lt;slot name=&quot;footer&quot; :foo=&quot;value&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>组件使用者要想使用组件作者提供的属性，必须使用<code>&lt;template&gt;</code>和<code>v-slot</code>指令，同时还要设置一个名称用来引用属性对象。这种添加属性，并通过赋予对象名称来使用的插槽，称为作用域插槽。<br />
基本语法为：<code>&lt;template v-solt:插槽名=&quot;对象名称&quot;&gt;</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;vvv&quot;</span>&gt;</span></span><br><span class="line">      测试 &#123;&#123; vvv.foo &#125;&#125; 测试</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>工作原理是将插槽内容包裹在一个拥有单个参数的函数里，调用该函数时，会传递一个包含各插槽属性的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">对象名称</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相同作用域内，插槽属性会遮盖同名的数据属性。例如上例中，即便 Vue实例有一个名为<code>vvv</code>的数据属性，在<code>&lt;template&gt;</code>中也只能访问到插槽属性对象。</p>
<p>由于<code>对象名称</code>这部分会被原封不动的作为函数参数，因此也可以在这里书写一个解构绑定，例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;&#123; time &#125;&quot;</span>&gt;</span></span><br><span class="line">    测试 &#123;&#123; time &#125;&#125; 测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果组件内没有命名插槽，只有<code>default</code>插槽，那么上述用法可以简写，不使用<code>&lt;template&gt;</code>而直接将<code>v-solt</code>放在组件元素上。更进一步，连<code>v-slot</code>的参数也可以省略（但是省略后不能使用<code>#</code>缩写，必须写为<code>#default</code>）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;vvv&quot;</span>&gt;</span></span><br><span class="line">    测试 &#123;&#123; vvv.time &#125;&#125; 测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-layout</span> <span class="attr">v-slot</span>=<span class="string">&quot;vvv&quot;</span>&gt;</span></span><br><span class="line">    测试 &#123;&#123; vvv.time &#125;&#125; 测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有两种已废弃的语法，可能出现在旧版本的Vue代码中：</p>
<ul>
<li>使用组件作者提供的属性时，使用<code>&lt;template slot=&quot;插槽名&quot; slot-scope=&quot;对象名称&quot;&gt;</code>而不是<code>&lt;template v-solt:插槽名=&quot;对象名称&quot;&gt;</code>。当插槽名为<code>default</code>时也可以省去<code>slot</code>属性。</li>
<li>不使用<code>&lt;template&gt;</code>而直接将<code>slot-scope</code>属性写在普通元素上。</li>
</ul>
<h3 id="动态插槽名"><a class="markdownIt-Anchor" href="#动态插槽名"></a> 动态插槽名</h3>
<p><code>v-slot</code>后的参数可以是一个中括号括起来的表达式，但不能有空格和引号。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="内置属性-2"><a class="markdownIt-Anchor" href="#内置属性-2"></a> 内置属性</h2>
<h3 id="事件监听器"><a class="markdownIt-Anchor" href="#事件监听器"></a> 事件监听器</h3>
<p>组件具有<code>$listeners</code>属性，它是一个对象，包含了外部设置在本组件上的所有（不包括<code>.native</code>的）事件监听器。其属性值键被监听的事件名，属性值为事件触发时的回调函数。<br />
通过该对象，组件内部可以通过<code>v-on</code>指令重新将监听器分配到组件内部合适的元素上。如果还有其他事件想要监听，可以通过<code>Object.assign</code>合并对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="built_in">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on=&quot;inputListeners&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="事件侦听方法"><a class="markdownIt-Anchor" href="#事件侦听方法"></a> 事件侦听方法</h3>
<p>对于一个事件，除了使用<code>v-on</code>指令进行监听外，还可以使用JavaScript的API进行监听：</p>
<ul>
<li><code>$on(eventName, handler)</code>：当触发<code>eventName</code>事件时执行<code>handler</code></li>
<li><code>$once(eventName, handler)</code>：仅当第一次<code>eventName</code>事件时执行<code>handler</code></li>
<li><code>$off(eventName, handler)</code>：取消<code>eventName</code>事件上的<code>handler</code>处理程序</li>
</ul>
<h3 id="继承属性"><a class="markdownIt-Anchor" href="#继承属性"></a> 继承属性</h3>
<p><code>$attrs</code>属性包括了组件上所有没有通过<code>props</code>选项接受的HTML属性（除了<code>class</code>和<code>style</code>）。它是一个对象，属性键是HTML属性名，属性值是HTML属性值。</p>
<h3 id="vue实例-2"><a class="markdownIt-Anchor" href="#vue实例-2"></a> Vue实例</h3>
<p>每个组件都属于某个<code>new Vue</code>出的实例，在组件内可以通过<code>$root</code>访问这个Vue实例，进而修改实例的属性值或调用相关方法。</p>
<h3 id="父组件实例"><a class="markdownIt-Anchor" href="#父组件实例"></a> 父组件实例</h3>
<p><code>$parent</code>属性可以访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据作为HTML参数传入子组件的方式。<br />
在绝大多数情况下，触达父级组件会使得你的应用更难调试和理解，尤其是当你变更了父级组件的数据的时候。当我们稍后回看那个组件的时候，很难找出那个变更是从哪里发起的。</p>
<h3 id="子组件实例"><a class="markdownIt-Anchor" href="#子组件实例"></a> 子组件实例</h3>
<p>如果想访问子组件的实例，可以使用<code>$refs</code>属性，它只在组件渲染完成之后生效。<br />
该属性需要配合子组件上的<code>ref</code>属性使用，<code>ref</code>的值是一个指代此组件的ID：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">&quot;usernameInput&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$refs.usernameInput</span><br></pre></td></tr></table></figure>
<p>当<code>ref</code>属性和<code>v-for</code>一起用在子组件上时，<code>$refs.子组件ID</code>得到的是子组件实例的数组。</p>
<h3 id="插槽内容"><a class="markdownIt-Anchor" href="#插槽内容"></a> 插槽内容</h3>
<p><code>$slots</code>对象包含每个非作用域插槽（<code>v-slot:插槽名</code>后没有引号内的<code>&quot;对象名称&quot;</code>）的内容，其属性键是插槽的名字（包括<code>default</code>），属性值是一个数组，数组元素是<code>VNode</code>节点对象。<br />
<code>$scopedSlots</code>对象包括所有插槽的内容，其属性键是插槽的名字（包括<code>default</code>），属性值是一个函数。该函数接受一个对象参数（该对象的属性键是作用域插槽中引用的变量名，属性值是变量对应的值，也就是说<code>v-slot:插槽名=&quot;对象名称&quot;</code>中的<code>对象名称</code>就是为此对象起的名字），基于传入的对象，返回一个数组，数组元素是<code>VNode</code>节点对象。<br />
<code>$slots</code>中的所有插槽都会出现在<code>$scopedSlots</code>中，因此使用后者是最可靠的。</p>
<h2 id="动态组件"><a class="markdownIt-Anchor" href="#动态组件"></a> 动态组件</h2>
<p>使用一个组件时，需要写明组件的HTML标签，但如果希望标签名是一个变量，而不是写死的字符串，就要用到动态组件。<br />
使用<code>&lt;component&gt;</code>标签，并为其<code>is</code>属性绑定变量。渲染时<code>&lt;component&gt;</code>标签会被渲染为<code>is</code>属性所指示的组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，每次修改<code>is</code>所绑定的变量，都会导致旧的组件被销毁，新的组件被创建。但有时我们希望旧的组件被缓存下来，如果下一次将<code>is</code>绑定的变量改回之前创建过的组件，该组件仍然能维持当时的状态，例如输入到一半的内容被保留而不是清空。<br />
要实现缓存，可以使用<code>&lt;keep-alive&gt;</code>元素将动态组件包裹起来。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意<code>&lt;keep-alive&gt;</code>要求被缓存组件有自己的名字，不论是通过组件的<code>name</code>选项还是局部/全局注册。</p>
<h2 id="异步组件"><a class="markdownIt-Anchor" href="#异步组件"></a> 异步组件</h2>
<p>组件的选项有时需要通过异步任务才能得到，要想在异步任务完成时才实例化组件，可以将选项参数改为工厂函数<code>function(resolve, reject)</code>，当异步任务完成时，调用<code>resolve(option)</code>来传入选项，或者使用<code>reject(reason)</code>来表示加载失败。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">&#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>工厂函数也可以返回一个Promise，其结果值是组件选项，例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 这个动态导入会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>工厂函数还可以返回一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">&#x27;./MyComponent.vue&#x27;</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="递归组件"><a class="markdownIt-Anchor" href="#递归组件"></a> 递归组件</h2>
<p>全局注册的组件，以及在选项中提供了<code>name</code>属性的组件，可以使用这个名字来在<code>template</code>中递归的使用组件本身。<br />
递归组件和编写递归函数是一样，必须有一个基线条件，使得最终一定能停止。否则会爆栈。组件中的基线条件可以使用一个最终能得到<code>false</code>的<code>v-if</code>指令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  name: <span class="string">&#x27;stack-overflow&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环引用"><a class="markdownIt-Anchor" href="#循环引用"></a> 循环引用</h2>
<p>两个组件之间有可能出现循环引用，如果是通过<code>Vue.component</code>全局注册的组件，则不会有任何问题。<br />
但如果是通过<code>component</code>选项局部注册组件，那么在导入另一个组件选项时就会出现问题。例如有两个组件：<br />
第一个<code>./treeFolder.vue</code>内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">&quot;folder.children&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> treeFolderContents <span class="keyword">from</span> <span class="string">&quot;./treeFolderContents&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;folder&#x27;</span>],</span></span><br><span class="line">  component: &#123;</span><br><span class="line">    treeFolderContents</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二个<code>./treeFolderContents.vue</code>内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;child in children&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">&quot;child.children&quot;</span> <span class="attr">:folder</span>=<span class="string">&quot;child&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span> &gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> treeFolder <span class="keyword">from</span> <span class="string">&quot;./treeFolder&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;children&#x27;</span>],</span></span><br><span class="line">  component: &#123;</span><br><span class="line">    treeFolder</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要解决这个问题，有两种办法：</p>
<ul>
<li>使用webpack的异步<code>import</code>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">&#x27;children&#x27;</span>],</span><br><span class="line">  component: &#123;</span><br><span class="line">    treeFolder: <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./treeFolder.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>或者不直接在选项中添加使用的组件，而是在生命周期钩子函数中添加：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$options.components.treeFolder = <span class="built_in">require</span>(<span class="string">&#x27;./treeFolder.vue&#x27;</span>).default</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="全局混入"><a class="markdownIt-Anchor" href="#全局混入"></a> 全局混入</h1>
<p>除了通过组件选项中的<code>mixins</code>来进行混入外，也可以通过<code>Vue.mixin(option)</code>来进行全局混入，这种方式会导致之后通过<code>new Vue</code>创建的每一个Vue实例都被混入了<code>option</code>选项对象。</p>
<h2 id="自定义混入策略"><a class="markdownIt-Anchor" href="#自定义混入策略"></a> 自定义混入策略</h2>
<p>通过添加或重写<code>Vue.config.optionMergeStrategies</code>对象上的函数，就可以自定义某个选项属性的混入策略，默认策略是覆盖。<br />
添加或重写的函数，其函数名是选项的属性，例如<code>data</code>和<code>computed</code>，函数接受两个参数。例如<code>Vue.config.optionMergeStrategies.methods</code>是目前针对<code>选项中的methods</code>属性使用的混入策略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = Vue.config.optionMergeStrategies.computed</span><br><span class="line">Vue.config.optionMergeStrategies.vuex = <span class="function"><span class="keyword">function</span> (<span class="params">toVal, fromVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回合并后的值</span></span><br><span class="line">  <span class="keyword">if</span> (!toVal) <span class="keyword">return</span> fromVal</span><br><span class="line">  <span class="keyword">if</span> (!fromVal) <span class="keyword">return</span> toVal</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getters: merge(toVal.getters, fromVal.getters),</span><br><span class="line">    state: merge(toVal.state, fromVal.state),</span><br><span class="line">    actions: merge(toVal.actions, fromVal.actions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="过渡动画"><a class="markdownIt-Anchor" href="#过渡动画"></a> 过渡动画</h1>
<p>Vue 在插入、更新或者移除 DOM 时，可以插入过渡动画。一些插入动画的方式如下：</p>
<ul>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
</ul>
<h2 id="单元素组件过渡"><a class="markdownIt-Anchor" href="#单元素组件过渡"></a> 单元素/组件过渡</h2>
<p>内置组件<code>&lt;transition&gt;</code>可以用于给元素或组件添加进入/离开动画</p>
<h1 id="虚拟dom"><a class="markdownIt-Anchor" href="#虚拟dom"></a> 虚拟DOM</h1>
<p>浏览器会将HTML代码解析为一个DOM树，以便组织所有的元素，从而快速的增删改查。<br />
Vue会根据模板或渲染函数创建一个虚拟DOM（树），以便追踪要如何改变浏览器的DOM。<br />
虚拟结点(virtual node)简称VNode，它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。</p>
<h1 id="渲染函数"><a class="markdownIt-Anchor" href="#渲染函数"></a> 渲染函数</h1>
<p>除了使用模板来创建HTML元素之外，还可以使用渲染函数，它允许你通过JavaScript更细致的控制每一个元素是如何创建的。模板实际上最终也被编译成了渲染函数。</p>
<p>选项对象中的<code>render</code>属性的值是一个渲染函数，渲染函数返回一个VNode对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;anchored-heading&#x27;</span>, &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">&#x27;h&#x27;</span> + <span class="built_in">this</span>.level,   <span class="comment">// 标签名称</span></span><br><span class="line">      <span class="built_in">this</span>.$slots.default <span class="comment">// 子节点数组</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>渲染函数的参数是用于创建VNode的函数<code>createElement</code>（也经常简写为<code>h</code>），通过调用这个函数就可以创建结点，最终返回一个VNode。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateElement &#123;</span><br><span class="line">  (tag?: <span class="built_in">string</span> | Component | AsyncComponent | (<span class="function">() =&gt;</span> Component), children?: VNodeChildren): VNode;</span><br><span class="line">  (tag?: <span class="built_in">string</span> | Component | AsyncComponent | (<span class="function">() =&gt;</span> Component), data?: VNodeData, children?: VNodeChildren): VNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createElement</code>第一个参数是HTML标签字符串，或者一个组件选项对象，又或者是一个结果值为标签字符串或选项对象的async函数。该参数是必须传递的。<br />
第二个参数是正在创建的VNode的属性数据对象(VNodeData)。该参数是可选的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> VNodeData &#123;</span><br><span class="line">  key?: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 如果组件是其它组件的子组件，需为插槽指定名称</span></span><br><span class="line">  slot?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 作用域插槽的值是函数</span></span><br><span class="line">  <span class="comment">// props =&gt; VNode | Array&lt;VNode&gt;</span></span><br><span class="line">  scopedSlots?: &#123; [key: <span class="built_in">string</span>]: ScopedSlot | <span class="literal">undefined</span> &#125;;</span><br><span class="line">  ref?: <span class="built_in">string</span>;</span><br><span class="line">  refInFor?: <span class="built_in">boolean</span>;</span><br><span class="line">  tag?: <span class="built_in">string</span>;</span><br><span class="line">  staticClass?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 接受一个字符串、对象或字符串和对象组成的数组</span></span><br><span class="line">  class?: any;</span><br><span class="line">  staticStyle?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;;</span><br><span class="line">  <span class="comment">// 接受一个字符串、对象，或对象组成的数组</span></span><br><span class="line">  style?: <span class="built_in">string</span> | <span class="built_in">object</span>[] | <span class="built_in">object</span>;</span><br><span class="line">  <span class="comment">// 组件 prop</span></span><br><span class="line">  props?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;;</span><br><span class="line">  <span class="comment">// 普通的 HTML attribute</span></span><br><span class="line">  attrs?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;;</span><br><span class="line">  <span class="comment">// DOM property</span></span><br><span class="line">  domProps?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;;</span><br><span class="line">  hook?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">Function</span> &#125;;</span><br><span class="line">  <span class="comment">// 事件监听器但不支持修饰符</span></span><br><span class="line">  on?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">  <span class="comment">// 仅用于组件，用于监听原生事件</span></span><br><span class="line">  nativeOn?: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">  transition?: <span class="built_in">object</span>;</span><br><span class="line">  show?: <span class="built_in">boolean</span>;</span><br><span class="line">  inlineTemplate?: &#123;</span><br><span class="line">    render: <span class="built_in">Function</span>;</span><br><span class="line">    staticRenderFns: <span class="built_in">Function</span>[];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 自定义指令。注意，你无法对 binding 中的 oldValue赋值</span></span><br><span class="line">  directives?: VNodeDirective[];</span><br><span class="line">  keepAlive?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ScopedSlot = <span class="function">(<span class="params">props: <span class="built_in">any</span></span>) =&gt;</span> ScopedSlotReturnValue;</span><br><span class="line"><span class="keyword">type</span> ScopedSlotReturnValue = VNode | <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="literal">null</span> | <span class="literal">undefined</span> | ScopedSlotReturnArray;</span><br><span class="line"><span class="keyword">interface</span> ScopedSlotReturnArray <span class="keyword">extends</span> Array&lt;ScopedSlotReturnValue&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第三个参数是一个字符串（表示单个文本VNode），或一个VNode的数组。该参数是可选的。注意，<code>createElement</code>创建的VNode在一个虚拟DOM中只能出现一次，因此数组中不能有两个相同对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> VNodeChildren = VNodeChildrenArrayContents | [ScopedSlot] | <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VNodeChildrenArrayContents <span class="keyword">extends</span> Array&lt;VNodeChildren | VNode&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用指令的实现"><a class="markdownIt-Anchor" href="#常用指令的实现"></a> 常用指令的实现</h2>
<p><code>v-if</code>和<code>v-for</code>可以用<code>if-else</code>和<code>for</code>循环或<code>map</code>函数实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;items.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;items&#x27;</span>],</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.items.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&#x27;ul&#x27;</span>, <span class="built_in">this</span>.items.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">&#x27;li&#x27;</span>, item.name)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;No items found.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>v-model</code>可以通过<code>:value</code>和<code>@input</code>实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">      domProps: &#123;</span><br><span class="line">        value: self.value</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">          self.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修饰符-3"><a class="markdownIt-Anchor" href="#修饰符-3"></a> 修饰符</h2>
<p>某些事件修饰符的逻辑不需要手动在渲染函数中实现，只需要为VNodeData中的<code>on</code>对象的属性键增加对应的前缀：</p>
<table>
<thead>
<tr>
<th style="text-align:left">修饰符</th>
<th style="text-align:left">前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.passive</code></td>
<td style="text-align:left"><code>&amp;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>.capture</code></td>
<td style="text-align:left"><code>!</code></td>
</tr>
<tr>
<td style="text-align:left"><code>.once</code></td>
<td style="text-align:left"><code>~</code></td>
</tr>
<tr>
<td style="text-align:left"><code>.capture.once</code>或<code>.once.capture</code></td>
<td style="text-align:left"><code>~!</code></td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  <span class="string">&#x27;!click&#x27;</span>: <span class="built_in">this</span>.doThisInCapturingMode,</span><br><span class="line">  <span class="string">&#x27;~keyup&#x27;</span>: <span class="built_in">this</span>.doThisOnce,</span><br><span class="line">  <span class="string">&#x27;~!mouseover&#x27;</span>: <span class="built_in">this</span>.doThisOnceInCapturingMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应其他修饰符，你还是需要手动实现相应的逻辑：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>处理函数中的等价操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.stop</code></td>
<td><code>event.stopPropagation()</code></td>
</tr>
<tr>
<td><code>.prevent</code></td>
<td><code>event.preventDefault()</code></td>
</tr>
<tr>
<td><code>.self</code></td>
<td><code>if (event.target !== event.currentTarget) return</code></td>
</tr>
<tr>
<td><code>.enter</code>或<code>.13</code></td>
<td><code>if (event.keyCode !== 13) return</code></td>
</tr>
<tr>
<td><code>.ctrl</code></td>
<td><code>if (!event.ctrlKey) return</code></td>
</tr>
</tbody>
</table>
<h2 id="jsx"><a class="markdownIt-Anchor" href="#jsx"></a> JSX</h2>
<p>全部写函数逻辑有时很麻烦，我们可能更希望增强版本的模板，而不是完全使用JavaScript。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;/span&gt; world!</span><br><span class="line">      &lt;/AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="函数式组件-2"><a class="markdownIt-Anchor" href="#函数式组件-2"></a> 函数式组件</h2>
<p>在组件选项中使用<code>functional</code>声明一个函数式组件。此时渲染函数接受第二个参数<code>context</code>，它是一个对象，包含下列属性：<br />
props：提供所有 prop 的对象<br />
children：VNode 子节点的数组<br />
slots：一个函数，返回了包含所有插槽的对象<br />
scopedSlots：(2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。<br />
data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件<br />
parent：对父组件的引用<br />
listeners：(2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。<br />
injections：(2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的 property。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// Props 是可选的</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 为了弥补缺少的实例</span></span><br><span class="line">  <span class="comment">// 提供第二个参数作为上下文</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>单文件组件中，使用<code>functional</code>属性声明函数式组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在普通组件中，没有被定义为 prop 的 attribute 会自动添加到组件的根元素上，将已有的同名 attribute 进行替换或与其进行智能合并。然而函数式组件要求你显式定义该行为，即将<code>context.data</code>传给<code>createElement</code>的第二个参数。</p>
<h1 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h1>
<p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>
<ul>
<li>添加全局方法或者 property。如：vue-custom-element</li>
<li>添加全局资源：指令/过滤器/过渡等。如 vue-touch</li>
<li>通过全局混入来添加一些组件选项。如 vue-router</li>
<li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router</li>
</ul>
<h2 id="使用插件"><a class="markdownIt-Anchor" href="#使用插件"></a> 使用插件</h2>
<p>通过全局方法<code>Vue.use(MyPlugin)</code>来使用插件，该方法的调用需要在<code>new Vue()</code>之前完成。还可以传入可选的选项：<code>Vue.use(MyPlugin, &#123; someOption: true &#125;)</code><br />
<code>Vue.use</code> 会自动阻止多次注册相同插件，即使多次调用也只会注册一次该插件。<br />
某些插件在检测到<code>Vue</code>是全局变量时会自动调用<code>Vue.use</code>，但你不能依赖这种行为，因此保险起见，始终调用<code>Vue.use</code>。</p>
<h2 id="开发插件"><a class="markdownIt-Anchor" href="#开发插件"></a> 开发插件</h2>
<p>Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="过滤器-2"><a class="markdownIt-Anchor" href="#过滤器-2"></a> 过滤器</h1>
<p>过滤器是对输入值进行处理并返回输出值的函数。可以用在双花括号插值，以及<code>v-bind</code>表达式中，但只能被添加在 JavaScript 表达式的尾部。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上等价于</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; capitalize(message) &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;formatId(rawId)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>过滤器语法相比<code>methods</code>中定义的方法唯一的优点，就是不用写那么多嵌套函数调用括号。<br />
组件选项中可以通过<code>filters</code>来自定义过滤器。<br />
也可以通过<code>Vue.filter(name, func)</code>来定义全局过滤器。<br />
全局过滤器和组件内的局部过滤器同名时，局部过滤器优先。</p>
<p>过滤器通常只接受一个参数，这个参数就是前面表达式的结果。如果你非要定义接受多个参数，那么使用过滤器时就必须变成<code>&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</code>，前面表达式的结果仍然是过滤器的第一个参数，括号中定义的是第二个和第三个参数，这里字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。</p>
<h1 id="单文件组件"><a class="markdownIt-Anchor" href="#单文件组件"></a> 单文件组件</h1>
<p>使用<code>Vue.component</code>来定义组件有很多缺点：</p>
<ul>
<li>全局定义 (Global definitions) 强制要求每个 component 中的命名不得重复</li>
<li>字符串模板 (String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 <code>\</code></li>
<li>不支持 CSS (No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>
<li>没有构建步骤 (No build step) 限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li>
</ul>
<p>单文件组件<code>.vue</code>用于解决这个问题。<br />
单文件组件以扩展名<code>vue</code>结尾，它有三个部分：模板、JS代码、样式。<br />
组件的模板内容写在<code>&lt;template&gt;</code>中，组件的选项、导入的其他组件写在<code>&lt;script&gt;</code>中，样式写在<code>&lt;style&gt;</code>中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      greeting: <span class="string">&#x27;Hello&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>安装：<code>npm install -g @vue/cli</code><br />
升级：<code>npm update -g @vue/cli</code></p>
<p>app._render() 基于当前数据返回新的虚拟DOM<br />
app._vnote 目前已经渲染出DOM<br />
Vue会比较二者的差异，将需要修改的部分修改。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/前端/Vue.html">https://rcocco.github.io/categories/计算机/前端/Vue.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"><i class="fa fa-chevron-left">  </i><span>计算机网络</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/Vue-Router.html"><span>Vue-Router</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>