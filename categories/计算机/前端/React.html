<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="React"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>React | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E5%85%83%E7%B4%A0"><span class="toc-number">1.</span> <span class="toc-text"> React元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.</span> <span class="toc-text"> 创建元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createelement"><span class="toc-number">1.1.1.</span> <span class="toc-text"> createElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsx"><span class="toc-number">1.1.2.</span> <span class="toc-text"> JSX</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text"> 渲染元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.</span> <span class="toc-text"> 更新元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text"> 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text"> 函数组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text"> class组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-number">2.2.2.1.</span> <span class="toc-text"> 挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-number">2.2.2.2.</span> <span class="toc-text"> 更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.2.2.3.</span> <span class="toc-text"> 卸载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%B7%B2%E6%9C%89%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text"> 基于已有组件创建新组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 固定子元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%BB%84%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text"> 设计组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B0%86%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84ui%E5%88%92%E5%88%86%E4%B8%BA%E7%BB%84%E4%BB%B6%E5%B1%82%E7%BA%A7"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 1. 将设计好的UI划分为组件层级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%A8react%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%89%88%E6%9C%AC"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 2 用React创建一个静态版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 固定其他参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text"> 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text"> 事件监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text"> 事件处理程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">4.</span> <span class="toc-text"> 渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">4.1.</span> <span class="toc-text"> 条件渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-number">4.2.</span> <span class="toc-text"> 列表渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text"> 表单控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text"> 受控组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text"> 非受控组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8"><span class="toc-number">6.</span> <span class="toc-text"> 备注</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E5%85%83%E7%B4%A0-2"><span class="toc-number">6.1.</span> <span class="toc-text"> React元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text"> 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E7%99%BD%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text"> 空白符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">6.4.</span> <span class="toc-text"> 子元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-2"><span class="toc-number">7.</span> <span class="toc-text"> 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-2"><span class="toc-number">7.1.</span> <span class="toc-text"> 函数组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E7%BB%84%E4%BB%B6-2"><span class="toc-number">7.2.</span> <span class="toc-text"> class组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81-2"><span class="toc-number">7.2.1.</span> <span class="toc-text"> 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text"> 生命周期方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81"><span class="toc-number">7.2.3.</span> <span class="toc-text"> 更新状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">7.3.</span> <span class="toc-text"> 单向数据传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text"> 事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-3"><span class="toc-number">8.1.</span> <span class="toc-text"> 函数组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E7%BB%84%E4%BB%B6-3"><span class="toc-number">8.2.</span> <span class="toc-text"> class组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E9%A2%9D%E5%A4%96%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text"> 传递额外的参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93-2"><span class="toc-number">9.</span> <span class="toc-text"> 条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8if%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.1.</span> <span class="toc-text"> 使用if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">9.2.</span> <span class="toc-text"> 内联条件渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93-2"><span class="toc-number">10.</span> <span class="toc-text"> 列表渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">11.</span> <span class="toc-text"> 表单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E8%BE%93%E5%85%A5%E6%A1%86"><span class="toc-number">11.1.</span> <span class="toc-text"> 单行输入框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E8%BE%93%E5%85%A5%E6%A1%86"><span class="toc-number">11.2.</span> <span class="toc-text"> 多行输入框</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">12.</span> <span class="toc-text"> 其他</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E7%94%A8"><span class="toc-number">13.</span> <span class="toc-text"> 备用</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">203</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">React</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/">前端</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="react元素"><a class="markdownIt-Anchor" href="#react元素"></a> React元素</h1>
<p>React元素是构成React应用的最小砖块。React元素类似于DOM元素，它也有元素类型、元素属性、子元素，主要区别在于：</p>
<ul>
<li>React元素开销比DOM元素小得多，因为React元素只有元素类型、元素属性、子元素等少数简单的属性。</li>
<li>React元素是不可变对象，一旦创建就不能再修改。具体而言，React元素的所有属性，以及当这些属性是对象时，这些对象的属性，还有对象的属性的属性等等深层的属性，都是不可配置、不可修改的。</li>
</ul>
<span id="more"></span>
<h2 id="创建元素"><a class="markdownIt-Anchor" href="#创建元素"></a> 创建元素</h2>
<p>有两种方法可以创建React元素：</p>
<ol>
<li>使用<code>React.createElement</code>函数</li>
<li>使用JSX语法</li>
</ol>
<h3 id="createelement"><a class="markdownIt-Anchor" href="#createelement"></a> createElement</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(type, props, ...children)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type</code>是标签名字符串（如<code>'div'</code>）或React组件（类或函数对象，也可以是表示React fragment组件的Symbol值），表示要创建的React元素的类型</li>
<li><code>props</code>是要创建的React元素的属性，通常是一个对象，这个对象的属性会作为React元素的属性。如果要创建的元素不需要属性，也可以传递<code>null</code>或<code>undefined</code>（如果没有<code>children</code>参数也可以不传递<code>props</code>）
<ul>
<li><code>props.children</code>是<code>props</code>中一个特殊的属性，它保存着React元素的子元素。当没有子元素时，不存在该属性。当有一个子元素时，<code>props.children</code>就是该子元素。当有两个及以上子元素时，<code>props.children</code>是子元素组成的数组。</li>
</ul>
</li>
<li><code>children</code>是任意个子元素，为了方便起见我们通常通过<code>children</code>参数来间接设置<code>props.children</code>。如果同时设置了<code>children</code>参数和<code>props.children</code>，则<code>children</code>参数会覆盖手动设置的<code>props.children</code>。</li>
</ul>
<p>尽管任何值都可以作为子元素，但能被ReactDOM渲染的子元素只有四种类型：<code>Number</code>、<code>String</code>、React元素、前三种子元素组成的数组。其他类型的子元素在渲染时会被忽略。</p>
<p>具体而言，在渲染时各子元素会被如下处理：</p>
<ul>
<li><code>Number</code>类型子元素会被调用<code>toString</code>转换为字符串，被渲染为文本结点。</li>
<li><code>String</code>类型子元素会被渲染为文本结点。</li>
<li>React元素类型的子元素会作为React元素渲染。</li>
<li>数组类型子元素，会逐个按规则进行渲染。</li>
<li>其他类型子元素，不渲染。</li>
</ul>
<h3 id="jsx"><a class="markdownIt-Anchor" href="#jsx"></a> JSX</h3>
<p>JSX是JavaScript的语法扩展，它使得创建 React 元素的函数调用<code>React.createElement</code>，能够写成类似HTML元素的形式（即<code>&lt;开始标签&gt;内容&lt;/结束标签&gt;</code>），这种形式十分接近React元素渲染成DOM元素的代码。<br />
每个 JSX 元素只是调用 <code>React.createElement</code> 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成，可以在<a target="_blank" rel="noopener" href="https://babeljs.io/repl">Babel官网</a>看到这种转换。此外，JSX经常会比较长，需要换行，为了避免换行时JS的自动插入分号机制破坏了JSX的语法，对于需要换行的JSX元素最好使用圆括号<code>()</code>括起来。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;开始标签 属性名=<span class="string">&quot;属性值&quot;</span>&gt;内容&lt;/结束标签&gt;</span><br><span class="line">&lt;开始标签 属性名=&#123;表达式&#125;&gt;内容&lt;/结束标签&gt;</span><br><span class="line">&lt;开始标签 属性名&gt;内容&lt;/结束标签&gt;</span><br><span class="line">&lt;开始标签 &#123;...对象&#125;&gt;内容&lt;/结束标签&gt;</span><br><span class="line">&lt;自闭合标签 /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>标签名：表示元素类型
<ul>
<li>当标签名以小写开头时，标签名会作为<strong>字符串</strong>传给<code>React.createElement</code>的<code>type</code>参数。例如<code>&lt;h1&gt;&lt;/h1&gt;</code>等价于<code>React.createElement('h1')</code></li>
<li>当标签名以大写开头时，标签名会作为<strong>表达式</strong>传给<code>React.createElement</code>的<code>type</code>参数。例如<code>&lt;H1&gt;&lt;/H1&gt;</code>等价于<code>React.createEelement(H1)</code></li>
<li>必须手动书写斜杠<code>/</code>来表示这是一个自闭合标签，而不能像HTML元素那样自动识别自闭合标签。</li>
</ul>
</li>
<li>内容：表示子元素，实际上是属性名为<code>children</code>的属性
<ul>
<li>内容可以是字符串，例如<code>Hello</code></li>
<li>内容可以是由JSX表示的React元素，例如<code>&lt;span&gt;&lt;/span&gt;</code></li>
<li>内容可以是由<code>&#123;&#125;</code>括起来的表达式，例如<code>&#123;0.1+0.2&#125;</code>。</li>
<li>内容可以是字符串、React元素、表达式的任意组合，例如<code>Hello &#123;2014&#125; World</code>。</li>
</ul>
</li>
<li>属性
<ul>
<li>单个属性
<ul>
<li>属性名均使用驼峰式命名，例如DOM中的<code>class</code>在JSX中的属性名为<code>className</code>，<code>tabindex</code>变成了<code>tabIndex</code></li>
<li>属性值可以是字符串，例如<code>tabIndex=&quot;属性值&quot;</code>等价于<code>React.createElement</code>的<code>props</code>参数中，形如<code>&#123; tabIndex: &quot;属性值&quot; &#125;</code>的属性</li>
<li>属性值还可以是表达式，例如<code>tabIndex=&#123;表达式&#125;</code>等价于<code>React.createElement</code>的<code>props</code>参数中，形如<code>&#123; tabIndex: 表达式值 &#125;</code>的属性</li>
<li>属性值还可以不存在，这种形式等价于属性值是<code>&#123;true&#125;</code></li>
</ul>
</li>
<li>多个属性，使用<code>&#123;...对象&#125;</code>语法，<code>对象</code>的属性与值会作为元素的属性与值。</li>
<li>单属性语法和多属性语法可以混用，混用时会使用<code>Object.assign</code>将各个属性合并，同名属性写在后面的会覆盖前面的。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">p</span> &#123;<span class="attr">...obj</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">a</span>=<span class="string">&quot;A&quot;</span> &#123;<span class="attr">...obj</span>&#125;  <span class="attr">c</span>=<span class="string">&quot;C&quot;</span> &#123;<span class="attr">...prop</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// React.createElement</span></span><br><span class="line"><span class="keyword">var</span> element1 = React.createElement(<span class="string">&#x27;p&#x27;</span>, obj);</span><br><span class="line"><span class="keyword">var</span> element2 = React.createElement(<span class="string">&#x27;p&#x27;</span>, <span class="built_in">Object</span>.assign(</span><br><span class="line">                 &#123; <span class="attr">a</span>: <span class="string">&quot;A&quot;</span> &#125;, obj, &#123; <span class="attr">c</span>: <span class="string">&quot;C&quot;</span> &#125;, prop</span><br><span class="line">               ) );</span><br></pre></td></tr></table></figure>
<h2 id="渲染元素"><a class="markdownIt-Anchor" href="#渲染元素"></a> 渲染元素</h2>
<p>要让React元素在页面上显示，需要将React元素渲染为DOM元素，并且添加到当前页面的DOM树中。可以使用<code>ReactDOM.render</code>来完成这一操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(reactElement, DOMContainer, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reactElement</code>参数是要渲染的React元素</li>
<li><code>DOMContainer</code>参数是挂载渲染后的React元素的DOM容器元素，被渲染的React元素会作为DOM容器元素的子元素存在，它会替换容器元素原先的所有子元素。</li>
<li><code>callback</code>是可选的回调函数，在组件被渲染或更新后被执行。</li>
</ul>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span></span><br><span class="line"><span class="javascript">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React元素中只记录了元素的类型（字符串、构造函数），直到调用<code>ReactDOM.render</code>时相应的DOM元素才被创建，组件的构造函数才被调用。</p>
<h2 id="更新元素"><a class="markdownIt-Anchor" href="#更新元素"></a> 更新元素</h2>
<p>由于React元素是不可变对象，一旦创建就不能再修改，因此如果想调用<code>ReactDOM.render</code>来更新渲染元素，只能传递一个新的React元素。例如下面的例子中，每秒创建一个新的React元素，然后调用<code>ReactDOM.render</code>渲染它。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>));</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>调用<code>ReactDOM.render</code>来渲染时，React会比较被渲染的元素，和容器元素目前的子元素，采用DOM差分算法，尽可能只更新发生了变化的DOM元素，使得更新操作尽可能的高效。在上面的例子中，渲染的<code>&lt;div&gt;</code>和<code>&lt;h1&gt;</code>元素没有变化，也就不会被更新。</p>
<p>更常用的更新是通过组件的状态，当状态发生变化时，组件会自动重新渲染。</p>
<h1 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h1>
<p>组件是可复用的定制元素，它封装了要展示的基本HTML元素，以及在这些元素上通过JavaScript定义的行为。<br />
组件与原生HTML5中的<code>&lt;video&gt;</code>等元素十分相似，用户只需要为组件提供属性（<code>props</code>参数），最终渲染出的效果就是一个能够暂停、播放的视频。处理播放、暂停的逻辑都由组件内部完成，对于用户来说就是个黑盒。</p>
<p>React对于组件有一个核心要求：所有 React 组件都不能修改作为参数传递进来的<code>props</code>。<br />
因为一个<code>props</code>可能被传给多个组件，一旦某个组件修改了<code>props</code>，可能导致所有接受<code>props</code>并依赖于它的组件都发生了变化，这种行为是不合理的。</p>
<p>组件从定义的方式可以分成函数组件和class组件。</p>
<h2 id="函数组件"><a class="markdownIt-Anchor" href="#函数组件"></a> 函数组件</h2>
<p>满足下列要求的函数是一个函数组件：</p>
<ul>
<li>函数名以大写开头（组件名就是函数名）</li>
<li>接受表示属性的对象<code>props</code>参数。</li>
<li>返回一个React元素（？<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#render%EF%BC%89">https://zh-hans.reactjs.org/docs/react-component.html#render）</a></li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若React元素的类型是函数组件，在调用<code>ReactDOM.render</code>渲染元素时，元素的所有属性与值会作为一个对象传给函数，最后渲染这个函数返回的React元素。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;Sara&quot;</span> /&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 调用了Welcome(&#123;name: &quot;Sara&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<h2 id="class组件"><a class="markdownIt-Anchor" href="#class组件"></a> class组件</h2>
<p>满足下列要求的类是一个class组件：</p>
<ul>
<li>类名以大写开头（组件名就是类名）</li>
<li>继承<code>React.Component</code></li>
<li>实现了<code>render()</code>方法，该方法返回一个React元素</li>
</ul>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于父类<code>React.Component</code>的构造函数（代码如下）接受表示属性的对象<code>props</code>参数，因此作为子类的class组件可以使用<code>this.props</code>访问到传递给组件的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.Component</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.props = props;</span><br><span class="line">  <span class="built_in">this</span>.context = context;</span><br><span class="line">  <span class="built_in">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="built_in">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h3>
<p>组件需要管理自己的内部状态，根据约定，class组件的状态对象保存在组件实例的<code>state</code>属性上，通过<code>this.state</code>可以访问。</p>
<p>要更新状态，使用<code>setState()</code>原型方法。不要直接修改<code>this.state</code>，因为<code>setState()</code>方法是由<code>React.Component</code>而不是用户实现的，一旦调用该方法，React框架就知道状态更新了，于是会自动的去重新渲染组件。</p>
<p><code>setState()</code>有两种调用形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setState(<span class="function">(<span class="params">nextState, nextProps</span>)=&gt;</span>&#123; <span class="keyword">return</span> newState &#125;, callback);</span><br><span class="line">setState(newState, callback);</span><br></pre></td></tr></table></figure>
<ol>
<li>其第一个参数是一个函数对象，或者一个表示要更新的状态的对象。
<ul>
<li>当第一个参数是函数对象时，函数的参数为<code>(nextState, nextProps)</code>，这里<code>nextState</code>是最新的<code>state</code>（它可能和<code>this.state</code>相同，也可能不同，因为对状态 的更新不一定会立刻反应到<code>this.state</code>上），返回值应该是一个对象，对象的属性会被<code>Object.assign</code>合并到原来的状态对象上。</li>
<li>当第一个参数是一个对象（不是函数对象）时，对象的属性会被<code>Object.assign</code>合并到原来的状态对象上。</li>
</ul>
</li>
<li>其第二个参数是一个可选的回调函数，它将在<code>setState()</code>导致的更新完成后执行。
<ul>
<li>当生命周期函数<code>shouldComponentUpdate()</code>返回<code>false</code>时，它会在<code>shouldComponentUpdate()</code>执行完毕后调用。</li>
<li>当生命周期函数<code>shouldComponentUpdate()</code>返回<code>true</code>时，它会在<code>componentDidUpdate()</code>执行完毕后调用。</li>
</ul>
</li>
</ol>
<p><code>setState()</code>只是安排一次更新，将更新操作添加到队列中，它未必会立刻更新<code>this.state</code>。在更新<code>this.state</code>之前，如果多次调用<code>setState()</code>安排更新，这些更新可能会被合并执行。<br />
这导致当第一个参数是对象时，例如<code>setState(&#123;count: this.count + 1&#125;)</code>，多次调用只能将状态的<code>count</code>加1，而不会增加多次，因为合并执行后等价于<code>Object.assign(prevState, &#123;count: this.count+1&#125;, &#123;count: this.count+1&#125;)</code>。为了避免由合并更新导致的意外，最好使用第一个参数是函数对象的调用形式，它能保证每次获取的<code>state</code>都是最新的。</p>
<p>在目前React常规版本（而非实验版本）中，只有在React的事件处理程序中多次调用<code>setState()</code>才会合并执行。在React事件处理程序以外的地方多次调用<code>setState()</code>不会合并执行，而是每次调用更新一次，再执行下一次调用。</p>
<h3 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h3>
<p>组件实例的生命周期分为三个阶段：</p>
<ol>
<li>挂载：创建组件实例或DOM结点，并将其插入到DOM容器的过程</li>
<li>更新：当出现新的<code>props</code>（例如父组件改变了子组件上的属性）、调用<code>setState()</code>和<code>forceUpdate()</code>时，组件被重新渲染的过程。</li>
<li>卸载：组件被从DOM容器中移除的过程</li>
</ol>
<p><img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/_v_images/20210603185533232_8573.png" alt="" width="621" /></p>
<h4 id="挂载"><a class="markdownIt-Anchor" href="#挂载"></a> 挂载</h4>
<p>在挂载期间，React会依次调用class组件的下列方法，程序员可以在这些方法中编写自己需要的逻辑，从而影响元素挂载过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span>(<span class="params">props</span>)</span><br></pre></td></tr></table></figure>
<p>React会调用class组件的<code>constructor</code>构造函数来创建组件实例。如果不需要进行任何操作可以没有<code>constructor</code>方法，让JavaScript自动生成默认的<code>constructor</code>，默认的<code>constructor</code>会将<code>state</code>初始化为<code>null</code>。<br />
class组件的构造函数内不要执行任何有副作用的操作，它通常只做两件事：</p>
<ul>
<li>初始化<code>state</code>，如<code>this.state = &#123; counter: 0 &#125;</code>，如果将<code>state</code>初始化为<code>undefined</code>，最终也会变成<code>null</code>。注意不要调用<code>setState</code>来更新状态。</li>
<li>为事件处理函数绑定<code>this</code>，如<code>this.handleClick = this.handleClick.bind(this)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, nextState)</span><br></pre></td></tr></table></figure>
<p>React会调用class组件的<code>getDerivedStateFromProps</code>方法来更新<code>state</code>。注意此方法中的<code>this</code>为<code>undefined</code>，无法直接访问到组件实例。</p>
<ul>
<li><code>nextProps</code>是传递给组件实例的参数。</li>
<li><code>nextState</code>是组件实例的状态，如果没有在<code>constructor</code>中初始化过<code>state</code>，那么这里的<code>state</code>是<code>null</code>。之所以用<code>next</code>前缀开头，是因为此函数执行时还没有改变<code>this.state</code>，这里<code>nextState</code>是一个即将用于更新的值而不是已经更新的值。</li>
<li>函数应该返回<code>null</code>或者一个对象，当返回对象时，该对象被与<code>state</code>合并来更新状态，当返回<code>null</code>时则不更新状态。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render()</span><br></pre></td></tr></table></figure>
<p>React会调用class组件的<code>render</code>方法来返回组件内部的构成元素。<br />
在调用此函数时，<code>this.state</code>已经是更新后的状态。<br />
它应该是纯函数，只要组件实例的<code>state</code>没有发生变化，每次调用都应该返回相同结果，而且不应该与浏览器进行交互。返回值必须是以下类型之一：</p>
<ul>
<li>React元素：通常通过JSX创建</li>
<li>数组 / fragments：用于返回多个元素</li>
<li>Portals：用于将子结点渲染到指定的DOM元素里</li>
<li>String / Number：被渲染为文本结点</li>
<li>Boolean / Null：什么都不渲染，主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式</li>
</ul>
<p>即便<code>render()</code>什么都不渲染，<code>componentDidMount()</code>仍然会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()</span><br></pre></td></tr></table></figure>
<p>React会在组件被插入到DOM树后调用class组件的<code>componentDidMount</code>方法。<br />
依赖于 DOM 节点的初始化操作应该放在这里。例如通过网络请求获取数据，可以在这里创建请求。<br />
函数内可以通过<code>this.state</code>来访问到已经更新过的状态。<br />
如果在该函数内调用<code>setState()</code>将触发额外渲染，但额外的渲染会发生在浏览器更新屏幕之前，因此用户不会看到中间状态。谨慎使用这种办法来额外渲染，因为它会导致性能问题。通常，你应该在 <code>constructor()</code> 中初始化 <code>state</code>。只有在渲染依赖于 DOM 节点的大小或位置，才用这种方式处理。</p>
<h4 id="更新"><a class="markdownIt-Anchor" href="#更新"></a> 更新</h4>
<p>在更新期间，React会依次调用class组件的下列方法，程序员可以在这些方法中编写自己需要的逻辑，从而影响元素更新过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, nextState)</span><br></pre></td></tr></table></figure>
<p>React会调用class组件的<code>getDerivedStateFromProps</code>方法来更新<code>state</code>。注意此方法中的<code>this</code>为<code>undefined</code>，无法直接访问到组件实例。</p>
<ul>
<li><code>nextProps</code>是传递给组件实例的参数。</li>
<li><code>nextState</code>是组件实例的状态，如果没有在<code>constructor</code>中初始化过<code>state</code>，那么这里的<code>state</code>是<code>null</code>。之所以用<code>next</code>前缀开头，是因为此函数执行时还没有改变<code>this.state</code>，这里<code>nextState</code>是一个即将用于更新的值而不是已经更新的值。</li>
<li>函数应该返回<code>null</code>或者一个对象，当返回对象时，该对象被与<code>state</code>合并来更新状态，当返回<code>null</code>时则不更新状态。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure>
<p>当由于出现新的<code>props</code>（例如父组件改变了子组件上的属性），或者调用<code>setState()</code>导致更新时，React会调用class组件的<code>shouldComponentUpdate</code>方法，并根据返回的布尔值来判断是否要重新渲染。<br />
但当通过<code>forceUpdate()</code>更新时，不会调用该函数。如果没有调用该函数，则和返回<code>true</code>效果一样，会重新渲染。<br />
该函数内可以调用<code>this.state</code>来得到组件尚未更新时的状态。<br />
当明确返回<code>false</code>时，组件不会被重新渲染，也不会调用更新阶段剩余的<code>render()</code>、<code>getSnapshotBeforeUpdate()</code>、<code>componentDidUpdate()</code>方法，但状态的更新仍然会进行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render()</span><br></pre></td></tr></table></figure>
<p>React会调用class组件的<code>render</code>方法来返回组件内部的构成元素。<br />
在调用此函数时，<code>this.state</code>已经是更新后的状态。<br />
它应该是纯函数，只要组件实例的<code>state</code>没有发生变化，每次调用都应该返回相同结果，而且不应该与浏览器进行交互。返回值必须是以下类型之一：</p>
<ul>
<li>React元素：通常通过JSX创建</li>
<li>数组 / fragments：用于返回多个元素</li>
<li>Portals：用于将子结点渲染到指定的DOM元素里</li>
<li>String / Number：被渲染为文本结点</li>
<li>Boolean / Null：什么都不渲染，主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式</li>
</ul>
<p>即便<code>render()</code>什么都不渲染，<code>getSnapshotBeforeUpdate()</code>仍然会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)</span><br></pre></td></tr></table></figure>
<p>React会在将更新的渲染输出提交到DOM结点前调用class组件的<code>getSnapshotBeforeUpdate</code>方法，此函数通常用于在组件更新前从DOM中获取一些信息(snapshot)并传给下一个函数。<br />
在调用此函数时，参数<code>prevState</code>是本次更新阶段开始之前的状态，而<code>this.state</code>是更新后的状态。<br />
此函数的返回值会作为参数传给下一个钩子函数<code>componentDidUpdate()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure>
<p>React会在组件更新被提交到DOM结点后调用class组件的<code>componentDidUpdate</code>方法。<br />
在调用此函数时，参数<code>prevState</code>是本次更新阶段开始之前的状态，而<code>this.state</code>是更新后的状态。<code>snapShot</code>是<code>getSnapshotBeforeUpdate()</code>返回的值，如果没有定义过<code>getSnapshotBeforeUpdate()</code>，其值为<code>undefined</code><br />
组件更新后才能执行的DOM操作可以在此进行，例如通过网络请求获取数据，可以在这里创建请求。<br />
注意，如果要在这里调用<code>setState()</code>，一定要将其放在条件语句中，有选择性的执行，避免死循环，因为<code>setState()</code>又将触发更新，又会调用<code>componentDidUpdate</code>。</p>
<h4 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure>
<p>React会在组件卸载及销毁之前调用class组件的<code>componentWillUnmount</code>方法。<br />
通常在此方法中执行必要的清理操作，例如，清除定时器，取消网络请求等。<br />
此方法中不应该调用 <code>setState()</code>，因为组件马上就会被卸载，不会被重新渲染，修改状态没有任何意义。</p>
<h2 id="基于已有组件创建新组件"><a class="markdownIt-Anchor" href="#基于已有组件创建新组件"></a> 基于已有组件创建新组件</h2>
<p>通常通过固定为组件传递的某些参数来创建新组件</p>
<h3 id="固定子元素"><a class="markdownIt-Anchor" href="#固定子元素"></a> 固定子元素</h3>
<p>组件的内容是名为<code>props.children</code>的属性，因此组件可以接受外部参数（包括组件）作为其内容。这通常用于那些无法提前知晓自己的子元素的那些组件，例如侧边栏和对话框。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">&#x27;FancyBorder FancyBorder-&#x27;</span> + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;SplitPane&quot;</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>固定为其传递特定的子元素，就得到了新组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">&quot;blue&quot;</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span><br><span class="line">        Thank you <span class="keyword">for</span> visiting our spacecraft!</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left=&#123;</span><br><span class="line">        &lt;Contacts /&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计组件"><a class="markdownIt-Anchor" href="#设计组件"></a> 设计组件</h2>
<h3 id="1-将设计好的ui划分为组件层级"><a class="markdownIt-Anchor" href="#1-将设计好的ui划分为组件层级"></a> 1. 将设计好的UI划分为组件层级</h3>
<p>单一职责原则(Single-responsibility principle)：一个类、模块应该有且只有一个变化的原因。<br />
一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。<br />
假设有一个返回JSON的API，以及一个设计稿，考虑组件的设计：<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/_v_images/20210612212855202_3456.png" alt="" /><br />
应该在设计稿上用方框圈出每一个组件（包括它们的子组件），并以合适的名称命名。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/_v_images/20210612213020267_22594.png" alt="" /></p>
<ul>
<li>FilterableProductTable (橙色): 是整个示例应用的整体</li>
<li>SearchBar (蓝色): 接受所有的用户输入</li>
<li>ProductTable (绿色): 展示数据内容并根据用户输入筛选结果</li>
<li>ProductCategoryRow (天蓝色): 为每一个产品类别展示标题</li>
<li>ProductRow (红色): 每一行展示一个产品</li>
</ul>
<p>然后就可以给出组件的层级：</p>
<ul>
<li>FilterableProductTable
<ul>
<li>SearchBar</li>
<li>ProductTable
<ul>
<li>ProductCategoryRow</li>
<li>ProductRow</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-用react创建一个静态版本"><a class="markdownIt-Anchor" href="#2-用react创建一个静态版本"></a> 2 用React创建一个静态版本</h3>
<p>现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。</p>
<h3 id="固定其他参数"><a class="markdownIt-Anchor" href="#固定其他参数"></a> 固定其他参数</h3>
<p>下面的组件接受参数<code>title</code>和<code>message</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">&quot;blue&quot;</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要固定这些参数，就又可以得到新组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Dialog</span><br><span class="line">      title=<span class="string">&quot;Welcome&quot;</span></span><br><span class="line">      message=<span class="string">&quot;Thank you for visiting our spacecraft!&quot;</span> /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h1>
<p>React有一套专门的事件系统，它的事件名都是以<code>on</code>开头的驼峰式命名，例如<code>onClick</code>。</p>
<h2 id="事件监听器"><a class="markdownIt-Anchor" href="#事件监听器"></a> 事件监听器</h2>
<p>要为组件添加事件监听器，只需要将事件名和处理函数作为<code>props</code>参数传给组件。例如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h2 id="事件处理程序"><a class="markdownIt-Anchor" href="#事件处理程序"></a> 事件处理程序</h2>
<p>事件处理程序接受一个React事件对象，React事件对象也实现了浏览器原生对象的相关接口，因此用法十分类似。<br />
最主要的区别在于不能通过返回<code>false</code>来阻止默认行为，必须显式调用<code>preventDefault()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件处理程序中经常需要访问组件实例，例如希望获取组件当前状态或更新状态。但React不会为事件处理程序传递组件实例作为参数，而且在调用事件处理程序时所用的<code>thisArgument</code>是<code>undefined</code>（<code>handle.apply(undefined, e)</code>）<br />
因此为了拿到组件实例，必须手动绑定<code>this</code>，有几种办法：<br />
一种办法是将事件处理程序定义为原型方法，然后在构造函数中通过<code>bind</code>创建同名的绑定<code>this</code>的事件处理函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        点击</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种办法是使用ECMAScript 2022的类字段语法，类字段相当于在构造函数中创建的实例属性，当声明一个类字段，其值为箭头函数时，包围箭头函数的词法环境就变成了构造函数的词法环境，其<code>this</code>值就是组件实例了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick= <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        点击</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种办法是在<code>render()</code>中现场创建一个箭头函数对象，并通过<code>this</code>调用作为原型方法的事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;<span class="built_in">this</span>.handleClick()&#125;&#125;&gt;</span><br><span class="line">        点击</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点是由于<code>render()</code>经常被调用，每次被调用都会创建新的函数对象，可能导致性能问题。<br />
尽管存在缺点，但当你不止希望传递<code>thisArgument</code>，还想为事件处理程序传递额外参数时，就只能通过这种办法。<br />
onClick<br />
onSubmit<br />
onChange</p>
<h1 id="渲染"><a class="markdownIt-Anchor" href="#渲染"></a> 渲染</h1>
<h2 id="条件渲染"><a class="markdownIt-Anchor" href="#条件渲染"></a> 条件渲染</h2>
<p>组件经常会根据状态或<code>props</code>来决定渲染什么子元素。<br />
一种办法是使用条件语句来创建对应的React元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button;</span><br><span class="line">  <span class="keyword">if</span>(props.isLoggedIn) &#123;</span><br><span class="line">    button = <span class="xml"><span class="tag">&lt;<span class="name">LogoutButton</span>&gt;</span>登出<span class="tag">&lt;/<span class="name">LogoutButton</span>&gt;</span></span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    button = <span class="xml"><span class="tag">&lt;<span class="name">LoginButton</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">LoginButton</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;button&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用条件表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Login</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;props.isLoggedIn</span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;<span class="name">LogoutButton</span>&gt;</span>登出<span class="tag">&lt;/<span class="name">LogoutButton</span>&gt;</span></span></span><br><span class="line">        : <span class="xml"><span class="tag">&lt;<span class="name">LoginButton</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">LoginButton</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种办法是使用逻辑表达式，利用子元素为布尔值时不渲染任何内容的规则，使得满足条件时才渲染元素。注意，逻辑运算符不一定会返回布尔值，它会返回左侧的值或右侧的值，因此要利用这个规则需要保证其中一个操作数是返回布尔值的表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果什么都不想渲染，可以令函数组件的返回值、class组件的<code>render()</code>函数的返回值为<code>null</code>，和返回布尔值一样，返回<code>null</code>也不会渲染任何元素。</p>
<h2 id="列表渲染"><a class="markdownIt-Anchor" href="#列表渲染"></a> 列表渲染</h2>
<p>当渲染的子元素是 React元素组成的数组 时称为列表渲染，它将每一个数组元素当成子元素来进行渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numArr = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> elementArr = numArr.map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>num<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;elementArr&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于数组的变化通常是部分元素的变化（添加、删除）而不是整个数组所有元素的变化，为了提高性能，React采用<code>key</code>属性来标识数组元素，<code>key</code>属性是作为数组元素的React元素上的属性，它的值会被转为字符串来作为唯一标识符，当数组发生变化时，<code>key</code>值不变的React元素不再重新渲染。<br />
同一个数组中，所有元素的<code>key</code>必须不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numArr = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> elementArr = numArr.map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;num&#125;</span>&gt;</span>num<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;elementArr&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管<code>key</code>看上去是组件的属性，但在传递过程中<code>key</code>会被React拦截并获取，而不会作为<code>props</code>继续传递给组件。</p>
<h1 id="表单控件"><a class="markdownIt-Anchor" href="#表单控件"></a> 表单控件</h1>
<p>React中的表单控件分为受控组件和不受控组件。区别在于控件的状态（例如值）由React管理，还是由DOM结点管理。</p>
<h2 id="受控组件"><a class="markdownIt-Anchor" href="#受控组件"></a> 受控组件</h2>
<p>受控组件具有<code>value</code>或<code>checked</code>参数，当作为组件的表单控件具有该参数，且值不为<code>null</code>或<code>undefined</code>时，参数值会覆盖DOM结点中的值。效果就是不管怎么尝试输入，显示出的值永远是参数的值。<br />
当用户尝试输入时，会触发<code>onChange</code>事件，可以在这个事件的处理程序中修改这两个参数的值。<br />
通常会把受控组件的<code>value</code>或<code>checked</code>参数设为组件的<code>state</code>的某个值，然后在<code>onChange</code>处理程序中调用<code>setState()</code>更新状态，进而重新用新值渲染组件，在处理程序中可以通过<code>e.target.value</code>或<code>e.target.checked</code>访问到DOM结点上还没有被参数覆盖掉的最新值。</p>
<p>能够作为受控组件的控件主要有以下几种：</p>
<ul>
<li>文本框<code>&lt;input type=&quot;text&quot; /&gt;</code>，参数为<code>value</code></li>
<li>多行文本框<code>&lt;textarea /&gt;</code>，参数为<code>value</code>，表示多行文本框的文本，注意React中的多行文本框是自闭合元素。</li>
<li>下拉框<code>&lt;select&gt;&lt;/select&gt;</code>，参数为<code>value</code>，会选中与子元素的<code>value</code>相同的那个元素，多个元素可以将数组作为<code>value</code>值。</li>
<li>多选框<code>&lt;input type=&quot;checkbox&quot; /&gt;</code>，参数为<code>checked</code></li>
<li>单选框<code>&lt;input type=&quot;radio&quot; /&gt;</code>，参数为<code>checked</code></li>
</ul>
<h2 id="非受控组件"><a class="markdownIt-Anchor" href="#非受控组件"></a> 非受控组件</h2>
<p>非受控组件没有<code>value</code>或<code>checked</code>参数，这些控件的值由DOM结点自己管理，获取或者设置控件的值，和DOM中用的方法一致。</p>
<h1 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h1>
<h2 id="react元素-2"><a class="markdownIt-Anchor" href="#react元素-2"></a> React元素</h2>
<h2 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h2>
<p>如果没有给元素属性赋值，那么它的默认值为<code>true</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">MyTextBox</span> <span class="attr">autocomplete</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">MyTextBox</span> <span class="attr">autocomplete</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span>;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="keyword">var</span> element1 = React.createElement(MyTextBox, &#123;</span><br><span class="line">  autocomplete: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="空白符"><a class="markdownIt-Anchor" href="#空白符"></a> 空白符</h2>
<p>在JSX中：</p>
<ul>
<li>每行首尾的空白符会被删除。</li>
<li>空行也会被删除。</li>
<li>标签旁边的相邻的新行被删除。</li>
<li>出现在字符串字面值中间的新行将被压缩为一个空格。</li>
</ul>
<p>因此下面四种写法最终结果都是一样的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">&lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello</span><br><span class="line">  World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="子元素"><a class="markdownIt-Anchor" href="#子元素"></a> 子元素</h2>
<p>一个JSX元素的子元素可以是另一个JSX元素、字符串字面值、任何插值结果。<br />
这些子元素会被作为<code>createElement</code>的参数传递，从第三个参数开始。<br />
组件可以从<code>props.children</code>中接收到这些传递的参数（子元素）。<br />
尽管任何东西都可以作为子元素，但组件被渲染时必须确保它的子元素都是 React 可以理解的对象，另外，<code>false</code>、<code>true</code>、<code>null</code>、<code>undefined</code>是可以被 React 理解的对象，但它们不会渲染出任何内容。<br />
较长的JSX最好使用括号括起来，以避免JS自动插入分号导致的错误。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> element = (</span><br><span class="line">  &lt;MyContainer&gt;</span><br><span class="line">    aaa &#123;test&#125;</span><br><span class="line">    &lt;MyFirstComponent /&gt;</span><br><span class="line">    bb &#123;<span class="number">123</span>&#125; cc</span><br><span class="line">    &lt;MySecondComponent /&gt;</span><br><span class="line">    &#123;<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;&#125;</span><br><span class="line">  &lt;/MyContainer&gt;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="keyword">var</span> element = React.createElement(MyContainer, <span class="literal">null</span>, <span class="string">&quot;aaa &quot;</span>, test, React.createElement(MyFirstComponent, <span class="literal">null</span>), <span class="string">&quot;bb &quot;</span>, <span class="number">123</span>, <span class="string">&quot; cc&quot;</span>, React.createElement(MySecondComponent, <span class="literal">null</span>), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="组件-2"><a class="markdownIt-Anchor" href="#组件-2"></a> 组件</h1>
<p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。从概念上组件类似于 JavaScript 函数。它接受任意的入参（即 <code>props</code>），并返回用于描述页面展示内容的 React 元素。<br />
JSX中也可以使用自定义组件，例如<code>&lt;Counter /&gt;</code>，注意自定义组件名必须以大写开头，否则在解析时会将标签名作为字符串而不是引用传给<code>createElement</code>。</p>
<p>组件参数<code>props</code>是不可修改的对象，在JSX中，<code>props</code>就是写在组件元素上的HTML属性（<code>key</code>除外）<br />
组件返回的结果是以下类型之一：</p>
<ul>
<li>React 元素。通常通过 JSX 创建。</li>
<li>数组或 fragments。 使得渲染方法可以返回多个元素。</li>
<li>Portals。可以渲染子节点到不同的 DOM 子树中。</li>
<li>字符串或数值类型。它们在 DOM 中会被渲染为文本节点</li>
<li>布尔类型或 null。什么都不渲染（注意组件不能返回<code>undefined</code>，但子元素允许是<code>undefined</code>，表示不渲染）</li>
</ul>
<h2 id="函数组件-2"><a class="markdownIt-Anchor" href="#函数组件-2"></a> 函数组件</h2>
<p>接受一个参数<code>props</code>并返回一个上述类型之一的函数就是函数组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="class组件-2"><a class="markdownIt-Anchor" href="#class组件-2"></a> class组件</h2>
<p>通过以下五步将函数组件转成 class 组件：</p>
<ol>
<li>创建一个同名的 ES6 class，并且继承于 <code>React.Component</code>。</li>
<li>添加一个空的 <code>render()</code> 方法。</li>
<li>将函数体移动到 <code>render()</code> 方法之中。</li>
<li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</li>
<li>删除剩余的空函数声明。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="built_in">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是class组件与函数组件等价的用法。</p>
<p>与函数组件相比，class组件的优点是，相同DOM结点中渲染同一种React元素，只会有一个class组件的实例，所以它可以有状态和生命周期方法。</p>
<h3 id="状态-2"><a class="markdownIt-Anchor" href="#状态-2"></a> 状态</h3>
<p>class组件的状态保存在构造函数的<code>state</code>实例属性上。当状态发生变化时，React能够自动更新使用该组件的地方的输出结果。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="生命周期方法"><a class="markdownIt-Anchor" href="#生命周期方法"></a> 生命周期方法</h3>
<p>class组件中可以声明一些特殊方法，当组件挂载或卸载时就会去执行这些方法：<br />
<code>componentDidMount()</code>：在组件第一次被渲染到 DOM 中的时候执行。<br />
<code>componentWillUnmount()</code>：在DOM中的组件被删除的时候执行。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timerID = <span class="built_in">setInterval</span>(</span><br><span class="line">      () =&gt; <span class="built_in">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol>
<li>当 <code>&lt;Clock /&gt;</code> 被传给 <code>ReactDOM.render()</code>的时候，React 会去<code>new</code> Clock 组件的构造函数，创建出一个Clock组件的实例，它的<code>state</code>中设置了当前的时间<code>date</code>。</li>
<li>之后 React 会调用组件的 <code>render()</code> 方法，这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 Clock 渲染的输出。</li>
<li>当 Clock 的的输出被插入到 DOM 中后，React 就会调用 <code>ComponentDidMount()</code> 生命周期方法。在这个方法中，Clock 组件向浏览器请求设置一个计时器来每秒调用一次组件的 <code>tick()</code> 方法。</li>
<li>浏览器每秒都会调用一次 <code>tick()</code> 方法。 在这方法之中，Clock 组件会通过调用 <code>setState()</code> 来计划进行一次 UI 更新。得益于 <code>setState()</code> 的调用，React 能够知道 <code>state</code> 已经改变了，然后会重新调用 <code>render()</code> 方法来确定页面上该显示什么。这一次，<code>render()</code> 方法中的 <code>this.state.date</code> 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM。</li>
<li>一旦 Clock 组件从 DOM 中被移除，React 就会调用 <code>componentWillUnmount()</code> 生命周期方法，这样计时器就停止了。</li>
</ol>
<h3 id="更新状态"><a class="markdownIt-Anchor" href="#更新状态"></a> 更新状态</h3>
<p>和Vue不同，<code>state</code>实例属性只是一个普通对象，而不是被监听的对象，直接修改它的属性值不会重新渲染组件，除非调用<code>this.forceUpdate()</code>进行强制更新。<br />
正确更新状态的方法是使用<code>this.setState(updater, [callback])</code></p>
<ol>
<li><code>updater</code>可以是一个对象，<code>this.setState</code>会将<code>updater</code>浅层合并到新的<code>state</code>中。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.quantity + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>updater</code>也可以是一个<code>(state, props)=&gt;stateChange</code>形式的函数。其中<code>state</code>和<code>props</code>是最新的状态和属性，不应该直接修改它们，而应该基于它们返回一个表示要更新内容的新对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">counter</span>: state.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>callback</code>是可选的回调函数，它会在<code>setstate</code>完成合并并重新渲染组件后执行。通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式。</li>
</ol>
<p>由于<code>setState</code>会将更新对象的内容合并到当前<code>state</code>，因此即便某个状态是一个数组，也不能直接用<code>push</code>等方法修改状态，而应该创建一个新数组赋给更新对象。</p>
<p><code>setState</code>会<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973">按照调用顺序</a>进行更新，但更新有时是立刻执行的（同步的），有时是批量推迟执行的（异步的，但没有使用setTimeout或nextTick等系统异步调度函数，而是自己维护一个队列，在其他函数里根据队列进行更新）。</p>
<ul>
<li>如果更新是由React事件处理程序触发的，则这些<code>setState</code>会将更改放入队列，然后在事件结束前批量处理，而且由于是将更新对象合并，对同一个状态多次更新，最后一次会覆盖前面的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设state.quantity = 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>
<p>因此上面的例子中，调用<code>setState</code>后立即查看状态不会看到状态的更新。同一状态后一次的更新也会覆盖前面的，在事件结束前<code>quantity</code>最终被更新为<code>1</code>。<br />
要想每次更新都基于最新的状态，需要使用函数形式的<code>updater</code>，<code>updater</code>接受的参数<code>state</code>保证是最新的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState( <span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;<span class="attr">quantity</span>: state.quantity + <span class="number">1</span>&#125;) );</span><br><span class="line"><span class="built_in">this</span>.setState( <span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;<span class="attr">quantity</span>: state.quantity + <span class="number">1</span>&#125;) );</span><br></pre></td></tr></table></figure>
<ul>
<li>如果更新不是由React事件处理程序触发的，那么<code>setState</code>的更新会被立刻处理，因为推迟更新依赖的是React事件处理流程中的某个函数在将来对这些更新进行处理，如果没有进入事件处理流程，那个进行更新的函数永远不会运行，因此只能立刻更新，否则就没有时机更新了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设state.quantity = 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
<p>关于<code>setState</code>为什么要被设计为异步的，参见<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">为什么setState是异步的？</a></p>
<p>最后还要注意，由于<code>render</code>被设计为一个纯函数，所以不要在<code>render</code>中更新状态。</p>
<h2 id="单向数据传递"><a class="markdownIt-Anchor" href="#单向数据传递"></a> 单向数据传递</h2>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。除了拥有并设置了<code>state</code>的组件，其他组件都无法访问<code>state</code>属性。<br />
组件可以选择把它的 <code>state</code> 作为 <code>props</code> 向下传递到它的子组件中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;<span class="built_in">this</span>.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>FormattedDate 组件会在其 <code>props</code> 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 Clock 的 <code>state</code>，或是 Clock 的 <code>props</code>，还是手动输入的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。<br />
如果把一个以组件构成的树想象成一个 <code>props</code> 的数据瀑布的话，那么每一个组件的 <code>state</code> 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p>
<h1 id="事件处理"><a class="markdownIt-Anchor" href="#事件处理"></a> 事件处理</h1>
<p>React 元素的事件处理和 DOM 元素很相似，但是有一点语法上的不同：</p>
<ul>
<li>React 事件的命名采用驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。因为插值部分会原封不动作为<code>func</code>，在React内部通过<code>func.apply(context, funcArgs)</code>调用。</li>
</ul>
<p>你可能会想，如果我不用React事件，只用原生事件，是不是就不用理会上面的区别，例如事件名不用驼峰式？<br />
答案是：不能。在React中你创建的所有元素都是React元素，并不是原生元素，因此你在React元素上书写<code>oninput</code>等原生事件名，React是无法理解的。</p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML事件名小写，值是函数调用字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;activateLasers()&quot;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- React事件名驼峰，值是函数对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外，在React中不能通过返回 <code>false</code> 的方式阻止默认行为。必须显式的使用 <code>preventDefault</code>。<br />
React事件处理程序接受的参数不是原生事件对象，而是React<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/events.html">合成事件</a>对象</p>
<h2 id="函数组件-3"><a class="markdownIt-Anchor" href="#函数组件-3"></a> 函数组件</h2>
<p>函数组件中的事件处理程序，只需写成函数组件中的嵌套函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">&quot;#&quot;</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="class组件-3"><a class="markdownIt-Anchor" href="#class组件-3"></a> class组件</h2>
<p>class组件中的事件处理程序，通常的是声明为 class 中的方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isToggleOn ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>和函数组件不同，class组件的事件处理程序中经常要读取或设置状态，这不可避免的用到<code>this</code>。然而触发事件时，React内部会通过<code>func.apply(context, funcArgs)</code>调用我们的事件处理函数<code>func</code>，这里<code>context</code>永远（？）是<code>undefined</code>，因此在我们的函数中<code>this</code>变成了<code>undefined</code>，也就无法通过<code>this.state</code>读取到组件的状态。</p>
<p>要解决这个问题，可以使用<code>bind</code>或箭头函数：</p>
<ol>
<li>在<code>render()</code>方法内，使用<code>bind</code>绑定<code>this</code>，缺点是每次重新渲染组件调用<code>render()</code>时都会重新创建一个<code>bind</code>过的函数。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)</span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在构造函数内，创建一个与事件处理程序同名的实例属性，为其赋予<code>bind</code>绑定过<code>this</code>的事件处理程序。缺点是已经定义了方法还不够，必须记得在构造函数中绑定一遍。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="built_in">this</span>.handleClick <span class="comment">// 调用的是实例方法而不是原型方法</span></span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>render()</code>方法内，使用箭头函数包装对事件处理程序的调用，触发事件时，被调用的是这个箭头函数，箭头函数内才执行了我们的事件处理程序。箭头函数内的<code>this</code>是定义箭头函数时包围它的词法作用域的<code>this</code>，也就是调用<code>instance.render()</code>时的<code>instance</code>实例对象，因此我们的事件处理程序会有正确的<code>this</code>。缺点是每次重新渲染组件调用<code>render()</code>时都会重新创建一个箭头函数。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="function">()=&gt;</span><span class="built_in">this</span>.handleClick()&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()</span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在构造函数中，使用箭头函数定义一个实例方法。触发事件时，被调用的是这个箭头函数，箭头函数内才执行了我们的事件处理程序。箭头函数内的<code>this</code>是定义箭头函数时包围它的词法作用域的<code>this</code>，也就是构造函数中的<code>this</code>，因此我们的事件处理程序会有正确的<code>this</code>。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="built_in">this</span>.handleClick <span class="comment">// 调用的是实例方法而不是原型方法</span></span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不想把方法定义写在构造函数内部，而想和其他类方法对齐，可以使用 TC39 的实验性语法：类字段。Babel支持这种语法。<br />
这种语法等价于在构造函数中使用<code>Object.defineProperty</code>，因此它定义的仍然是实例方法，而不是原型方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实验性语法</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">&#125;</span><br><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    isToggleOn: !state.isToggleOn</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;handleClick&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传递额外的参数"><a class="markdownIt-Anchor" href="#传递额外的参数"></a> 传递额外的参数</h2>
<p>事件触发时，我们的事件处理程序<code>func</code>被React通过<code>func.apply(context, funcArgs)</code>调用。其中<code>funcArgs</code>数组只有一个元素，就是合成事件对象。<br />
在几乎所有情况下，事件处理程序要用到的信息都在<code>this</code>上，而不会在<code>render()</code>函数里，因为<code>render()</code>函数能拿到的数据也是从<code>this</code>中得到的。因此基本上不需要传递额外的参数。</p>
<p>如果你一定要在<code>render()</code>调用时为事件处理程序传递参数，而不是让事件处理程序自己从<code>this</code>中获取，那么你只能每次在<code>render()</code>中创建一个新函数，可以是一个使用<code>bind</code>绑定额外参数的函数，也可以是一个内部手动调用事件处理程序的箭头函数。例如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.deleteRow(id, e) &#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123; <span class="built_in">this</span>.deleteRow.bind(<span class="built_in">this</span>, id) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>如果你在构造函数中使用<code>bind</code>绑定了<code>this</code>，这里仍然需要创建新函数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="built_in">this</span>.deleteRow.bind(id) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>如果你在构造函数中定义了一个持有箭头函数的实例属性，它无法传递额外参数。你可能会在<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52788613/react-js-the-most-efficient-way-to-pass-a-parameter-to-an-event-handler-without">stackoverflow</a>上看到这样的写法：将类字段写成一个箭头函数，该箭头函数又返回一个箭头函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">(<span class="params">param1, param2</span>) =&gt;</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里可以使用this以及各种参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(param1, param2, <span class="built_in">this</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123; <span class="built_in">this</span>.handleClick(param1, param2) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>尽管作者自以为这样的写法，每次<code>render()</code>时不会创建新函数，但实际并非如此。<br />
外层的箭头函数<code>this.handleClick</code>确实不会重新创建，但每次渲染都会被调用，而调用的结果就是创建了新的箭头函数<code>(e)=&gt;&#123;&#125;</code>并返回。因此这种写法和下面没什么不同。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(param1, param2, e) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h1 id="条件渲染-2"><a class="markdownIt-Anchor" href="#条件渲染-2"></a> 条件渲染</h1>
<h2 id="使用if语句"><a class="markdownIt-Anchor" href="#使用if语句"></a> 使用if语句</h2>
<p>在父组件中根据<code>if</code>条件语句的结果返回不同的组件，一般会将不同渲染结果拆分成函数组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123; <span class="comment">// 根据条件返回不同的组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null不渲染</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;warning&quot;</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;<span class="literal">false</span>&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="内联条件渲染"><a class="markdownIt-Anchor" href="#内联条件渲染"></a> 内联条件渲染</h2>
<p>如果想使用更简洁的语法进行条件渲染，可以使用JSX的插值语法</p>
<ol>
<li>如果满足所有条件，则渲染：<br />
<code>&#123;condition &amp;&amp; JSX&#125;</code><br />
<code>&#123;cond1 &amp;&amp; cond2 &amp;&amp; cond3 &amp;&amp; JSX&#125;</code><br />
这个插值表达式，当<code>condition</code>为<code>true</code>时返回<code>JSX</code>，当<code>condition</code>为<code>false</code>时返回<code>false</code>。对于<code>false</code>子元素，React是不会渲染的。由于逻辑与运算符是左结合的，因此多个条件联立时不需要加括号。</li>
<li>如果满足条件，则渲染A，否则渲染B：<br />
<code>&#123;condition ? JSXA : JSXB&#125;</code></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello! &#123;props.isLogin ? props.user : <span class="string">&#x27;Guest&#x27;</span>&#125; &lt;/h1&gt;</span><br><span class="line">      &#123;props.isLogin &amp;&amp; props.user.unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="列表渲染-2"><a class="markdownIt-Anchor" href="#列表渲染-2"></a> 列表渲染</h1>
<p>一个常见的需求是根据数组中的数据渲染出对应的元素。<br />
<code>render()</code>可以返回一个数组，而JSX插值表达式中也可以是一个数组。<br />
通过数组的<code>map</code>方法，我们可以根据每个数组元素生成一个JSX元素。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;numbers.map( <span class="function">(<span class="params">num</span>)=&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>) &#125;&lt;/ul&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意，当渲染对象是一个数组时，数组中的每个JSX元素必须具有<code>key</code>属性，否则会有一个警告<code>Warning: Each child in a list should have a unique &quot;key&quot; prop</code>。因此正确的写法应该是：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;numbers.map( <span class="function">(<span class="params">num</span>)=&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;num.toString()&#125;</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>) &#125;&lt;/ul&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React 在进行渲染时，出于效率考量，会比较之前的DOM与本次要渲染的DOM之间的差异，然后将旧DOM修改为新DOM，而不是简单的清空旧的完全重新渲染新的。<br />
在比较差异时，最简单的思路就是逐个比较，例如一个元素的子元素发生了变化，那么就比较 旧子元素1-新子元素1、旧子元素2-新子元素2。<br />
通常这没什么问题，但如果子元素是基于数组渲染的，同时新的DOM中在结尾以外的位置添加或删除了元素，那么这种基于索引的逐个比较效率就很低，因为绝大部分元素是没有变化的，不需要修改，改变的只是位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 --- arr4 不同，需修改</span><br><span class="line">arr2 --- arr1 不同，需修改</span><br><span class="line">arr3 --- arr2 不同，需修改</span><br><span class="line">     --- arr3 不同，需添加</span><br></pre></td></tr></table></figure>
<p>如果我们为每一个元素赋予一个唯一标识符，那么在比较的时候就可以基于唯一标识，而不是索引来比较。在下面的例子中，两次DOM中<code>key</code>为1、2、3的元素很容易知道没有发生拜年话，<code>key</code>为4的元素不存在，需要添加。此时就只有1处差异，而不是之前按索引比较时的4处差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1[key&#x3D;&quot;1&quot;] arr4[key&#x3D;&quot;4&quot;]</span><br><span class="line">arr2[key&#x3D;&quot;2&quot;] arr1[key&#x3D;&quot;1&quot;]</span><br><span class="line">arr3[key&#x3D;&quot;3&quot;] arr2[key&#x3D;&quot;2&quot;]</span><br><span class="line">              arr3[key&#x3D;&quot;3&quot;]</span><br></pre></td></tr></table></figure>
<p><code>key</code>属性帮助 React 识别哪些元素改变了，比如被添加或删除。一个元素的 <code>key</code> 最好是这个元素在列表中拥有的一个独一无二的字符串。不要使用索引作为<code>key</code>，因为这和没有<code>key</code>的效果是一样的。<br />
由于<code>key</code> 用于兄弟元素之间的比较，因此<code>key</code>在兄弟结点之间必须唯一，但不同父元素内的结点可以有相同的<code>key</code>，因为不同父元素的两个结点不会被比较。</p>
<p>总之，<code>map()</code> 方法生成的元素需要设置 <code>key</code> 属性。<code>key</code>属性不会被放在<code>props</code>中传给组件，因为它是给React使用的内部数据，如果你想要获取<code>key</code>属性，可以使用其他名字来传递属性。</p>
<h1 id="表单"><a class="markdownIt-Anchor" href="#表单"></a> 表单</h1>
<p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）通常自己维护 状态，并根据用户输入进行更新。例如在你输入内容时，元素的<code>value</code>属性也被同步更新，反之也一样。<br />
而在 React 中，可变状态（mutable state）通常保存在组件的 <code>state</code> 属性中，并且只能通过使用 <code>setState()</code>来更新。<br />
我们可以把两者结合起来，使 React 的 <code>state</code> 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。<br />
实现受控组件的方法，就是在表单控件上通过<code>onChange</code>事件获取控件传递给组件的新值（只是传递，控件内部值没有变化），然后通过<code>value</code>属性为控件设置新值。</p>
<h2 id="单行输入框"><a class="markdownIt-Anchor" href="#单行输入框"></a> 单行输入框</h2>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">str</span>: <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      str: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;<span class="built_in">this</span>.handleInputChange&#125; value=&#123;<span class="built_in">this</span>.state.str&#125; /&gt;</span><br><span class="line">        &lt;p&gt;You input: &#123;<span class="built_in">this</span>.state.str&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会对在<code>&lt;input type=&quot;text&quot;&gt;</code>上使用<code>onChange</code>事件感到奇怪，因为原生HTML元素中，我们通常使用<code>oninput</code>监听输入，而<code>oninput</code>和<code>onchange</code>效果是不同的。<br />
尽管<code>&lt;input type=&quot;text&quot;&gt;</code>看上去像HTML元素，但在React中实际上它是React元素而非原生HTML元素，对于文本输入框，React中的<code>onChange</code>事件实际上会被处理为监听原生的<code>input</code>事件。</p>
<h2 id="多行输入框"><a class="markdownIt-Anchor" href="#多行输入框"></a> 多行输入框</h2>
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<p>React两个文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span> <span class="comment">// 将react虚拟DOM绘制到浏览器DOM中</span></span><br><span class="line"><span class="keyword">import</span> ReactCanvas <span class="keyword">from</span> <span class="string">&#x27;react-canvas&#x27;</span> <span class="comment">// 将react虚拟DOM绘制到canvas标签</span></span><br><span class="line"><span class="keyword">import</span> ReactNative <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span> <span class="comment">// 将react虚拟DOM绘制到安卓或IOS系统的软件</span></span><br></pre></td></tr></table></figure>
<p>Babel可以查看JSX编译的结果，也可以找到一些新语法的兼容实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="comment">// 数据放在state对象里</span></span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.dec = <span class="built_in">this</span>.dec.bind(<span class="built_in">this</span>); <span class="comment">// 基于原型创建绑定的实例方法</span></span><br><span class="line">    <span class="built_in">this</span>.inc2 = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="built_in">this</span>.state.count - <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 优先，会自动更新</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="comment">// 这个对象会被Object.assign到state</span></span><br><span class="line">      count: <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 不自动更新，必须强制更新</span></span><br><span class="line">    <span class="built_in">this</span>.state.count--;</span><br><span class="line">    <span class="built_in">this</span>.forceUpdate();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getSpan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 第二种办法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; this.state.count &#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// button的onclick接收到的是函数，没有this上下文</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.dec&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &#123; <span class="built_in">this</span>.getSpan() &#125; <span class="comment">// 第二种办法</span></span><br><span class="line">      &lt;span&gt;&#123; <span class="built_in">this</span>.state.count &#125; &lt;/span&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.inc&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      <span class="comment">// 第三种办法：箭头函数 不推荐，每次创建新函数</span></span><br><span class="line">      &lt;button onClick=&#123;<span class="function">()=&gt;</span><span class="built_in">this</span>.inc()&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.inc.bind(<span class="built_in">this</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> a = React.createElement(Counter, <span class="literal">null</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>大写的标签名会被认为是变量名，因此自定义标签必须大写<br />
<a target="_blank" rel="noopener" href="http://www.hackingwithreact.com/read/1/9/handling-events-with-jsx-onclick">http://www.hackingwithreact.com/read/1/9/handling-events-with-jsx-onclick</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  inc = <span class="function">() =&gt;</span> &#123; <span class="comment">// 这是什么类语法？ES6不是只能方法定义吗？</span></span><br><span class="line">  <span class="comment">// TC39 实验性方法，自CHROME 74支持</span></span><br><span class="line">  <span class="comment">// https://github.com/tc39/proposal-class-fields</span></span><br><span class="line">  <span class="comment">// 相对于在构造函数内Object.defineProperty</span></span><br><span class="line">  	<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="built_in">this</span>.state.count - <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="built_in">this</span>.inc&#125;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="built_in">this</span>.dec&#125;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 调用render()时this确定，但this.dec拿到的是函数对象，onClick调用时的this取决于左值引用。a.onClick</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      onClick: <span class="built_in">this</span>.dec</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="备用"><a class="markdownIt-Anchor" href="#备用"></a> 备用</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line">    children: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<p>要将一个React元素渲染为DOM，需要使用<code>ReactDOM.render(element, container[, callback])</code>方法，<code>element</code>是要被渲染的元素，<code>container</code>是DOM中的容器元素，被渲染的元素会作为容器元素的子结点，可选的<code>callback</code>是组件被渲染或更新之后被执行的回调函数。例如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>ReactDOM.render</code>。例如下面的例子中，每秒创建一个新的React元素然后调用<code>ReactDOM.render</code>进行渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>React DOM 并不是简单的将容器元素清空然后重新添加元素，它会将本次渲染元素的状态和之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<p>多个控件共用一个事件处理函数，表单控件本来就有name属性，可以用它来区分。<br />
自己添加的属性是没用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      isGoing: <span class="literal">true</span>,</span><br><span class="line">      numberOfGuests: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.handleInputChange = <span class="built_in">this</span>.handleInputChange.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> target = event.target;</span><br><span class="line">    <span class="keyword">const</span> value = target.type === <span class="string">&#x27;checkbox&#x27;</span> ? target.checked : target.value;</span><br><span class="line">    <span class="keyword">const</span> name = target.name;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          参与:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">&quot;isGoing&quot;</span></span><br><span class="line">            type=<span class="string">&quot;checkbox&quot;</span></span><br><span class="line">            checked=&#123;<span class="built_in">this</span>.state.isGoing&#125;</span><br><span class="line">            onChange=&#123;<span class="built_in">this</span>.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          来宾人数:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">&quot;numberOfGuests&quot;</span></span><br><span class="line">            type=<span class="string">&quot;number&quot;</span></span><br><span class="line">            value=&#123;<span class="built_in">this</span>.state.numberOfGuests&#125;</span><br><span class="line">            onChange=&#123;<span class="built_in">this</span>.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 Formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。<br />
<a target="_blank" rel="noopener" href="https://jaredpalmer.com/formik">https://jaredpalmer.com/formik</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/前端/React.html">https://rcocco.github.io/categories/计算机/前端/React.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/Vue-Router.html"><i class="fa fa-chevron-left">  </i><span>Vue-Router</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/bootstrap.html"><span>bootstrap</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>