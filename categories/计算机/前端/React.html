<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="React"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>React | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jsx"><span class="toc-number">1.</span> <span class="toc-text"> JSX</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.</span> <span class="toc-text"> 元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">1.2.</span> <span class="toc-text"> 插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text"> 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E7%99%BD%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text"> 空白符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.</span> <span class="toc-text"> 子元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E5%85%83%E7%B4%A0"><span class="toc-number">2.</span> <span class="toc-text"> React元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text"> 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text"> 函数组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text"> class组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 生命周期方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 更新状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.</span> <span class="toc-text"> 单向数据传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-2"><span class="toc-number">4.1.</span> <span class="toc-text"> 函数组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E7%BB%84%E4%BB%B6-2"><span class="toc-number">4.2.</span> <span class="toc-text"> class组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E9%A2%9D%E5%A4%96%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text"> 传递额外的参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">5.</span> <span class="toc-text"> 条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8if%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.</span> <span class="toc-text"> 使用if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">5.2.</span> <span class="toc-text"> 内联条件渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-number">6.</span> <span class="toc-text"> 列表渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">7.</span> <span class="toc-text"> 表单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E8%BE%93%E5%85%A5%E6%A1%86"><span class="toc-number">7.1.</span> <span class="toc-text"> 单行输入框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E8%BE%93%E5%85%A5%E6%A1%86"><span class="toc-number">7.2.</span> <span class="toc-text"> 多行输入框</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">8.</span> <span class="toc-text"> 其他</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">175</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">React</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/">前端</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="jsx"><a class="markdownIt-Anchor" href="#jsx"></a> JSX</h1>
<p>JSX是JavaScript的语法扩展，可以将创建React元素的函数调用，写成类似HTML代码的样子。<br />
每个 JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖。<code>component</code>是字符串或者自定义元素的构造函数，<code>props</code>对象包括元素上的属性以及值，<code>children</code>是所有的子元素。<br />
因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成，可以在<a target="_blank" rel="noopener" href="https://babeljs.io/repl">Babel官网</a>看到这种转换。</p>
<span id="more"></span>
<h2 id="元素"><a class="markdownIt-Anchor" href="#元素"></a> 元素</h2>
<p>小写开头的HTML标签，以及使用引号括起来的HTML属性值，会作为字符串传给函数。<br />
大写开头的HTML标签，会被当做标识符（变量）引用传给函数。<br />
JSX中把所有连字符的HTML属性名都变成了驼峰命名。<br />
JSX还要求所有自闭合标签手动闭合，例如<code>&lt;Counter /&gt;</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element3 = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> Obj = &#123; <span class="attr">a</span>: Counter &#125;;</span><br><span class="line"><span class="keyword">var</span> element4 = <span class="xml"><span class="tag">&lt;<span class="name">Obj.a</span> /&gt;</span></span>;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="keyword">var</span> element1 = React.createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> element2 = React.createElement(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">tabIndex</span>: <span class="string">&quot;0&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> element3 = React.createElement(Counter, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> element4 = React.createElement(Obj.a, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>尽管为<code>createElement</code>传递了自定义组件的构造函数，但此时并不会去实例化该类，而是在<code>RecatDOM.render</code>时才会去<code>new</code>你的类。</p>
<h2 id="插值"><a class="markdownIt-Anchor" href="#插值"></a> 插值</h2>
<p>JSX中可以使用<code>&#123;表达式&#125;</code>进行插值，它既可以用在元素的文本部分，也可以用在元素的属性值部分。<code>&#123;&#125;</code>中间的部分会原封不动的作为创建元素时的函数参数。<br />
文本插值的内容在渲染前会被转义，以避免XSS攻击。<br />
由于JSX元素也是一个表达式，因此<code>&#123;&lt;h1&gt;Hello&lt;/h1&gt;&#125;</code>也是合法的插值内容，尽管这个中括号没什么必要。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;2+2&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element3 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element4 = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="keyword">var</span> element1 = React.createElement(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello, &quot;</span>, name);</span><br><span class="line"><span class="keyword">var</span> element2 = React.createElement(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello, &quot;</span>, <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> element3 = React.createElement(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello, &quot;</span>, formatName(user));</span><br><span class="line"><span class="keyword">var</span> element4 = React.createElement(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">  src: user.avatarUrl</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对于属性值，在JSX中<code>src=&quot;a.jpg&quot;</code>等价于<code>src=&#123;&quot;a.jpg&quot;&#125;</code>，另外，如果有HTML实体，那么<code>src=&quot;&amp;lt;3&quot;</code>也等价于<code>src=&quot;&lt;3&quot;</code></p>
<h2 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h2>
<p>如果没有给元素属性赋值，那么它的默认值为<code>true</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">MyTextBox</span> <span class="attr">autocomplete</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">MyTextBox</span> <span class="attr">autocomplete</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span>;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="keyword">var</span> element1 = React.createElement(MyTextBox, &#123;</span><br><span class="line">  autocomplete: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了直接用<code>属性名=属性值</code>的语法书写属性，也可以使用<code>&#123;...obj&#125;</code>语法，将对象<code>obj</code>中的属性与值作为元素的属性与值。你只能以这种语法展开对象，直接书写对象字面值是非法的。<br />
需要注意的是，当混用两种语法时候，它会使用<code>Object.assign</code>将各个属性合并，同名属性写在后面的会覆盖前面的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> prop = &#123;<span class="attr">d</span>: <span class="number">4</span>, <span class="attr">e</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> &#123;<span class="attr">...obj</span>&#125; /&gt;</span></span>;</span><br><span class="line"><span class="keyword">var</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">a</span>=<span class="string">&quot;A&quot;</span> &#123;<span class="attr">...obj</span>&#125;  <span class="attr">c</span>=<span class="string">&quot;C&quot;</span> &#123;<span class="attr">...prop</span>&#125; /&gt;</span></span>;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="keyword">var</span> element1 = React.createElement(Greeting, obj);</span><br><span class="line"><span class="keyword">var</span> element2 = React.createElement(Greeting, <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">  a: <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;, obj, &#123;</span><br><span class="line">  c: <span class="string">&quot;C&quot;</span></span><br><span class="line">&#125;, prop));</span><br></pre></td></tr></table></figure>
<h2 id="空白符"><a class="markdownIt-Anchor" href="#空白符"></a> 空白符</h2>
<p>在JSX中：</p>
<ul>
<li>每行首尾的空白符会被删除。</li>
<li>空行也会被删除。</li>
<li>标签旁边的相邻的新行被删除。</li>
<li>出现在字符串字面值中间的新行将被压缩为一个空格。</li>
</ul>
<p>因此下面四种写法最终结果都是一样的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">&lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello</span><br><span class="line">  World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="子元素"><a class="markdownIt-Anchor" href="#子元素"></a> 子元素</h2>
<p>一个JSX元素的子元素可以是另一个JSX元素、字符串字面值、任何插值结果。<br />
这些子元素会被作为<code>createElement</code>的参数传递，从第三个参数开始。<br />
组件可以从<code>props.children</code>中接收到这些传递的参数（子元素）。<br />
尽管任何东西都可以作为子元素，但组件被渲染时必须确保它的子元素都是 React 可以理解的对象，另外，<code>false</code>、<code>true</code>、<code>null</code>、<code>undefined</code>是可以被 React 理解的对象，但它们不会渲染出任何内容。<br />
较长的JSX最好使用括号括起来，以避免JS自动插入分号导致的错误。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> element = (</span><br><span class="line">  &lt;MyContainer&gt;</span><br><span class="line">    aaa &#123;test&#125;</span><br><span class="line">    &lt;MyFirstComponent /&gt;</span><br><span class="line">    bb &#123;<span class="number">123</span>&#125; cc</span><br><span class="line">    &lt;MySecondComponent /&gt;</span><br><span class="line">    &#123;<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">5</span>)&#125;&#125;</span><br><span class="line">  &lt;/MyContainer&gt;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="keyword">var</span> element = React.createElement(MyContainer, <span class="literal">null</span>, <span class="string">&quot;aaa &quot;</span>, test, React.createElement(MyFirstComponent, <span class="literal">null</span>), <span class="string">&quot;bb &quot;</span>, <span class="number">123</span>, <span class="string">&quot; cc&quot;</span>, React.createElement(MySecondComponent, <span class="literal">null</span>), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="react元素"><a class="markdownIt-Anchor" href="#react元素"></a> React元素</h1>
<p><code>createElement</code>创建的 React 元素是创建开销极小的普通对象。它类似于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这是简化过的结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line">    children: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<p>要将一个React元素渲染为DOM，需要使用<code>ReactDOM.render(element, container[, callback])</code>方法，<code>element</code>是要被渲染的元素，<code>container</code>是DOM中的容器元素，被渲染的元素会作为容器元素的子结点，可选的<code>callback</code>是组件被渲染或更新之后被执行的回调函数。例如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>ReactDOM.render</code>。例如下面的例子中，每秒创建一个新的React元素然后调用<code>ReactDOM.render</code>进行渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>React DOM 并不是简单的将容器元素清空然后重新添加元素，它会将本次渲染元素的状态和之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<h1 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h1>
<p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。从概念上组件类似于 JavaScript 函数。它接受任意的入参（即 <code>props</code>），并返回用于描述页面展示内容的 React 元素。<br />
JSX中也可以使用自定义组件，例如<code>&lt;Counter /&gt;</code>，注意自定义组件名必须以大写开头，否则在解析时会将标签名作为字符串而不是引用传给<code>createElement</code>。</p>
<p>组件参数<code>props</code>是不可修改的对象，在JSX中，<code>props</code>就是写在组件元素上的HTML属性（<code>key</code>除外）<br />
组件返回的结果是以下类型之一：</p>
<ul>
<li>React 元素。通常通过 JSX 创建。</li>
<li>数组或 fragments。 使得渲染方法可以返回多个元素。</li>
<li>Portals。可以渲染子节点到不同的 DOM 子树中。</li>
<li>字符串或数值类型。它们在 DOM 中会被渲染为文本节点</li>
<li>布尔类型或 null。什么都不渲染（注意组件不能返回<code>undefined</code>，但子元素允许是<code>undefined</code>，表示不渲染）</li>
</ul>
<h2 id="函数组件"><a class="markdownIt-Anchor" href="#函数组件"></a> 函数组件</h2>
<p>接受一个参数<code>props</code>并返回一个上述类型之一的函数就是函数组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="class组件"><a class="markdownIt-Anchor" href="#class组件"></a> class组件</h2>
<p>通过以下五步将函数组件转成 class 组件：</p>
<ol>
<li>创建一个同名的 ES6 class，并且继承于 <code>React.Component</code>。</li>
<li>添加一个空的 <code>render()</code> 方法。</li>
<li>将函数体移动到 <code>render()</code> 方法之中。</li>
<li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</li>
<li>删除剩余的空函数声明。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="built_in">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是class组件与函数组件等价的用法。</p>
<p>与函数组件相比，class组件的优点是，相同DOM结点中渲染同一种React元素，只会有一个class组件的实例，所以它可以有状态和生命周期方法。</p>
<h3 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h3>
<p>class组件的状态保存在构造函数的<code>state</code>实例属性上。当状态发生变化时，React能够自动更新使用该组件的地方的输出结果。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="生命周期方法"><a class="markdownIt-Anchor" href="#生命周期方法"></a> 生命周期方法</h3>
<p>class组件中可以声明一些特殊方法，当组件挂载或卸载时就会去执行这些方法：<br />
<code>componentDidMount()</code>：在组件第一次被渲染到 DOM 中的时候执行。<br />
<code>componentWillUnmount()</code>：在DOM中的组件被删除的时候执行。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timerID = <span class="built_in">setInterval</span>(</span><br><span class="line">      () =&gt; <span class="built_in">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol>
<li>当 <code>&lt;Clock /&gt;</code> 被传给 <code>ReactDOM.render()</code>的时候，React 会去<code>new</code> Clock 组件的构造函数，创建出一个Clock组件的实例，它的<code>state</code>中设置了当前的时间<code>date</code>。</li>
<li>之后 React 会调用组件的 <code>render()</code> 方法，这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 Clock 渲染的输出。</li>
<li>当 Clock 的的输出被插入到 DOM 中后，React 就会调用 <code>ComponentDidMount()</code> 生命周期方法。在这个方法中，Clock 组件向浏览器请求设置一个计时器来每秒调用一次组件的 <code>tick()</code> 方法。</li>
<li>浏览器每秒都会调用一次 <code>tick()</code> 方法。 在这方法之中，Clock 组件会通过调用 <code>setState()</code> 来计划进行一次 UI 更新。得益于 <code>setState()</code> 的调用，React 能够知道 <code>state</code> 已经改变了，然后会重新调用 <code>render()</code> 方法来确定页面上该显示什么。这一次，<code>render()</code> 方法中的 <code>this.state.date</code> 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM。</li>
<li>一旦 Clock 组件从 DOM 中被移除，React 就会调用 <code>componentWillUnmount()</code> 生命周期方法，这样计时器就停止了。</li>
</ol>
<h3 id="更新状态"><a class="markdownIt-Anchor" href="#更新状态"></a> 更新状态</h3>
<p>和Vue不同，<code>state</code>实例属性只是一个普通对象，而不是被监听的对象，直接修改它的属性值不会重新渲染组件，除非调用<code>this.forceUpdate()</code>进行强制更新。<br />
正确更新状态的方法是使用<code>this.setState(updater, [callback])</code></p>
<ol>
<li><code>updater</code>可以是一个对象，<code>this.setState</code>会将<code>updater</code>浅层合并到新的<code>state</code>中。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.quantity + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>updater</code>也可以是一个<code>(state, props)=&gt;stateChange</code>形式的函数。其中<code>state</code>和<code>props</code>是最新的状态和属性，不应该直接修改它们，而应该基于它们返回一个表示要更新内容的新对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">counter</span>: state.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>callback</code>是可选的回调函数，它会在<code>setstate</code>完成合并并重新渲染组件后执行。通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式。</li>
</ol>
<p>由于<code>setState</code>会将更新对象的内容合并到当前<code>state</code>，因此即便某个状态是一个数组，也不能直接用<code>push</code>等方法修改状态，而应该创建一个新数组赋给更新对象。</p>
<p><code>setState</code>会<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973">按照调用顺序</a>进行更新，但更新有时是立刻执行的（同步的），有时是批量推迟执行的（异步的，但没有使用setTimeout或nextTick等系统异步调度函数，而是自己维护一个队列，在其他函数里根据队列进行更新）。</p>
<ul>
<li>如果更新是由React事件处理程序触发的，则这些<code>setState</code>会将更改放入队列，然后在事件结束前批量处理，而且由于是将更新对象合并，对同一个状态多次更新，最后一次会覆盖前面的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设state.quantity = 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>
<p>因此上面的例子中，调用<code>setState</code>后立即查看状态不会看到状态的更新。同一状态后一次的更新也会覆盖前面的，在事件结束前<code>quantity</code>最终被更新为<code>1</code>。<br />
要想每次更新都基于最新的状态，需要使用函数形式的<code>updater</code>，<code>updater</code>接受的参数<code>state</code>保证是最新的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState( <span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;<span class="attr">quantity</span>: state.quantity + <span class="number">1</span>&#125;) );</span><br><span class="line"><span class="built_in">this</span>.setState( <span class="function">(<span class="params">state</span>)=&gt;</span>(&#123;<span class="attr">quantity</span>: state.quantity + <span class="number">1</span>&#125;) );</span><br></pre></td></tr></table></figure>
<ul>
<li>如果更新不是由React事件处理程序触发的，那么<code>setState</code>的更新会被立刻处理，因为推迟更新依赖的是React事件处理流程中的某个函数在将来对这些更新进行处理，如果没有进入事件处理流程，那个进行更新的函数永远不会运行，因此只能立刻更新，否则就没有时机更新了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设state.quantity = 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 0</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="built_in">this</span>.state.quantity + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.quantity); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
<p>关于<code>setState</code>为什么要被设计为异步的，参见<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">为什么setState是异步的？</a></p>
<p>最后还要注意，由于<code>render</code>被设计为一个纯函数，所以不要在<code>render</code>中更新状态。</p>
<h2 id="单向数据传递"><a class="markdownIt-Anchor" href="#单向数据传递"></a> 单向数据传递</h2>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。除了拥有并设置了<code>state</code>的组件，其他组件都无法访问<code>state</code>属性。<br />
组件可以选择把它的 <code>state</code> 作为 <code>props</code> 向下传递到它的子组件中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;<span class="built_in">this</span>.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>FormattedDate 组件会在其 <code>props</code> 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 Clock 的 <code>state</code>，或是 Clock 的 <code>props</code>，还是手动输入的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。<br />
如果把一个以组件构成的树想象成一个 <code>props</code> 的数据瀑布的话，那么每一个组件的 <code>state</code> 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p>
<h1 id="事件处理"><a class="markdownIt-Anchor" href="#事件处理"></a> 事件处理</h1>
<p>React 元素的事件处理和 DOM 元素很相似，但是有一点语法上的不同：</p>
<ul>
<li>React 事件的命名采用驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。因为插值部分会原封不动作为<code>func</code>，在React内部通过<code>func.apply(context, funcArgs)</code>调用。</li>
</ul>
<p>你可能会想，如果我不用React事件，只用原生事件，是不是就不用理会上面的区别，例如事件名不用驼峰式？<br />
答案是：不能。在React中你创建的所有元素都是React元素，并不是原生元素，因此你在React元素上书写<code>oninput</code>等原生事件名，React是无法理解的。</p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML事件名小写，值是函数调用字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;activateLasers()&quot;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- React事件名驼峰，值是函数对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外，在React中不能通过返回 <code>false</code> 的方式阻止默认行为。必须显式的使用 <code>preventDefault</code>。<br />
React事件处理程序接受的参数不是原生事件对象，而是React<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/events.html">合成事件</a>对象</p>
<h2 id="函数组件-2"><a class="markdownIt-Anchor" href="#函数组件-2"></a> 函数组件</h2>
<p>函数组件中的事件处理程序，只需写成函数组件中的嵌套函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">&quot;#&quot;</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="class组件-2"><a class="markdownIt-Anchor" href="#class组件-2"></a> class组件</h2>
<p>class组件中的事件处理程序，通常的是声明为 class 中的方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isToggleOn ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>和函数组件不同，class组件的事件处理程序中经常要读取或设置状态，这不可避免的用到<code>this</code>。然而触发事件时，React内部会通过<code>func.apply(context, funcArgs)</code>调用我们的事件处理函数<code>func</code>，这里<code>context</code>永远（？）是<code>undefined</code>，因此在我们的函数中<code>this</code>变成了<code>undefined</code>，也就无法通过<code>this.state</code>读取到组件的状态。</p>
<p>要解决这个问题，可以使用<code>bind</code>或箭头函数：</p>
<ol>
<li>在<code>render()</code>方法内，使用<code>bind</code>绑定<code>this</code>，缺点是每次重新渲染组件调用<code>render()</code>时都会重新创建一个<code>bind</code>过的函数。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)</span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在构造函数内，创建一个与事件处理程序同名的实例属性，为其赋予<code>bind</code>绑定过<code>this</code>的事件处理程序。缺点是已经定义了方法还不够，必须记得在构造函数中绑定一遍。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="built_in">this</span>.handleClick <span class="comment">// 调用的是实例方法而不是原型方法</span></span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>render()</code>方法内，使用箭头函数包装对事件处理程序的调用，触发事件时，被调用的是这个箭头函数，箭头函数内才执行了我们的事件处理程序。箭头函数内的<code>this</code>是定义箭头函数时包围它的词法作用域的<code>this</code>，也就是调用<code>instance.render()</code>时的<code>instance</code>实例对象，因此我们的事件处理程序会有正确的<code>this</code>。缺点是每次重新渲染组件调用<code>render()</code>时都会重新创建一个箭头函数。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="function">()=&gt;</span><span class="built_in">this</span>.handleClick()&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()</span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在构造函数中，使用箭头函数定义一个实例方法。触发事件时，被调用的是这个箭头函数，箭头函数内才执行了我们的事件处理程序。箭头函数内的<code>this</code>是定义箭头函数时包围它的词法作用域的<code>this</code>，也就是构造函数中的<code>this</code>，因此我们的事件处理程序会有正确的<code>this</code>。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯JS</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">    onClick: <span class="built_in">this</span>.handleClick <span class="comment">// 调用的是实例方法而不是原型方法</span></span><br><span class="line">  &#125;, <span class="string">&quot;Click&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不想把方法定义写在构造函数内部，而想和其他类方法对齐，可以使用 TC39 的实验性语法：类字段。Babel支持这种语法。<br />
这种语法等价于在构造函数中使用<code>Object.defineProperty</code>，因此它定义的仍然是实例方法，而不是原型方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实验性语法</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">&#125;</span><br><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    isToggleOn: !state.isToggleOn</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;handleClick&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传递额外的参数"><a class="markdownIt-Anchor" href="#传递额外的参数"></a> 传递额外的参数</h2>
<p>事件触发时，我们的事件处理程序<code>func</code>被React通过<code>func.apply(context, funcArgs)</code>调用。其中<code>funcArgs</code>数组只有一个元素，就是合成事件对象。<br />
在几乎所有情况下，事件处理程序要用到的信息都在<code>this</code>上，而不会在<code>render()</code>函数里，因为<code>render()</code>函数能拿到的数据也是从<code>this</code>中得到的。因此基本上不需要传递额外的参数。</p>
<p>如果你一定要在<code>render()</code>调用时为事件处理程序传递参数，而不是让事件处理程序自己从<code>this</code>中获取，那么你只能每次在<code>render()</code>中创建一个新函数，可以是一个使用<code>bind</code>绑定额外参数的函数，也可以是一个内部手动调用事件处理程序的箭头函数。例如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.deleteRow(id, e) &#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123; <span class="built_in">this</span>.deleteRow.bind(<span class="built_in">this</span>, id) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>如果你在构造函数中使用<code>bind</code>绑定了<code>this</code>，这里仍然需要创建新函数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="built_in">this</span>.deleteRow.bind(id) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>如果你在构造函数中定义了一个持有箭头函数的实例属性，它无法传递额外参数。你可能会在<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52788613/react-js-the-most-efficient-way-to-pass-a-parameter-to-an-event-handler-without">stackoverflow</a>上看到这样的写法：将类字段写成一个箭头函数，该箭头函数又返回一个箭头函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">(<span class="params">param1, param2</span>) =&gt;</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里可以使用this以及各种参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(param1, param2, <span class="built_in">this</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123; <span class="built_in">this</span>.handleClick(param1, param2) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>尽管作者自以为这样的写法，每次<code>render()</code>时不会创建新函数，但实际并非如此。<br />
外层的箭头函数<code>this.handleClick</code>确实不会重新创建，但每次渲染都会被调用，而调用的结果就是创建了新的箭头函数<code>(e)=&gt;&#123;&#125;</code>并返回。因此这种写法和下面没什么不同。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(param1, param2, e) &#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h1 id="条件渲染"><a class="markdownIt-Anchor" href="#条件渲染"></a> 条件渲染</h1>
<h2 id="使用if语句"><a class="markdownIt-Anchor" href="#使用if语句"></a> 使用if语句</h2>
<p>在父组件中根据<code>if</code>条件语句的结果返回不同的组件，一般会将不同渲染结果拆分成函数组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123; <span class="comment">// 根据条件返回不同的组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null不渲染</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;warning&quot;</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;<span class="literal">false</span>&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="内联条件渲染"><a class="markdownIt-Anchor" href="#内联条件渲染"></a> 内联条件渲染</h2>
<p>如果想使用更简洁的语法进行条件渲染，可以使用JSX的插值语法</p>
<ol>
<li>如果满足所有条件，则渲染：<br />
<code>&#123;condition &amp;&amp; JSX&#125;</code><br />
<code>&#123;cond1 &amp;&amp; cond2 &amp;&amp; cond3 &amp;&amp; JSX&#125;</code><br />
这个插值表达式，当<code>condition</code>为<code>true</code>时返回<code>JSX</code>，当<code>condition</code>为<code>false</code>时返回<code>false</code>。对于<code>false</code>子元素，React是不会渲染的。由于逻辑与运算符是左结合的，因此多个条件联立时不需要加括号。</li>
<li>如果满足条件，则渲染A，否则渲染B：<br />
<code>&#123;condition ? JSXA : JSXB&#125;</code></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello! &#123;props.isLogin ? props.user : <span class="string">&#x27;Guest&#x27;</span>&#125; &lt;/h1&gt;</span><br><span class="line">      &#123;props.isLogin &amp;&amp; props.user.unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="列表渲染"><a class="markdownIt-Anchor" href="#列表渲染"></a> 列表渲染</h1>
<p>一个常见的需求是根据数组中的数据渲染出对应的元素。<br />
<code>render()</code>可以返回一个数组，而JSX插值表达式中也可以是一个数组。<br />
通过数组的<code>map</code>方法，我们可以根据每个数组元素生成一个JSX元素。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;numbers.map( <span class="function">(<span class="params">num</span>)=&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>) &#125;&lt;/ul&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意，当渲染对象是一个数组时，数组中的每个JSX元素必须具有<code>key</code>属性，否则会有一个警告<code>Warning: Each child in a list should have a unique &quot;key&quot; prop</code>。因此正确的写法应该是：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;numbers.map( <span class="function">(<span class="params">num</span>)=&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;num.toString()&#125;</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>) &#125;&lt;/ul&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React 在进行渲染时，出于效率考量，会比较之前的DOM与本次要渲染的DOM之间的差异，然后将旧DOM修改为新DOM，而不是简单的清空旧的完全重新渲染新的。<br />
在比较差异时，最简单的思路就是逐个比较，例如一个元素的子元素发生了变化，那么就比较 旧子元素1-新子元素1、旧子元素2-新子元素2。<br />
通常这没什么问题，但如果子元素是基于数组渲染的，同时新的DOM中在结尾以外的位置添加或删除了元素，那么这种基于索引的逐个比较效率就很低，因为绝大部分元素是没有变化的，不需要修改，改变的只是位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 --- arr4 不同，需修改</span><br><span class="line">arr2 --- arr1 不同，需修改</span><br><span class="line">arr3 --- arr2 不同，需修改</span><br><span class="line">     --- arr3 不同，需添加</span><br></pre></td></tr></table></figure>
<p>如果我们为每一个元素赋予一个唯一标识符，那么在比较的时候就可以基于唯一标识，而不是索引来比较。在下面的例子中，两次DOM中<code>key</code>为1、2、3的元素很容易知道没有发生拜年话，<code>key</code>为4的元素不存在，需要添加。此时就只有1处差异，而不是之前按索引比较时的4处差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1[key&#x3D;&quot;1&quot;] arr4[key&#x3D;&quot;4&quot;]</span><br><span class="line">arr2[key&#x3D;&quot;2&quot;] arr1[key&#x3D;&quot;1&quot;]</span><br><span class="line">arr3[key&#x3D;&quot;3&quot;] arr2[key&#x3D;&quot;2&quot;]</span><br><span class="line">              arr3[key&#x3D;&quot;3&quot;]</span><br></pre></td></tr></table></figure>
<p><code>key</code>属性帮助 React 识别哪些元素改变了，比如被添加或删除。一个元素的 <code>key</code> 最好是这个元素在列表中拥有的一个独一无二的字符串。不要使用索引作为<code>key</code>，因为这和没有<code>key</code>的效果是一样的。<br />
由于<code>key</code> 用于兄弟元素之间的比较，因此<code>key</code>在兄弟结点之间必须唯一，但不同父元素内的结点可以有相同的<code>key</code>，因为不同父元素的两个结点不会被比较。</p>
<p>总之，<code>map()</code> 方法生成的元素需要设置 <code>key</code> 属性。<code>key</code>属性不会被放在<code>props</code>中传给组件，因为它是给React使用的内部数据，如果你想要获取<code>key</code>属性，可以使用其他名字来传递属性。</p>
<h1 id="表单"><a class="markdownIt-Anchor" href="#表单"></a> 表单</h1>
<p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）通常自己维护 状态，并根据用户输入进行更新。例如在你输入内容时，元素的<code>value</code>属性也被同步更新，反之也一样。<br />
而在 React 中，可变状态（mutable state）通常保存在组件的 <code>state</code> 属性中，并且只能通过使用 <code>setState()</code>来更新。<br />
我们可以把两者结合起来，使 React 的 <code>state</code> 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。<br />
实现受控组件的方法，就是在表单控件上通过<code>onChange</code>事件获取控件传递给组件的新值（只是传递，控件内部值没有变化），然后通过<code>value</code>属性为控件设置新值。</p>
<h2 id="单行输入框"><a class="markdownIt-Anchor" href="#单行输入框"></a> 单行输入框</h2>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">str</span>: <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      str: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;<span class="built_in">this</span>.handleInputChange&#125; value=&#123;<span class="built_in">this</span>.state.str&#125; /&gt;</span><br><span class="line">        &lt;p&gt;You input: &#123;<span class="built_in">this</span>.state.str&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会对在<code>&lt;input type=&quot;text&quot;&gt;</code>上使用<code>onChange</code>事件感到奇怪，因为原生HTML元素中，我们通常使用<code>oninput</code>监听输入，而<code>oninput</code>和<code>onchange</code>效果是不同的。<br />
尽管<code>&lt;input type=&quot;text&quot;&gt;</code>看上去像HTML元素，但在React中实际上它是React元素而非原生HTML元素，对于文本输入框，React中的<code>onChange</code>事件实际上会被处理为监听原生的<code>input</code>事件。</p>
<h2 id="多行输入框"><a class="markdownIt-Anchor" href="#多行输入框"></a> 多行输入框</h2>
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<p>React两个文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span> <span class="comment">// 将react虚拟DOM绘制到浏览器DOM中</span></span><br><span class="line"><span class="keyword">import</span> ReactCanvas <span class="keyword">from</span> <span class="string">&#x27;react-canvas&#x27;</span> <span class="comment">// 将react虚拟DOM绘制到canvas标签</span></span><br><span class="line"><span class="keyword">import</span> ReactNative <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span> <span class="comment">// 将react虚拟DOM绘制到安卓或IOS系统的软件</span></span><br></pre></td></tr></table></figure>
<p>Babel可以查看JSX编译的结果，也可以找到一些新语法的兼容实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="comment">// 数据放在state对象里</span></span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.dec = <span class="built_in">this</span>.dec.bind(<span class="built_in">this</span>); <span class="comment">// 基于原型创建绑定的实例方法</span></span><br><span class="line">    <span class="built_in">this</span>.inc2 = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="built_in">this</span>.state.count - <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 优先，会自动更新</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="comment">// 这个对象会被Object.assign到state</span></span><br><span class="line">      count: <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 不自动更新，必须强制更新</span></span><br><span class="line">    <span class="built_in">this</span>.state.count--;</span><br><span class="line">    <span class="built_in">this</span>.forceUpdate();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getSpan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 第二种办法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; this.state.count &#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// button的onclick接收到的是函数，没有this上下文</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.dec&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &#123; <span class="built_in">this</span>.getSpan() &#125; <span class="comment">// 第二种办法</span></span><br><span class="line">      &lt;span&gt;&#123; <span class="built_in">this</span>.state.count &#125; &lt;/span&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.inc&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      <span class="comment">// 第三种办法：箭头函数 不推荐，每次创建新函数</span></span><br><span class="line">      &lt;button onClick=&#123;<span class="function">()=&gt;</span><span class="built_in">this</span>.inc()&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.inc.bind(<span class="built_in">this</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> a = React.createElement(Counter, <span class="literal">null</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>大写的标签名会被认为是变量名，因此自定义标签必须大写<br />
<a target="_blank" rel="noopener" href="http://www.hackingwithreact.com/read/1/9/handling-events-with-jsx-onclick">http://www.hackingwithreact.com/read/1/9/handling-events-with-jsx-onclick</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  inc = <span class="function">() =&gt;</span> &#123; <span class="comment">// 这是什么类语法？ES6不是只能方法定义吗？</span></span><br><span class="line">  <span class="comment">// TC39 实验性方法，自CHROME 74支持</span></span><br><span class="line">  <span class="comment">// https://github.com/tc39/proposal-class-fields</span></span><br><span class="line">  <span class="comment">// 相对于在构造函数内Object.defineProperty</span></span><br><span class="line">  	<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="built_in">this</span>.state.count - <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="built_in">this</span>.inc&#125;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="built_in">this</span>.dec&#125;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 调用render()时this确定，但this.dec拿到的是函数对象，onClick调用时的this取决于左值引用。a.onClick</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      onClick: <span class="built_in">this</span>.dec</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/前端/React.html">https://rcocco.github.io/categories/计算机/前端/React.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/Vue-Router.html"><i class="fa fa-chevron-left">  </i><span>Vue-Router</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/bootstrap.html"><span>bootstrap</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>