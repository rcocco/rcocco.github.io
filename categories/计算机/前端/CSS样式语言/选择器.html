<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="选择器"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>选择器 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text"> 选择器结构和术语</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text"> 简单选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text"> 组合选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%93%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text"> 连结符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text"> 复杂选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E5%88%97%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text"> 选择器列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E5%99%A8-2"><span class="toc-number">2.</span> <span class="toc-text"> 简单选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text"> 类型选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text"> 通用选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text"> 属性选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css2%E5%BC%95%E5%85%A5%E7%9A%84%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text"> CSS2引入的属性选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 子串匹配属性选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 关于大小写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text"> 类选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#id%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text"> ID选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text"> 伪类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%8E%86%E5%8F%B2%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 链接历史伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 目标伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.6.3.</span> <span class="toc-text"> 用户操作伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.6.4.</span> <span class="toc-text"> 树结构伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.6.5.</span> <span class="toc-text"> 输入伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.6.6.</span> <span class="toc-text"> 语言伪类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.</span> <span class="toc-text"> 伪元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E8%A1%8C%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.1.</span> <span class="toc-text"> 首行伪元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E5%AD%97%E6%AF%8D%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.</span> <span class="toc-text"> 首字母伪元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%86%85%E5%AE%B9%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.</span> <span class="toc-text"> 生成内容伪元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%81%E5%87%BA%E6%98%BE%E7%A4%BA%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.</span> <span class="toc-text"> 突出显示伪元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.5.</span> <span class="toc-text"> 占位符伪元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%84%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text"> 逻辑组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E5%88%97%E8%A1%A8-2"><span class="toc-number">4.1.</span> <span class="toc-text"> 选择器列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BC%AA%E7%B1%BBis"><span class="toc-number">4.2.</span> <span class="toc-text"> 匹配伪类:is()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%A6%E5%AE%9A%E4%BC%AA%E7%B1%BBnot"><span class="toc-number">4.3.</span> <span class="toc-text"> 否定伪类:not()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E7%BB%93%E7%AC%A6-2"><span class="toc-number">5.</span> <span class="toc-text"> 连结符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E4%BB%A3%E8%BF%9E%E7%BB%93%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text"> 后代连结符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E4%BB%A3%E8%BF%9E%E7%BB%93%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text"> 子代连结符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%AA%E5%85%84%E5%BC%9Fnext-sibling%E8%BF%9E%E7%BB%93%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text"> 下个兄弟(next-sibling)连结符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BB%A7%E5%85%84%E5%BC%9Fsubsequent-sibling%E8%BF%9E%E7%BB%93%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text"> 后继兄弟(subsequent-sibling)连结符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text"> 解析顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%8C%87%E5%BA%A6"><span class="toc-number">7.</span> <span class="toc-text"> 特指度</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">173</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">选择器</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/CSS%E6%A0%B7%E5%BC%8F%E8%AF%AD%E8%A8%80/">CSS样式语言</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>参考资料：<br />
《CSS权威指南 第四版》<br />
<a target="_blank" rel="noopener" href="https://www.w3.org/TR/selectors-3/">Selectors Level 3- W3C Recommendation 06 November 2018</a><br />
<a target="_blank" rel="noopener" href="https://www.w3.org/TR/selectors-4/">Selectors Level 4- W3C Working Draft, 21 November 2018</a><br />
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rubylouvre/p/4276216.html">CSS 选择器</a><br />
<a target="_blank" rel="noopener" href="https://github.com/leeluolee/nes/wiki/Selector">leeluolee/nes</a></p>
<h1 id="选择器结构和术语"><a class="markdownIt-Anchor" href="#选择器结构和术语"></a> 选择器结构和术语</h1>
<p>每个元素可能有以下五个特征中的任何一个，可以针对任何一个特征进行选择，所有这些特征均作为字符串进行匹配：</p>
<span id="more"></span>
<ul>
<li>元素类型（也叫标签名称）</li>
<li>元素命名空间</li>
<li>ID</li>
<li>拥有的类</li>
<li>属性（键值对）</li>
</ul>
<p>个别元素可能没有以上特征的任何一个，某些元素是无特征的。一个无特征元素不能匹配任何选择器，除了显式定义的用于匹配它的选择器。</p>
<p><img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/CSS%E6%A0%B7%E5%BC%8F%E8%AF%AD%E8%A8%80/_v_images/20200930143206521_12704.png" alt="选择器分类" width="572" /></p>
<h2 id="选择器"><a class="markdownIt-Anchor" href="#选择器"></a> 选择器</h2>
<p>一个<strong>选择器</strong>表示树结构中一个特定模式的元素。术语“选择器”可以指一个<strong>简单选择器</strong>、<strong>组合选择器</strong>、<strong>复杂选择器</strong>以及<strong>选择器序列</strong>。选择器的主题是指被定义为与选择器相关的任何元素，即匹配该选择器的元素。</p>
<h2 id="简单选择器"><a class="markdownIt-Anchor" href="#简单选择器"></a> 简单选择器</h2>
<p>一个<strong>简单选择器</strong>是一个元素上的单个条件。一个<strong>类型选择器</strong>、<strong>通用选择器</strong>、<strong>属性选择器</strong>、<strong>类选择器</strong>、<strong>ID选择器</strong>和<strong>伪类</strong>都是一个<strong>简单选择器</strong>（在选择器语法中用<code>&lt;simple-selector&gt;</code>表示）。一个元素匹配一个简单选择器是指，该简单选择器按照本规范并根据文档语言精确的描述了该元素。</p>
<h2 id="组合选择器"><a class="markdownIt-Anchor" href="#组合选择器"></a> 组合选择器</h2>
<p>一个<strong>组合选择器</strong>是一个没有被<strong>连结符</strong>分隔的<strong>简单选择器</strong>组成的序列，并且表示单个元素上的一组同时成立的条件。如果它包含一个<strong>类型选择器</strong>或<strong>通用选择器</strong>，则<strong>类型选择器</strong>或<strong>通用选择器</strong>必须出现在序列的开头。序列中只允许出现一个<strong>类型选择器</strong>或<strong>通用选择器</strong>（一个<strong>组合选择器</strong>在选择器语法中用<code>&lt;compound-selector&gt;</code>表示）。一个元素匹配一个组合选择器是指，该元素匹配了组合选择器中的所有简单选择器。<br />
注意：因为空白符表示后代连结符，所以组合选择器中的简单选择器之间不允许出现空白符。</p>
<ul>
<li>解释：例如<code>.first:first-child[target].second</code></li>
</ul>
<h2 id="连结符"><a class="markdownIt-Anchor" href="#连结符"></a> 连结符</h2>
<p>一个<strong>连结符</strong>是一个条件，规定了以组合选择器表示的两个元素之间的关系。(A combinator is a condition of relationship between two elements represented by the compound selectors on either side.) <strong>连结符</strong>在Selectors Level 4中包括：<strong>后代连结符</strong>（空白符）、<strong>子代连结符</strong>（U+003E，<code>&gt;</code>）、<strong>下个兄弟(next-sibling)连结符</strong>（U+002B，<code>+</code>）和<strong>后继兄弟(subsequent-sibling)连结符</strong>（U+007E，<code>~</code>）。两个给定元素匹配连结符是指，这些元素之间的关系符合连结符的定义。</p>
<p>空白符中只能出现：空格(U+0020)、制表符(U+0009)、换行(U+000A)、回车(U+000D)、换页(U+000C)。<br />
其他像空格的字符不认为是空白符，例如em-space(U+2003)和全角空格(U+3000)</p>
<h2 id="复杂选择器"><a class="markdownIt-Anchor" href="#复杂选择器"></a> 复杂选择器</h2>
<p>一个<strong>复杂选择器</strong>是一个或多个被<strong>连结符</strong>分隔的<strong>组合选择器</strong>组成的序列。它表示满足这些连结符描述的特定关系的一组元素上的一组同时成立的条件。（<strong>复杂选择器</strong>在选择器语法中用<code>&lt;complex-selector&gt;</code>表示）。一个元素匹配一个复杂选择器是指，存在一个元素列表，列表中每个元素匹配复杂选择器中的一个相应的组合选择器，每对相邻的组合选择器中的元素匹配组合选择器之间的连结符，且最后一个元素是给定元素。(A given element is said to match a complex selector when there exists a list of elements, each matching a corresponding compound selector in the complex selector, with each pair of elements consecutive in the list matching the combinator between their corresponding compound selectors, and with the last element being the given element.)<br />
注意：一个由单个组合选择器构成的选择器匹配满足组成它的简单选择器的要求的任何元素。在一个序列开头添加另一个组合选择器和一个连结符会施加额外的匹配限制，致使复杂选择器的主题总是它最后一个组合选择器表示的元素的子集。</p>
<ul>
<li>解释：例如<code>.first[target].second .third[href] &gt; .fourth[width]</code></li>
</ul>
<h2 id="选择器列表"><a class="markdownIt-Anchor" href="#选择器列表"></a> 选择器列表</h2>
<p>一个<strong>简单/组合/复杂选择器列表</strong>是一个被逗号分隔的简单、组合或复杂选择器的列表。当类型不重要又或者在其他地方说明过，也可以简单的称为一个<strong>选择器列表</strong>。如果类型很重要并且没有特别说明，它默认是指一个复杂选择器的列表。一个元素匹配一个选择器列表是指，该元素匹配了列表中的任何（至少一个）选择器。</p>
<p>ISSUE2：伪元素在这里没有处理，但它本该有。</p>
<h1 id="简单选择器-2"><a class="markdownIt-Anchor" href="#简单选择器-2"></a> 简单选择器</h1>
<h2 id="类型选择器"><a class="markdownIt-Anchor" href="#类型选择器"></a> 类型选择器</h2>
<p>一个类型选择器是一个文档元素类型的名字，表示文档树中这个元素类型的实例。<br />
例如选择器<code>h1</code>表示文档中的所有<code>&lt;h1&gt;</code>元素。</p>
<h2 id="通用选择器"><a class="markdownIt-Anchor" href="#通用选择器"></a> 通用选择器</h2>
<p>通用选择器是一个特殊的类型选择器，表示任意类型的元素。写作<code>*</code>。<br />
除非元素是无特征的，否则通用选择器的存在对元素是否匹配某个选择器没有影响（无特征元素不匹配任何选择器，即便是通用选择器）<br />
组合选择器（加上伪元素）中如果没有类型选择器，那么就隐含着有一个通用选择器，即<code>.first[href].second</code>等价于<code>*.first[href].second</code>。<br />
通用选择器遵循与类型选择器相同的语法：在每个组合选择器中只能出现一次，并且必须是组合选择器中的第一个简单选择器。<br />
注意：虽然对匹配行为没有影响，但在某些情况下，加上通用选择器可以使得选择器更容易阅读。例如<code>div :first-child</code>和<code>div:first-child</code>第一眼很难看出有什么不同。但是写成<code>div *:first-child</code>就容易看出区别。</p>
<h2 id="属性选择器"><a class="markdownIt-Anchor" href="#属性选择器"></a> 属性选择器</h2>
<h3 id="css2引入的属性选择器"><a class="markdownIt-Anchor" href="#css2引入的属性选择器"></a> CSS2引入的属性选择器</h3>
<ul>
<li><code>[att]</code>：表示一个拥有<code>att</code>属性的元素，不管属性值是什么。</li>
<li><code>[att=val]</code>：表示一个拥有<code>att</code>属性，且属性值为<code>val</code>的元素。</li>
<li><code>[att~val]</code>：表示一个拥有<code>att</code>属性，且属性值是一个以空白符分隔的词语列表，其中一个词语与<code>val</code>完全相同。如果属性值和<code>val</code>完全相同，也可以匹配。如果<code>val</code>包含空格，或者<code>val</code>是空字符串，它就不会匹配任何内容。</li>
<li><code>[att|=val]</code>：表示一个拥有<code>att</code>属性，且属性值与<code>val</code>完全相同，又或者属性值开头是<code>val-</code>的元素。这个选择器主要用于语言子代码的匹配。</li>
</ul>
<p>属性值两边最好加上引号，只有在属性值满足<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5578845/css-attribute-selectors-the-rules-on-quotes-or-none">特定要求</a>时才可以不加引号，例如不能有空格，不能以数字开头，不能是英文破折号加数字等等。</p>
<h3 id="子串匹配属性选择器"><a class="markdownIt-Anchor" href="#子串匹配属性选择器"></a> 子串匹配属性选择器</h3>
<ul>
<li><code>[att^=val]</code>：表示一个拥有<code>att</code>属性，且属性值以前缀<code>val</code>开头的元素。如果<code>val</code>是空字符串，选择器不会匹配任何内容。</li>
<li><code>[att$=val]</code>：表示一个拥有<code>att</code>属性，且属性值以后缀<code>val</code>结尾的元素。如果<code>val</code>是空字符串，选择器不会匹配任何内容。</li>
<li><code>[att*=val]</code>：表示一个拥有<code>att</code>属性，且属性值包含子串<code>val</code>的元素。如果<code>val</code>是空字符串，选择器不会匹配任何内容。</li>
</ul>
<h3 id="关于大小写"><a class="markdownIt-Anchor" href="#关于大小写"></a> 关于大小写</h3>
<p>默认情况下，属性名和属性值是否区分大小写取决于文档语言。<br />
如果想匹配属性值时不区分大小写，而不管文档是什么语言编写的，可以在闭合中括号<code>]</code>前加一个标识符<code>i</code>。形如<code>[属性名=&quot;属性值&quot; i]</code>。<br />
如果想匹配属性值时强制区分大小写，而不管文档是什么语言编写的，可以在闭合中括号<code>]</code>前加一个标识符<code>s</code>。形如<code>[属性名=&quot;属性值&quot; s]</code>。</p>
<h2 id="类选择器"><a class="markdownIt-Anchor" href="#类选择器"></a> 类选择器</h2>
<p>类选择器的语法是一个点<code>.</code>后紧跟着类名，即<code>.classname</code>。它表示一个元素，该元素具有<code>class</code>属性，且属性值以空白符分隔后的词语列表里，其中一个词语（也叫类名）与<code>classname</code>完全相同。等价于属性选择器<code>[class~=classname]</code>。</p>
<h2 id="id选择器"><a class="markdownIt-Anchor" href="#id选择器"></a> ID选择器</h2>
<p>ID选择器的语法是一个井号<code>#</code>后紧跟着ID属性值，即<code>#val</code>。它表示一个具有<code>id</code>属性，且属性值与<code>val</code>完全相同的元素。</p>
<p>由于HTML中元素的<code>id</code>属性值不应该相同，因此ID选择器通常从所有元素中选择具有唯一、特定<code>id</code>属性值的那个元素。</p>
<h2 id="伪类"><a class="markdownIt-Anchor" href="#伪类"></a> 伪类</h2>
<p>伪类允许基于文档树之外，又或是使用其他简单选择器很难或无法表达的信息进行选择。它们也可以是动态的，即当用户与文档进行交互而不改变文档本身时，元素可以获取或丢失伪类。伪类不会出现在源文档或文档树中，也不会修改源文档或文档树。<br />
伪类的语法是一个冒号<code>:</code>后紧跟着作为CSS标识符的伪类名，如果是函数式伪类，后面还会跟着一对圆括号以及圆括号中的参数值。<br />
例如<code>:valid</code>是通常的伪类，<code>:lang()</code>是一个函数式伪类。<br />
像所有的CSS关键字一样，伪类名是区分大小写的ASCII字符。冒号和伪类名之间不允许出现空白符，函数式伪类名和它的左圆括号之间也不允许出现空白符。除非特别说明，函数式伪类的圆括号内部的参数的周围允许出现空白符。<br />
和其他简单选择器一样，伪类允许出现在组合选择器中，但必须在类型选择器或通用选择器之后（不要求紧跟着）。</p>
<p>注意：某些伪类是互斥的（包含它们的组合选择器不会匹配任何东西），而其他伪类可以同时应用到同一元素。</p>
<h3 id="链接历史伪类"><a class="markdownIt-Anchor" href="#链接历史伪类"></a> 链接历史伪类</h3>
<p>用户代理通常以与以前访问过的超链接不同的方式显示未访问的超链接。选择器提供伪类<code>:link</code>和<code>:visited</code>来区分它们：</p>
<ul>
<li><code>:link</code>伪类适用于尚未访问过的链接。</li>
<li><code>:visited</code>伪类适用至少被用户访问过一次的链接。</li>
</ul>
<p>一段时间后，用户代理可以选择将访问过的链接返回到（未访问）<code>:link</code>状态。<br />
两种状态是互斥的。</p>
<p>由于样式表作者可能会滥用<code>:link</code>和<code>:visited</code>伪类未经用户同意来检测用户访问了哪些网站，因此用户代理可能会将所有链接视为未访问的链接，或者在呈现访问与未访问链接的不同时采取其他措施来保护用户的隐私。例如，只能把颜色相关的属性应用到已访问的链接上，其他属性将被忽略。此外，通过脚本获取已访问链接的样式时，返回的值跟未访问时一样。</p>
<h3 id="目标伪类"><a class="markdownIt-Anchor" href="#目标伪类"></a> 目标伪类</h3>
<p>在某些文档语言中，文档的URL可以通过URL片段标识符<code>#</code>指向文档内的特定元素，以这种方式指定的元素是文档的目标元素。<br />
例如，在HTML中，片段标识符指向页面中具有相同ID的元素。例如<code>https://example.com/index.html#section2</code>指向位于<code>https://example.com/index.html</code>的文档中<code>id=&quot;section2&quot;</code>的元素。<br />
<code>:target</code>伪类匹配文档的目标元素，如果文档的URL中没有片段标识符，这个文档就没有目标元素。</p>
<h3 id="用户操作伪类"><a class="markdownIt-Anchor" href="#用户操作伪类"></a> 用户操作伪类</h3>
<p>交互式用户界面有时会响应用户操作来更改呈现。选择器提供了几个用户操作伪类，用于选择用户正在操作的元素。（在非交互式用户代理中，这些伪类有效，但从不匹配任何元素。）<br />
这些伪类不是互斥的，一个元素可以同时匹配多个用户操作伪类。</p>
<ol>
<li><code>:hover</code>：<br />
指针悬停伪类是当用户用定点设备指明了一个元素，但不必激活它时应用。例如，一个可视化用户代理会在光标悬停在元素生成的框时应用这个伪类。由于硬件限制而无法检测到悬停的交互式用户代理（例如，无法检测到悬停的笔设备）中该伪类有效，但不匹配任何元素。<br />
如果元素在平面树中的后代（包括非元素节点，例如文本节点）与上述条件匹配，则元素也匹配<code>:hover</code><br />
文档语言可以定义元素匹配的其他方式，例如HTML5规定当悬停在标签元素<code>&lt;label&gt;</code>上时，<code>:hover</code>会匹配被标签元素关联的控件。<br />
<code>:hover</code>可以应用到任何伪元素上。</li>
<li><code>:active</code>：<br />
激活伪类是当元素被用户激活时应用。例如，在用户按下鼠标按钮并释放它的期间。在具有多个鼠标按钮的系统上，<code>:active</code>仅适用于主要或主要激活按钮（通常为“左”鼠标按钮）及其任何别名。<br />
哪些元素可以<code>:active</code>可能具有文档语言或特定于实现的限制。例如HTML5定义了一份<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/semantics-other.html#selector-active">可激活元素列表</a><br />
如果元素在平面树中的后代（包括非元素节点，例如文本节点）与上述条件匹配，则元素也匹配<code>:active</code><br />
注意：元素可以同时<code>:visited</code>和<code>:active</code>（或<code>:link</code>和<code>:active</code>）</li>
<li><code>:focus</code>：<br />
输入焦点伪类是当一个元素具有焦点（接受键盘或鼠标事件，或其他形式的输入）时应用。<br />
哪些元素可以获取<code>:focus</code>可能具有文档语言或特定于实现的限制。例如HTML定义了一份<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/interaction.html#focusable-area">可聚焦区域</a>。<br />
文档语言可以定义元素匹配<code>:focus</code>的额外方式，除了<code>:focus</code>伪类必须不会自动传播到父元素。</li>
</ol>
<p>link-visited-focus-hover-active这个顺序不是随意的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: blue;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: purple;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: orange;&#125;</span><br></pre></td></tr></table></figure>
<p>其中第一行和第二行可以互换，没有影响。<br />
这五个规则中的五个声明，都是普通声明、作者来源、特指度均为(0,1,1)，所以靠后出现的声明优先级越高，也就是满足条件的最后一条规则的颜色会被应用。<br />
首先，链接历史伪类<code>:link</code>和<code>:visited</code>是互斥的，同时一个链接要么是已访问的要么是未访问的，所以不管链接元素是聚焦、悬停还是激活，都会匹配这两个伪类中的一个。如果把用户操作伪类<code>:hover</code>、<code>:focus</code>和<code>:active</code>中任何一个放在链接历史伪类前面，那么总是会应用链接历史伪类的样式。用户操作伪类完全无效。因此链接历史伪类必须是第一个和第二个出现。<br />
然后，以鼠标设备点击元素过程为例：</p>
<ol>
<li>鼠标开始移动到元素上：不匹配任何用户操作伪类</li>
<li>鼠标移动到了元素上：状态是<code>:hover</code></li>
<li>按下鼠标：状态是<code>:active:hover:focus</code></li>
<li>松开鼠标：状态是<code>:hover:focus</code></li>
<li>鼠标从元素上移开：状态是<code>:focus</code></li>
<li>鼠标点击了其他元素：不匹配任何用户操作伪类</li>
</ol>
<p>可以看到元素从按下鼠标开始一直满足<code>:focus</code>状态，如果把<code>:hover</code>或<code>:active</code>放在<code>:focus</code>前面，则不会有任何效果，所以必须把它放在三个里最前面。同理，如果把<code>:active</code>放在<code>:hover</code>前面，也不会有任何效果。因此顺序只能是focus-hover-active。<br />
当然，如果使用组合选择器，更加具体的指明状态，例如<code>a:active:hover:focus</code>，就不需要要求顺序了。</p>
<h3 id="树结构伪类"><a class="markdownIt-Anchor" href="#树结构伪类"></a> 树结构伪类</h3>
<p>选择器引入了结构化伪类的概念，以允许基于文档树中不能由其他简单选择器或连结符表示的额外信息进行选择。<br />
计算元素在其父元素的子元素列表中的位置时，不计算独立文本和其他非元素节点，并且索引编号从1开始。<br />
结构化伪类只能应用文档树中的元素上，不能用在伪元素上。</p>
<ol>
<li><code>:root</code><br />
根伪类表示文档的根元素。例如HTML文档的根元素是<code>&lt;html&gt;</code></li>
<li><code>:empty</code><br />
空伪类表示没有子元素，但可能有几种特定的空白符或注释节点的元素（这是Selector Level 4的定义，旧浏览器可能仍然要求不能有空白符）。例如<code>&lt;p&gt;&lt;/p&gt;</code>和<code>&lt;p&gt; &lt;/p&gt;</code>。但<code>&lt;p&gt;&amp;nbsp;&lt;/p&gt;</code>和<code>&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</code>不能匹配。</li>
<li><code>:nth-child()</code><br />
<code>:nth-child(An+B)</code>伪类表示元素在所有兄弟中是第<code>An+B</code>个元素。<br />
语法<code>An+B</code>表示所有非负整数<code>n</code>生成的索引<code>i</code>，即<code>B</code>、<code>A+B</code>、<code>2A+B</code>。它也接受关键词<code>even</code>和<code>odd</code>，等价于<code>2n</code>和<code>2n+1</code>。当<code>A=0</code>时可以省略<code>An</code>部分。当<code>B=0</code>时可以省略<code>B</code>部分。当<code>B</code>为负数时，要用它的负号<code>-</code>替换<code>An+B</code>中的加号<code>+</code>。<br />
注意元素列表的索引是从1开始的，计算得到小于1的值将不会匹配任何元素，例如<code>10n-1</code>的第一个匹配元素是第9个。<br />
要表示兄弟中从第<code>B</code>个开始的所有元素，可以用<code>n+B</code>，因为<code>n&gt;=0</code>所以<code>n+B&gt;=B</code>。<br />
要表示兄弟中第<code>B</code>个以及之前的所有元素，可以用<code>-n+B</code>，因为<code>n&gt;=0</code>所以<code>-n+B&lt;=B</code>。</li>
<li><code>:nth-last-child()</code><br />
<code>:nth-child(An+B)</code>伪类表示元素在所有兄弟中是倒数第<code>An+B</code>个元素。<br />
注意此时元素列表中的最后一项的索引是1。</li>
<li><code>:first-child</code><br />
表示它在所有兄弟中的索引是1，等价于<code>:nth-child(1)</code>。<br />
<code>div &gt; p:first-child</code>表示在所有兄弟中索引是<code>1</code>的<code>&lt;p&gt;</code>元素，且它有一个父元素<code>&lt;div&gt;</code></li>
<li><code>:last-child</code><br />
表示它在所有兄弟中的索引是最大的，即最后一个。等价于<code>:nth-last-child(1)</code></li>
<li><code>:only-child</code><br />
表示一个没有兄弟的元素，等价于<code>:first-child:last-child</code>，但特指度更低。</li>
<li><code>nth-of-type()</code><br />
<code>:nth-of-type(An+B)</code>伪类表示在所有同类型的兄弟中是第<code>An+B</code>个元素。</li>
<li><code>nth-last-of-type()</code><br />
<code>:nth-last-of-type(An+B)</code>伪类表示在所有同类型兄弟中是倒数第<code>An+B</code>个元素。</li>
<li><code>:first-of-type</code><br />
表示它在所有同类型兄弟中的索引是1，等价于<code>:nth-of-type(1)</code></li>
<li><code>last-of-type</code><br />
表示它在所有同类型兄弟中的索引最大，即最后一个。等价于<code>:nth-last-of-type(1)</code></li>
<li><code>only-of-type</code><br />
表示一个没有同类型兄弟的元素，等价于<code>:first-of-type:last-of-type</code></li>
</ol>
<h3 id="输入伪类"><a class="markdownIt-Anchor" href="#输入伪类"></a> 输入伪类</h3>
<p>输入伪类大多应用在接受用户输入的元素上，例如HTML的<code>&lt;input&gt;</code>元素。</p>
<ol>
<li>
<p><code>:enabled</code>和<code>:disabled</code><br />
<code>:enabled</code>伪类表示处于启用状态的用户界面元素；这些元素必须有对应的禁用状态。<br />
反过来，<code>:disabled</code>伪类表示处于禁用状态的用户界面元素；这些元素必须有对应的启用状态。<br />
构成启用状态、禁用状态和用户界面元素的方式取决于文档语言。在通常的文档中，大多数元素既不是<code>:enabled</code>也不是<code>:disabled</code>。例如，HTML5将<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/semantics-other.html#selector-enabled">未禁用交互式元素</a>定义为<code>:enabled</code>，然后将<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/semantics-other.html#selector-enabled">显式禁用</a>的元素定义为<code>:disabled</code>。<br />
注意，可能影响用户与给定用户界面元素进行交互的能力的CSS属性，不会影响元素是否匹配<code>:enabled</code>和<code>:disabled</code>。例如<code>display</code>和<code>visibility</code>属性对元素的启用/禁用状态没有影响。</p>
</li>
<li>
<p>可变性伪类<code>:read-only</code>和<code>:read-write</code><br />
如果一个元素是用户可编辑的，则该元素匹配<code>:read-write</code>，如文档语言定义的那样。否则，它就是<code>:read-only</code>。<br />
例如，HTML5中一个<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/semantics-other.html#selector-read-only">未禁用非只读input元素</a>是<code>:read-write</code>的，任何将<code>contenteditable</code>属性设置为<code>true</code>状态的元素也是如此。</p>
</li>
<li>
<p>占位符显示伪类<code>:placeholder-shown</code><br />
输入元素有时可以显示占位符来提示用户该输入什么内容。例如HTML5中的<code>placeholder</code>属性。<code>:placeholder-shown</code>伪类匹配正在显示占位符文本的输入元素。</p>
</li>
<li>
<p>默认选项伪类<code>:default</code><br />
<code>:default</code>伪类应用在一组相似元素中的默认的一个或多个用户界面元素。通常适用于上下文菜单项，按钮和选择列表/菜单。<br />
一个例子是一组按钮中的默认提交按钮。另一个例子是弹出菜单中的默认选项。在多选组中，多个元素都可以匹配<code>:default</code>。例如HTML5定义<code>:default</code>匹配<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/semantics-other.html#selector-default">表单中的默认按钮、select中的默认选中选项和一些其他元素</a>。</p>
</li>
<li>
<p>选中选项伪类<code>:checked</code><br />
单选按钮和多选框元素可以被用户切换。当用户选择某些菜单项时，它们会被选中。当这些元素被切换到“开”时，<code>:checked</code>伪类适用。例如HTML5规定了<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/semantics-other.html#selector-checked">选中的多选框、单选按钮和选中的option元素</a>匹配<code>:checked</code>。<br />
<code>checked</code>伪类是动态的，并且可以由用户操作改变，因为它也可以基于文档中的语义属性的存在（例如HTML5中的<code>selected</code>和<code>checked</code>属性），它适用于所有媒体。<br />
一个未选中的多选框可以用否定伪类选择，例如<code>input[type=checkbox]:not(:checked)</code></p>
</li>
<li>
<p>不确定值伪类<code>:indeterminate</code><br />
<code>:indeterminate</code>伪类应用到值是不确定状态的UI元素，例如单选按钮和多选框可以在选中和未选中状态之间切换，但有时处于不确定状态，既没有选中也没有不选中。类似的，进度条和计量条元素完成百分比未知时也处于不确定状态。例如，HTML5规定了如何使多选框匹配<code>:indeterminate</code>。<br />
像<code>:checked</code>伪类一样，<code>:indeterminate</code>可以应用到所有媒体。例如，一组没有默认选中的单选按钮即使在静态显示中也是<code>:inderterminate</code>。</p>
</li>
<li>
<p>空值伪类<code>:blank</code><br />
<code>:blank</code>伪类应用到输入值为空（由空串或者其他空输入组成）的用户输入元素。<br />
一个<code>:blank</code>用户输入元素的例子是内容为空的<code>&lt;textarea&gt;</code>元素，或者一个<code>value</code>为空的<code>&lt;input&gt;</code>元素。需要注意的是所考虑的值在这里是将提交的值（参见HTML中表单控件的值 ），其在HTML不一定对应于该元素的<code>value</code>属性值。<br />
注意，该选择器有风险。</p>
</li>
<li>
<p>有效性伪类<code>:valid</code>和<code>:invalid</code><br />
当元素的内容或值相对于文档语言（例如HTML5）定义的数据有效性语义是有效或无效时，元素是<code>:valid</code>或<code>:invalid</code>的。缺少数据有效性语义的元素既不是<code>:valid</code>也不是<code>:invalid</code>。<br />
注意：没有限制总是<code>:valid</code>的元素与完全没有数据有效性语义的元素是有区别的，后者既不是<code>:valid</code>也不是<code>:invalid</code>。在HTML中，一个<code>&lt;input type=&quot;text&quot;&gt;</code>可能没有限制，而一个<code>&lt;p&gt;</code>元素根本没有有效性语义所以它永远不会与这些伪类中的任何一个匹配。</p>
</li>
<li>
<p>范围伪类<code>:in-range</code>和<code>:out-of-range</code><br />
<code>:in-range</code>和<code>:out-of-range</code>伪类只会应用到有范围限制的元素。当元素的值相对于文档语言所定义的范围限制，在范围内或范围外时，该元素为<code>:in-range</code>或<code>:out-of-range</code>。缺少数据范围限制或不是表单控件的元素既不是<code>:in-range</code>也不是<code>:out-of-range</code>。例如，一个值为11的滑块控件仅表示1-10之间的值是<code>:out-of-range</code>。另一个例子是一个值为<code>E</code>的菜单元素，该元素恰巧出现在仅具有选项<code>A</code>，<code>B</code>和<code>C</code>的弹出菜单中。<br />
该伪类只根据是否在范围内来判断，而范围内的值也可能是无效的，即可能既匹配<code>:in-range</code>也匹配<code>:invalid</code>，例如范围内但不满足步长要求。</p>
</li>
<li>
<p>可选性伪类<code>:required</code>和<code>:optional</code><br />
如果一个表单元素在它所属的表单可以有效提交之前是值是必填或者选填的，则它是<code>:required</code>或<code>:optional</code>的。不是表单控件的元素既不是必填也不是选填。</p>
</li>
<li>
<p>用户交互伪类<code>:user-invalid</code><br />
<code>:user-invalid</code>伪类表示输入了错误值的元素，但只在用户显式与它交互之后。<code>:user-invalid</code>伪类必须在在用户尝试提交表单和用户再次与表单元素交互之间这段时间匹配<code>:invalid</code>、<code>:out-of-range</code>或为空但<code>:required</code>的元素。用户代理可以允许它在其他时间匹配这些元素，这将适合于向用户突出显示错误。例如，UA可以选择当用户在其中输入了一些文本并将焦点更改为另一个元素时让<code>:user-invalid</code>与<code>:invalid</code>元素匹配，并且只有在用户成功更正输入后才停止匹配。</p>
</li>
</ol>
<h3 id="语言伪类"><a class="markdownIt-Anchor" href="#语言伪类"></a> 语言伪类</h3>
<p>如果文档语言指定如何确定元素的（人类）内容语言，则可以编写基于元素内容语言来表示元素的选择器。<code>:lang()</code>伪类表示一个内容语言是在它的参数中列出的语言之一的元素。它接受以逗号分隔的一个或多个语言范围作为参数（Selectors Level 3中只允许一个）。<code>:lang()</code>中的每个语言范围都必须是合法的CSS标识符或字符串（包括星号<code>*</code>的语言范围必须正确转义或者作为字符串用引号引用，例如<code>:lang(\*-Latn)</code>或<code>:lang(&quot;*-Latn&quot;)</code>）。<br />
注意，元素的内容语言由文档语言定义，例如HTML中，内容语言由<code>lang</code>属性、来自<code>&lt;meta&gt;</code>元素的信息，和可能的协议（例如HTTP首部）共同确定。XML语言可以用<code>xml:lang</code>属性来给一个元素指定语言。<br />
注意：<code>:lang(C)</code>和<code>|=</code>操作符之间的一个区别是<code>|=</code>操作符仅与元素上给定的属性进行比较，而<code>:lang(C)</code>伪类使用用户代理的文档语义知识来执行比较。<br />
例如HTML中，<code>&lt;body lang=fr&gt;&lt;p&gt;Je suis&lt;/p&gt;&lt;/body&gt;</code>使用属性选择器<code>[lang|=fr]</code>只能匹配<code>&lt;body&gt;</code>元素，因为<code>&lt;p&gt;</code>元素上没有属性<code>lang</code>，但<code>:lang(fr)</code>伪类可以匹配<code>&lt;body&gt;</code>和<code>&lt;p&gt;</code>元素。<br />
若要使用这种类型的语言范围匹配来选择元素的<code>lang</code>属性值，请同时使用属性选择器和语言伪类，例如<code>[lang]:lang(de-DE)</code></p>
<h1 id="伪元素"><a class="markdownIt-Anchor" href="#伪元素"></a> 伪元素</h1>
<p>和某些伪类表示不存在于文档树的额外状态信息类似，一个伪元素表示一个不直接出现在文档树中的元素。它们用于创建关于文档树的抽象，而不是由文档树提供的抽象。例如，伪元素可用于选择不对应于文档提供的元素但又是文档内容的一部分（包括不与元素边界对齐或不适合树结构的范围）；表示不在文档树或者依赖于样式、布局、用户交互以及未在文档树中反映的其他过程提供的信息。<br />
例如，文档语言不提供访问元素内容的第一个字母或者第一行的机制，但是伪元素<code>::first-letter</code>和<code>::first-line</code>可以对这些进行样式设置。特别注意的是在<code>::first-line</code>的例子中，哪一部分内容由伪元素表示取决于不能从文档树推断出的布局信息。伪元素还可以表示完全不存在于源文档的内容，例如<code>::before</code>和<code>::after</code>伪元素允许在任何元素的内容之前或之后插入额外内容。</p>
<p>与伪类类似，伪元素不会出现在源文档或文档树中，也不会修改源文档或文档树。因此，它们也不会影响结构化伪类或其他适用于它们原始元素的选择器。</p>
<p>伪元素的语法是两个冒号<code>::</code>后紧跟着作为CSS标识符的伪元素名。伪元素名是区分大小写的ASCII字符。两个冒号之间不允许出现空白符，冒号和伪元素名之间也不允许出现空白符。<br />
伪元素是无特征的，所以不能被任何其他选择器匹配。</p>
<p>伪元素在文档树中不是独立存在的，它总是绑定到页面上的另一个元素，称为<strong>原始元素</strong>。语法上，伪元素紧跟在表示其原始元素的组合选择器之后。如果组合选择器被省略了，它假设前面有通用选择器。<br />
例如在选择器<code>div a::before</code>中，选择器匹配的<code>a</code>元素就是<code>::before</code>伪元素的原始元素。选择器<code>::first-line</code>等价于<code>*::first-line</code>，会选择文档中的每个元素上的<code>::first-line</code>伪元素。</p>
<p>一个伪元素可能紧跟着任何用户操作伪类的组合，在这种情况下，伪元素只在相应状态才被表示。伪类能不能匹配上伪元素取决于伪类和伪元素的定义：除非特别说明，否则这些伪类都不会在伪元素上匹配。<br />
例如<code>:hover</code>伪类说明它可以应用到任何伪元素，<code>::first-line:hover</code>当悬停在元素的第一行时会匹配。而<code>:focus</code>和<code>::fisrt-line</code>都没有说明<code>:focus</code>可以应用到<code>::first-line</code>上面，所以选择器<code>::first-line:focus</code>什么也不会匹配。<br />
注意<code>::first-line:hover</code>和<code>:hover::first-line</code>非常不同，后者匹配任何被悬停的原始元素的第一行。比如当悬停在段落的第二行时，<code>:hover::first-line</code>也会匹配段落的第一行，而<code>::first-line:hover</code>只有悬停在它的第一行时才会匹配。<br />
注意：除非将来的规范的特别说明，否则除了用户操作伪类之外都不允许和伪元素组合，例如<code>::before:first-child</code>是不合法的选择器。</p>
<p>一些伪元素被定义为具有内部结构，在这些伪元素后面可以跟着子代或后代选择器来表达这种关系。没有内部结构的伪元素后面跟连结符是无效的。<br />
例如<code>::first-letter + span</code>和<code>::first-letter em</code>是无效的选择器。而因为<code>::shadow</code>被定义为有内部结构，所以<code>::shadow &gt; p</code>是有效的选择器。</p>
<h2 id="首行伪元素"><a class="markdownIt-Anchor" href="#首行伪元素"></a> 首行伪元素</h2>
<p>首行伪元素<code>::first-line</code>表示它的原始元素的第一格式化行。<br />
例如<code>p::first-line &#123; text-transform: uppercase &#125;</code>表示将每个<code>p</code>元素的第一行字母大写。选择器<code>p::first-line</code>不会匹配文档中的任何实际元素。它匹配的是用户代理在每个<code>&lt;p&gt;</code>元素开头插入的相应的伪元素。<br />
注意：第一行的长度取决于许多因素，包括页面的宽度、字体大小等等。</p>
<p>在CSS中，<code>::first-line</code>只在存在包含块时才有效，一个元素的第一格式化行必须出现在同一个流的块级后代（例如由于浮动或定位而没有在流之外的块级后代）<br />
例如<code>&lt;DIV&gt;&lt;P&gt;This line...&lt;/P&gt;&lt;/DIV&gt;</code>里<code>DIV</code>的第一行也是<code>P</code>的第一行。</p>
<p>仅适用于块级元素（未来的规范可能允许更多显示类型）。<code>::first-letter</code>伪元素可以用在包含文本，或有一个包含文本且在相同流中的后代的这类元素。用户代理应认为<code>:: first-letter</code>虚构的开始标签位于元素的第一个文本之前，即使该第一个文本在其后代中也是如此。<br />
表格单元格或inline块的第一行不会是祖先元素的第一个格式化行。这是说<code>&lt;DIV&gt;&lt;P STYLE=&quot;display: inline-block&quot;&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>中，<code>DIV</code>的第一个格式化行不是行<code>Hello</code>。<br />
注意：<code>&lt;p&gt;&lt;br&gt;First...</code>中<code>&lt;p&gt;</code>的第一行不包含任何字母，<code>First</code>不在第一格式化行中。</p>
<p>用户代理必须认为<code>::first-line</code>虚构的开始标记嵌套在最里面的封闭块级元素内。<br />
例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DIV</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">P</span>&gt;</span>First paragraph<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">P</span>&gt;</span>Second paragraph<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>被认为</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DIV</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">P</span>&gt;</span>&lt;DIV::first-line&gt;&lt;P::first-line&gt;First paragraph&lt;/P::first-line&gt;&lt;/DIV::first-line&gt;<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">P</span>&gt;</span>&lt;P::first-line&gt;Second paragraph&lt;/P::first-line&gt;<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>允许的属性有：</p>
<ul>
<li>所有字体属性</li>
<li><code>color</code>和<code>opacity</code>属性</li>
<li>所有背景属性</li>
<li>适用于行内元素的任何排版属性</li>
<li>所有文本装饰属性</li>
<li>适用于行内元素的任何行内布局属性</li>
<li>任何被相应规范定义的可以应用到<code>::fisrt-line</code>上的属性</li>
</ul>
<p>用户代理也可以应用其他属性。</p>
<h2 id="首字母伪元素"><a class="markdownIt-Anchor" href="#首字母伪元素"></a> 首字母伪元素</h2>
<p>首字母伪元素<code>::first-letter</code>表示它的原始元素的第一格式化行的第一个印刷字母单元，如果它前面的行没有其他内容（例如图片和行内表格）。<code>::first-letter</code>伪元素可以用来创建首字母大写和首字下沉，这是很常见的印刷效果。<br />
例如，<code>h2 +p::first-letter &#123;initial-letter:2;&#125;</code>创建一个二级标题下每个段落首字下沉2行效果。<br />
标点符号（即属于Punctuation(P*)<a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-text-3/#unicode-general-category">Unicode通用类别</a> <a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-pseudo-4/#biblio-uax44"> [UAX44] </a> 的字符）也要被包含在伪元素<code>::first-letter</code>里。即它会同时选中标点和首字母。<br />
某些语言的字母是由多个字符构成，这种情况下<code>::first-letter</code>应该考虑多个字母。<br />
如果构成<code>::first-letter</code>的字符不在同一个元素，例如<code>&lt;p&gt;'&lt;em&gt;T...</code>里的<code>'T</code>，用户代理可以从两个元素中选择一个或两个来创建<code>::first-letter</code>伪元素，也可以根本不创建伪元素。另外，如果块的第一个字母不在该行的开始（例如由于双向重排），则用户代理不需要创建伪元素。<br />
<code>::first-letter</code>伪元素被包含在<code>::first-line</code>伪元素中，它也继承于<code>::first-line</code>。</p>
<p>首字母必须出现在第一格式化行。例如HTML片段<code>&lt;p&gt;&lt;br&gt;First...</code>中，首行不包含任何字母所以<code>::first-letter</code>不匹配任何东西。特别是，也不会匹配<code>First</code>中的<code>F</code>。<br />
在CSS中，<code>::first-letter</code>伪元素仅适用于块级元素（未来的规范可能允许更多显示类型）。<code>::first-letter</code>伪元素可以用在包含文本，或有一个包含文本且在相同流中的后代的这类元素。用户代理应认为<code>:: first-letter</code>虚构的开始标签位于元素的第一个文本之前，即使该第一个文本在其后代中也是如此。<br />
例如<code>&lt;div&gt;&lt;p&gt;The first text</code>被认为是<code>&lt;div&gt;&lt;p&gt;&lt;div::first-letter&gt;&lt;p::first-letter&gt;T&lt;/...&gt;&lt;/...&gt;he first text.</code></p>
<p>在CSS中，表格单元格或inline块的首字母不会是祖先元素的首字母。这是说<code>&lt;DIV&gt;&lt;P STYLE=&quot;display: inline-block&quot;&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>中，<code>DIV</code>的首字母不是<code>H</code>。实际上<code>DIV</code>没有首字母。如果元素是<code>display:list-item</code>的，则<code>::first-letter</code>应用于标记后的主体框中的第一个字母。用户代理可能会忽略具有<code>list-style-position: inside</code>的列表项上的<code>::first-letter</code>。如果元素具有<code>::before</code>或<code>::after</code>内容，则<code>::first-letter</code>判断首字母时也需要考虑这部分内容。<br />
例如已有规则<code>p::before &#123;content: &quot;Note: &quot;&#125;</code>，选择器<code>p::first-letter</code>会匹配<code>Note</code>中的<code>N</code>。</p>
<p>允许的属性有：</p>
<ul>
<li>所有字体属性</li>
<li><code>color</code>和<code>opacity</code>属性</li>
<li>所有背景属性</li>
<li>适用于行内元素的任何排版属性</li>
<li>所有文本装饰属性</li>
<li>适用于行内元素的任何行内布局属性</li>
<li>外边距和内边距属性</li>
<li>任何被相应规范定义的可以应用到<code>::fisrt-letter</code>上的属性</li>
</ul>
<p>用户代理也可以应用其他属性。</p>
<h2 id="生成内容伪元素"><a class="markdownIt-Anchor" href="#生成内容伪元素"></a> 生成内容伪元素</h2>
<p>当<code>::before</code>和<code>after</code>的<code>content</code>属性值不是<code>none</code>时，这些伪元素将生成框，就好像它们是其原始元素的直接子元素一样，并且可以像在文档树中的元素一样对它们进行样式设置。<br />
<code>::before</code>表示在原始元素实际内容之前的可设置样式的子伪元素。<br />
<code>::after</code>表示在原始元素实际内容之后的可设置样式的子伪元素。<br />
例如<code>p.note::before &#123; content: &quot;Note: &quot; &#125;</code>在每个具有类名<code>note</code>的<code>p</code>元素的内容之前插入文本<code>Note:</code>。由于<code>display</code>的初始值是<code>inline</code>，它会生成一个行内框。就像<code>&lt;p&gt;</code>的其他的行内子元素一样，它会参与<code>&lt;p&gt;</code>的行内格式化上下文，有可能与其他内容共享同一行。</p>
<p>和其他常规元素的内容一样，对于<code>::before</code>和<code>::after</code>伪元素的生成内容，<code>::first-letter</code>和<code>::first-line</code>判断首字母和首行时也需要考虑进去。</p>
<p><code>content</code>属性所能设置的值非常多，不仅仅是字符串，还可以通过URL设置图片、引号、应用其他属性等等。还可以同时设置多种，只需要用空格分隔。</p>
<p>取值语法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">normal | none | [ &lt;content-replacement&gt; | &lt;content-list&gt; ] [/ &lt;string&gt; ]?</span><br><span class="line"><span class="built_in">where</span> </span><br><span class="line">&lt;content-replacement&gt; = &lt;image&gt;</span><br><span class="line">&lt;content-list&gt; = [ &lt;string&gt; | contents | &lt;image&gt; | &lt;quote&gt; | &lt;target&gt; | &lt;leader()&gt; ]+</span><br><span class="line"></span><br><span class="line"><span class="built_in">where</span> </span><br><span class="line">&lt;image&gt; = &lt;url&gt; | &lt;image()&gt; | &lt;image-set()&gt; | &lt;element()&gt; | &lt;paint()&gt; | &lt;cross-fade()&gt; | &lt;gradient&gt;</span><br><span class="line">&lt;quote&gt; = open-quote | close-quote | no-open-quote | no-close-quote</span><br><span class="line">&lt;target&gt; = &lt;target-counter()&gt; | &lt;target-counters()&gt; | &lt;target-text()&gt;</span><br><span class="line">&lt;leader()&gt; = leader( &lt;leader-type&gt; )</span><br></pre></td></tr></table></figure>
<h2 id="突出显示伪元素"><a class="markdownIt-Anchor" href="#突出显示伪元素"></a> 突出显示伪元素</h2>
<p><code>::selection</code>伪元素表示用户已经选择的部分。</p>
<h2 id="占位符伪元素"><a class="markdownIt-Anchor" href="#占位符伪元素"></a> 占位符伪元素</h2>
<p><code>::placeholder</code>伪元素匹配占位符。</p>
<h1 id="逻辑组合"><a class="markdownIt-Anchor" href="#逻辑组合"></a> 逻辑组合</h1>
<h2 id="选择器列表-2"><a class="markdownIt-Anchor" href="#选择器列表-2"></a> 选择器列表</h2>
<p>一个逗号<code>,</code>分隔的选择器列表表示其中每个选择器选出的元素的并集。逗号之前或之后可以出现空白符。<br />
注意，如果选择器列表中有无效的选择器语法，整个选择器列表都会失效，不会匹配任何元素。</p>
<h2 id="匹配伪类is"><a class="markdownIt-Anchor" href="#匹配伪类is"></a> 匹配伪类:is()</h2>
<p>任意匹配伪类<code>:is()</code>是一个函数式伪类，接受一个选择器列表作为参数。它表示被它的参数所表示的元素。<br />
例如<code>ul &gt; [hidden], ol &gt; [hidden], .list &gt; [hidden]</code>可以写成<code>:is(ul, ol, .list) &gt; [hidden]</code>，但是它们的特指度不一样。<br />
伪元素不能被否定伪类表示，它们也不能作为参数。</p>
<h2 id="否定伪类not"><a class="markdownIt-Anchor" href="#否定伪类not"></a> 否定伪类:not()</h2>
<p>否定伪类<code>:not()</code>是一个函数式伪类，接受一个选择器列表作为参数。它表示不被它的参数所表示的元素。<br />
注意，Selectors Level 3中否定伪类的参数只接受单个简单选择器。<br />
伪元素不能被否定伪类表示，它们也不能作为参数。<br />
例如，<code>button:not([DISABLED])</code>匹配没有被禁用的所有<code>&lt;button&gt;</code>元素。<code>*:not(FOO)</code>匹配除了<code>FOO</code>的所有元素。<code>*:not(:link):not(:visited)</code>匹配所有HTML链接。</p>
<h1 id="连结符-2"><a class="markdownIt-Anchor" href="#连结符-2"></a> 连结符</h1>
<p>HTML文档具有层次结构，由根节点<code>html</code>元素开始，可以构造一个文档树。<br />
若元素a在元素b的内部，则称元素a是元素b的后代元素，元素b是元素a的祖先元素。<br />
若元素a在元素b的内部，且a的外部元素就是b，则称元素a是元素b的子元素，元素b是元素a的父元素。元素的父子关系是祖先-后代关系的特例。</p>
<h2 id="后代连结符"><a class="markdownIt-Anchor" href="#后代连结符"></a> 后代连结符</h2>
<p>一个后代连结符是用来分开两个组合选择器的空白符。<br />
例如<code>h1 em</code>表示元素<code>&lt;em&gt;</code>是元素<code>&lt;h1&gt;</code>的后代。<br />
<code>div * p</code>表示元素<code>&lt;p&gt;</code>是元素<code>&lt;div&gt;</code>的后代但不是子代，注意<code>*</code>是通用选择器，但<code>*</code>两边的空格不是通用选择器的一部分，空格是连结符，表示<code>div</code>必须是某元素的祖先，并且这个元素又是<code>p</code>的祖先。</p>
<h2 id="子代连结符"><a class="markdownIt-Anchor" href="#子代连结符"></a> 子代连结符</h2>
<p>一个子代连结符是用来分开两个组合选择器的大于号<code>&gt;</code>。表示了两个元素之间的父子关系。<br />
例如<code>body &gt; p</code>表示<code>&lt;p&gt;</code>是<code>&lt;body&gt;</code>的子元素。<br />
<code>div ol&gt;li p</code>表示<code>&lt;p&gt;</code>是某个<code>&lt;li&gt;</code>的后代，并且这个<code>&lt;li&gt;</code>又是某个<code>&lt;ol&gt;</code>的子元素，并且这个<code>&lt;ol&gt;</code>又是某个<code>&lt;div&gt;</code>的后代。</p>
<h2 id="下个兄弟next-sibling连结符"><a class="markdownIt-Anchor" href="#下个兄弟next-sibling连结符"></a> 下个兄弟(next-sibling)连结符</h2>
<p>下个兄弟(next-sibling)连结符是用来分开两个组合选择器的加号<code>+</code>。这两个组合选择器表示的元素有相同的父元素，并且第二个组合选择器表示的元素是第一个组合选择器表示的元素的直接后继。考虑相邻关系时非元素节点（如元素之间的文本）被忽略。<br />
例如<code>math + p</code>表示<code>&lt;math&gt;</code>后面紧跟着的<code>&lt;p&gt;</code>。<br />
<code>h1.opener + h2</code>表示具有类名<code>opener</code>的<code>&lt;h1&gt;</code>元素后面紧跟着的<code>&lt;h2&gt;</code>。</p>
<h2 id="后继兄弟subsequent-sibling连结符"><a class="markdownIt-Anchor" href="#后继兄弟subsequent-sibling连结符"></a> 后继兄弟(subsequent-sibling)连结符</h2>
<p>后继兄弟(subsequent-sibling)连结符是用来分开两个组合选择器的波浪号<code>~</code>。这两个组合选择器表示的元素有相同的父元素，并且第二个组合选择器表示的元素是第一个组合选择器表示的元素的后继（不需要是直接后继）。<br />
例如<code>h1 ~ pre</code>表示<code>&lt;pre&gt;</code>元素在<code>&lt;h1&gt;</code>元素后面。</p>
<h1 id="解析顺序"><a class="markdownIt-Anchor" href="#解析顺序"></a> 解析顺序</h1>
<p>CSS选择器是从右向左解析，对于选择器<code>div p em</code>，先筛选出所有的<code>em</code>元素，然后对每一个<code>em</code>沿着父元素向上查找<code>p</code>，如果找到就继续向上查找<code>div</code>，选择器中所有条件都满足时就加入结果集，如果一直到根元素<code>html</code>还没找到就停止。然后检查下一个<code>em</code>元素。<br />
再例如选择器<code>.foo ~ [role] + #foo</code>，先筛选出所有的<code>id</code>属性为<code>foo</code>的元素，然后对每一个<code>id=&quot;foo&quot;</code>的元素查找它具有属性<code>role</code>的直接前驱兄弟，如果没找到就停止，继续遍历下一个<code>id=&quot;foo&quot;</code>，如果找到就在该有<code>role</code>属性的元素向前继续查找具有类名<code>foo</code>的前驱兄弟。如果找到就加入结果集，没找到就停止，继续遍历下一个<code>id=&quot;foo&quot;</code>。<br />
<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20185756">为什么排版引擎解析 CSS 选择器时一定要从右往左解析？</a></p>
<h1 id="特指度"><a class="markdownIt-Anchor" href="#特指度"></a> 特指度</h1>
<p>如果两个或多个属性声明有冲突，声明所属的选择器特指度最大的那个胜出。<br />
一个选择器的特指度计算规则如下：</p>
<ul>
<li>选择器中ID选择器的数量（=A）</li>
<li>选择器中类选择器、属性选择器、伪类的数量（=B）</li>
<li>类型选择器和伪元素的数量（=C）</li>
<li>忽略通用选择器</li>
</ul>
<p>按A,B,C的顺序来比较特指度：A值大的特指度高，如果A值相同，再比较B值，B值大的特指度更高，如果B值相同，则再比较C值，C值大的特指度更高。</p>
<p>如果选择器是一个选择器列表，需要为列表中每一个选择器计算出特指度数字。对于针对列表的给定匹配过程，特指度实际上是列表中与所冲突的声明匹配的复杂选择器中特指度最大的那个。例如对于<code>&lt;p class=&quot;a&quot;&gt;qqqqq&lt;/p&gt;</code>和以下CSS规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#a</span> , <span class="selector-tag">p</span><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有<code>&lt;p&gt;</code>元素的<code>color</code>属性冲突，而选择器列表中匹配元素<code>&lt;p&gt;</code>的复杂选择器是<code>p.a</code>，因此对于声明<code>color: blue</code>来说，选择器列表的特指度是<code>B=1,C=1</code>。而对于列表中所匹配的<code>id=a</code>的元素，它的<code>color</code>属性所属的选择器列表的特指度是<code>A=1</code>。</p>
<p>一些伪类为其他选择器提供了求值上下文，所以专门为它们特别定义了特指度：</p>
<ul>
<li><code>:is()</code>、<code>:not()</code>和<code>:has()</code>伪类的特指度，是参数的选择器列表中特指度最大的复杂选择器的特指度。</li>
<li>类似的，<code>:nth-child()</code>和<code>:nth-last-child()</code>伪类的特指度，是伪类自身（作为一次伪类选择器计算）加它参数的选择器列表（如果有）中特指度最大的复杂选择器的特指度。</li>
<li><code>:where()</code>伪类的特指度是0。</li>
</ul>
<p>注意：允许不断重复相同的简单选择器，并且这种做法确实会增加特指度值。</p>
<p>注意：HTML的<code>style</code>属性上的声明被认为具有作者来源，特指度高于任何选择器。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/前端/CSS样式语言/选择器.html">https://rcocco.github.io/categories/计算机/前端/CSS样式语言/选择器.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/CSS%E6%A0%B7%E5%BC%8F%E8%AF%AD%E8%A8%80/CSS%E6%A6%82%E8%BF%B0.html"><i class="fa fa-chevron-left">  </i><span>CSS概述</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/CSS%E6%A0%B7%E5%BC%8F%E8%AF%AD%E8%A8%80/%E5%80%BC%E5%92%8C%E5%8D%95%E4%BD%8D.html"><span>值和单位</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>