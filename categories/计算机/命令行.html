<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="命令行"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>命令行 | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFshell"><span class="toc-number">1.</span> <span class="toc-text"> 什么是shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text"> 提示符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%8E%86%E5%8F%B2"><span class="toc-number">1.2.</span> <span class="toc-text"> 命令历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text"> 移动光标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E4%B8%8E%E7%B2%98%E8%B4%B4"><span class="toc-number">1.4.</span> <span class="toc-text"> 快速拷贝与粘贴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text"> 显示当前日期和时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%97%A5%E5%8E%86"><span class="toc-number">1.6.</span> <span class="toc-text"> 显示日历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.</span> <span class="toc-text"> 显示磁盘剩余空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98"><span class="toc-number">1.8.</span> <span class="toc-text"> 显示空闲内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E7%BB%88%E7%AB%AF%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.9.</span> <span class="toc-text"> 结束终端会话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.10.</span> <span class="toc-text"> 后台会话</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B7%B3%E8%BD%AC"><span class="toc-number">2.</span> <span class="toc-text"> 文件系统跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-number">2.1.</span> <span class="toc-text"> 当前工作目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.</span> <span class="toc-text"> 列出目录内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-number">2.3.</span> <span class="toc-text"> 更改当前目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 相对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 快捷操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">2.4.</span> <span class="toc-text"> 文件名规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A2%E7%A9%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text"> 探究操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text"> 选项和参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ls%E9%95%BF%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">3.2.</span> <span class="toc-text"> ls长格式输出的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text"> 确定文件类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text"> 浏览文本文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-number">3.5.</span> <span class="toc-text"> 符号链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">3.6.</span> <span class="toc-text"> 硬链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">4.</span> <span class="toc-text"> 操作文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text"> 通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">4.2.</span> <span class="toc-text"> 创建目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">4.3.</span> <span class="toc-text"> 复制文件和目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text"> 移动和重命名文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">4.5.</span> <span class="toc-text"> 删除文件和目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5"><span class="toc-number">4.6.</span> <span class="toc-text"> 创建链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5-2"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 硬链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5-2"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 符号链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text"> 使用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text"> 显示命令的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.2.</span> <span class="toc-text"> 显示可执行程序的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%97%E5%88%B0%E5%91%BD%E4%BB%A4%E6%96%87%E6%A1%A3"><span class="toc-number">5.3.</span> <span class="toc-text"> 得到命令文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 内建命令的帮助文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%94%A8%E6%B3%95%E4%BF%A1%E6%81%AF%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 显示用法信息的选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%A8%8B%E5%BA%8F%E6%89%8B%E5%86%8C%E9%A1%B5"><span class="toc-number">5.3.3.</span> <span class="toc-text"> 显示程序手册页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%A8%8B%E5%BA%8F%E6%89%8B%E5%86%8C%E9%A1%B5"><span class="toc-number">5.3.4.</span> <span class="toc-text"> 搜索程序手册页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%A8%8B%E5%BA%8Finfo%E6%9D%A1%E7%9B%AE"><span class="toc-number">5.3.5.</span> <span class="toc-text"> 显示程序Info条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readme%E6%96%87%E4%BB%B6%E5%92%8C%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E6%96%87%E6%A1%A3"><span class="toc-number">5.3.6.</span> <span class="toc-text"> README文件和其他程序文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%88%AB%E5%90%8Dalias%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">5.4.</span> <span class="toc-text"> 用别名(alias)创建命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.</span> <span class="toc-text"> 重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.1.</span> <span class="toc-text"> 标准输出重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.2.</span> <span class="toc-text"> 标准错误重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E9%94%99%E8%AF%AF%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.</span> <span class="toc-text"> 重定向标准输出和错误到同一个文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">6.4.</span> <span class="toc-text"> 处理不需要的输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5"><span class="toc-number">6.5.</span> <span class="toc-text"> 连接文件与重定向输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%BA%BF"><span class="toc-number">6.6.</span> <span class="toc-text"> 管道线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">6.7.</span> <span class="toc-text"> 过滤器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">175</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">命令行</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="什么是shell"><a class="markdownIt-Anchor" href="#什么是shell"></a> 什么是shell</h1>
<p>所谓“命令行”指的就是shell。shell是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。几乎所有的Linux发行版都提供一个名为<code>bash</code>的shell程序，bash是最初 Unix上由Steve Bourne写成的shell程序<code>sh</code>的增强版。</p>
<span id="more"></span>
<h2 id="提示符"><a class="markdownIt-Anchor" href="#提示符"></a> 提示符</h2>
<p>启动终端后能看到类似下面的文字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$</span><br><span class="line">ubuntu@VM-0-17-ubuntu:~$</span><br></pre></td></tr></table></figure>
<p>这叫做shell提示符，当shell准备好接受输入时就会出现，它可能以各种类似形式显示，取决于不同的Linux发行版或者用户自己定义的形式，通常包含<code>用户名@主机名</code>，紧接着当前工作目录和一个美元符号<code>$</code>。<code>$</code>表示当前shell只有普通用户权限，而如果最后一个字符是<code>#</code>，则表示当前shell有超级用户权限，这意味着我们或者是以root用户身份登录，或者是该终端提供管理员权限。</p>
<h2 id="命令历史"><a class="markdownIt-Anchor" href="#命令历史"></a> 命令历史</h2>
<p>按一下向上箭头<code>↑</code>，我们会看到刚才输入的命令重新出现在提示符之后，这叫做命令历史。许多Linux发行版默认保存最后输入的500个命令。<br />
按一下向下箭头<code>↓</code>，先前输入的命令就消失了。</p>
<h2 id="移动光标"><a class="markdownIt-Anchor" href="#移动光标"></a> 移动光标</h2>
<p>按向左箭头<code>←</code>或者向右箭头<code>→</code>，可以把光标进行移动，在想要的位置编辑命令。</p>
<h2 id="快速拷贝与粘贴"><a class="markdownIt-Anchor" href="#快速拷贝与粘贴"></a> 快速拷贝与粘贴</h2>
<p>不要在终端窗口使用Ctrl+C和Ctrl+V来执行拷贝和粘贴操作，它们在Windows将其定义为复制粘贴的含义许多年前就被赋予了不同的意义。<br />
shell程序虽然是和键盘打交道的，但也可以在终端仿真器中使用鼠标。窗口系统提供了一种机制，支持快速拷贝和粘贴。<br />
按下鼠标左键，沿着文本拖动鼠标（或者双击了一个单词）高亮了一些文本，这些高亮文本就被拷贝到了由窗口系统管理的缓冲区里。然后按下鼠标中键，文本就被粘贴到光标所在位置。<br />
Windows下的终端可能需要高亮后点击右键来进行复制，然后按下右键进行粘贴。</p>
<h2 id="显示当前日期和时间"><a class="markdownIt-Anchor" href="#显示当前日期和时间"></a> 显示当前日期和时间</h2>
<p><code>date</code>命令用于显示系统当前日期和时间，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-17-ubuntu:~$ date</span><br><span class="line">Tue Sep 22 19:42:29 CST 2020</span><br></pre></td></tr></table></figure>
<h2 id="显示日历"><a class="markdownIt-Anchor" href="#显示日历"></a> 显示日历</h2>
<p><code>cal</code>命令默认显示当前月份的日历，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-17-ubuntu:~$ cal</span><br><span class="line">   September 2020</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">       1  2  3  4  5</span><br><span class="line"> 6  7  8  9 10 11 12</span><br><span class="line">13 14 15 16 17 18 19</span><br><span class="line">20 21 22 23 24 25 26</span><br><span class="line">27 28 29 30</span><br></pre></td></tr></table></figure>
<h2 id="显示磁盘剩余空间"><a class="markdownIt-Anchor" href="#显示磁盘剩余空间"></a> 显示磁盘剩余空间</h2>
<p><code>df</code>命令默认显示磁盘剩余空间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-17-ubuntu:~$ df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">udev              471644       4    471640   1% /dev</span><br><span class="line">tmpfs             100888    5496     95392   6% /run</span><br><span class="line">/dev/vda1       51539404 2811516  46530692   6% /</span><br><span class="line">tmpfs             504432      24    504408   1% /dev/shm</span><br><span class="line">tmpfs               5120       0      5120   0% /run/lock</span><br><span class="line">tmpfs             504432       0    504432   0% /sys/fs/cgroup</span><br><span class="line">tmpfs             100884       0    100884   0% /run/user/500</span><br></pre></td></tr></table></figure>
<h2 id="显示空闲内存"><a class="markdownIt-Anchor" href="#显示空闲内存"></a> 显示空闲内存</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-17-ubuntu:~$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        1008864      137808       88684        5524      782372      698316</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>
<h2 id="结束终端会话"><a class="markdownIt-Anchor" href="#结束终端会话"></a> 结束终端会话</h2>
<p>可以通过关闭终端窗口，或者是在shell提示符下输入<code>exit</code>命令来终止一个终端会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h2 id="后台会话"><a class="markdownIt-Anchor" href="#后台会话"></a> 后台会话</h2>
<p>即使终端仿真器没有运行，后台仍然有几个终端会话运行着，被称为虚拟终端或者虚拟控制台。在大多数Linux发行版，这些终端会话都可以通过Ctrl+Alt+F1到Ctrl+Alt+F6访问。要从一个虚拟控制台转换到另一个，按下Alt+F1到Alt+F6中的一个。返回图形界面，按Alt+F7。</p>
<h1 id="文件系统跳转"><a class="markdownIt-Anchor" href="#文件系统跳转"></a> 文件系统跳转</h1>
<p>Linux以分层目录结构来组织所有文件，文件系统中的第一级目录称为根目录，根目录包含文件和子目录，子目录包含更多文件和子目录，以此类推。<br />
和Windows中每个存储设备都有一个独自的文件系统不同，Linux总是只有一个单一的文件系统树，而不管有多少个磁盘或存储设备连接到计算机上。根据系统管理员的兴致，存储设备挂在到目录树的各个节点上。</p>
<h2 id="当前工作目录"><a class="markdownIt-Anchor" href="#当前工作目录"></a> 当前工作目录</h2>
<p>在任意时刻，我们处于一个目录中，能看到这个目录包含的所有文件、通往上级目录（父目录）的路径、下面的各个子目录。我们所在的目录称为当前工作目录。<br />
用<code>pwd</code>(print working directory)命令显示当前工作目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure>
<p>当我们首次登录系统或者启动终端仿真器会话后，当前工作目录是我们的家目录，每个用户都有自己的家目录。当我们以普通用户的身份登录时，家目录是唯一允许写入文件的地方。</p>
<h2 id="列出目录内容"><a class="markdownIt-Anchor" href="#列出目录内容"></a> 列出目录内容</h2>
<p>用<code>ls</code>命令列出一个目录包含的文件及子目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls</span><br><span class="line">Desktop Documents Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure>
<p>除了当前工作目录外，也可以指定别的目录，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /usr</span><br><span class="line">bin  games  include  lib  <span class="built_in">local</span>  sbin  share  src</span><br></pre></td></tr></table></figure>
<p>还可以列出多个目录的内容，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls ~ /usr</span><br><span class="line">/home/me:</span><br><span class="line">Desktop  Documents  Music  Pictures  Public  Templates  Videos</span><br><span class="line"></span><br><span class="line">/usr:</span><br><span class="line">bin  games  include  lib  <span class="built_in">local</span>  sbin  share  src</span><br></pre></td></tr></table></figure>
<p>也可以改变输出格式，得到更多细节，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-17-ubuntu:~$ ls -l</span><br><span class="line">total 48</span><br><span class="line">drwxrwxrwx 2 ubuntu ubuntu 4096 Sep 16 23:51 article</span><br><span class="line">drwxrwxrwx 2 ubuntu ubuntu 4096 Sep 16 23:51 book</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 2946 Sep 16 21:39 epublib.py</span><br><span class="line">drwxrwxrwx 4 ubuntu ubuntu 4096 Sep 16 21:29 initialization</span><br><span class="line">-rwxrwxrwx 1 ubuntu ubuntu 9929 Sep 16 21:40 news.py</span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu 4096 Sep 16 21:40 __pycache__</span><br><span class="line">drwxrwxrwx 2 ubuntu ubuntu 4096 Sep 16 21:29 resource</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 9060 Sep 16 21:40 utils.py</span><br></pre></td></tr></table></figure>
<p>常用选项如下：</p>
<ul>
<li><code>-a</code> / <code>--all</code>： 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。</li>
<li><code>-d</code> / <code>--directory</code>： 通常，如果指定了目录名，<code>ls</code>命令会列出这个目录中的内容，而不是目录本身。把这个选项与<code>-l</code>选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。</li>
<li><code>-F</code> / <code>--classify</code>： 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是目录名，则会加上一个<code>/</code>字符。</li>
<li><code>-h</code> / <code>--human-readable</code>： 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。</li>
<li><code>-l</code>： 以长格式显示结果。</li>
<li><code>-r</code> / <code>--reverse</code>： 以相反的顺序来显示结果。通常，<code>ls</code>命令的输出结果按照字母升序排列。</li>
<li><code>-S</code>： 命令输出结果按照文件大小来排序。</li>
<li><code>-t</code>： 按照修改时间来排序。</li>
<li><code>-i</code>： 查看文件索引节点incode信息</li>
</ul>
<h2 id="更改当前目录"><a class="markdownIt-Anchor" href="#更改当前目录"></a> 更改当前目录</h2>
<p>使用<code>cd</code>命令更改工作目录。先输入<code>cd</code>然后输入想要去的工作目录的路径名。<br />
路径名就是沿着目录树的分支到达想要的目录期间所经过的路线。<br />
路径名可通过两种方式来指定，一种是绝对路径，另一种是相对路径。</p>
<h3 id="绝对路径"><a class="markdownIt-Anchor" href="#绝对路径"></a> 绝对路径</h3>
<p>绝对路径开始于根路径，紧跟着目录树的一个个分支，一直到达所期望的目录或文件。例如<code>/usr/bin</code>意味着从根目录（开头的<code>/</code>）开始，有一个叫<code>usr</code>的目录包含了目录<code>bin</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">[me@linuxbox /usr/bin]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/bin</span><br><span class="line">[me@linuxbox /usr/bin]$ ls</span><br><span class="line">...Listing of many, many files ...</span><br></pre></td></tr></table></figure>
<p>注意shell提示符的变化，为了方便，通常shell提示符自动显示工作目录名。</p>
<h3 id="相对路径"><a class="markdownIt-Anchor" href="#相对路径"></a> 相对路径</h3>
<p>相对路径开始于工作目录，由于从工作目录开始既可能向上也可能向下，为了能够用相对路径表示，我们在文件系统树中用符号点<code>.</code>表示工作目录，用<code>..</code>表示工作目录的父目录。<br />
例如，如果我们的工作目录是<code>/usr/bin</code>，想要将工作目录更改为<code>/usr</code>，有两种办法：</p>
<ol>
<li>使用绝对路径名： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox /usr/bin]$ <span class="built_in">cd</span> /usr</span><br><span class="line">[me@linuxbox /usr]$ <span class="built_in">pwd</span></span><br><span class="line">/usr</span><br></pre></td></tr></table></figure>
</li>
<li>使用相对路径名： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox /usr/bin]$ <span class="built_in">cd</span> ..</span><br><span class="line">[me@linuxbox /usr]$ <span class="built_in">pwd</span></span><br><span class="line">/usr</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两种方法都可以，我们应该选输入量少的那个。<br />
注意，在几乎所有情况下，都可以省略<code>./</code>，它是隐含的，如果不指定一个文件的路径，那它被默认为在当前工作目录下，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox /usr]$ <span class="built_in">cd</span> bin</span><br><span class="line">[me@linuxbox /usr]$ <span class="built_in">cd</span> ./bin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox /usr]$ <span class="built_in">cd</span> ..</span><br><span class="line">[me@linuxbox /usr]$ <span class="built_in">cd</span> ./..</span><br></pre></td></tr></table></figure>
<p>都是等价的</p>
<h3 id="快捷操作"><a class="markdownIt-Anchor" href="#快捷操作"></a> 快捷操作</h3>
<ol>
<li><code>cd</code>：更改工作目录为家目录</li>
<li><code>cd -</code>：更改工作目录为先前的工作目录</li>
<li><code>cd ˜user_name</code>：更改工作目录为用户的家目录，例如<code>cd ~bob</code>会更改工作目录到用户<code>bob</code>的家目录。</li>
</ol>
<h2 id="文件名规则"><a class="markdownIt-Anchor" href="#文件名规则"></a> 文件名规则</h2>
<ol>
<li>以<code>.</code>字符开头的文件名是隐藏文件，<code>ls</code>命令不能列出它们，需要用<code>ls -a</code>命令。</li>
<li>文件名和命令名是大小写敏感的，文件名<code>File1</code>和<code>file1</code>是指两个不同的文件名。</li>
<li>Linux没有文件扩展名的概念，可以用任何喜欢的名字来给文件起名，文件内容或用途由其他方法决定。</li>
<li>虽然Linux支持长文件名，文件名可能包含空格、标点符号，但标点符号仅限使用<code>.</code>，<code>-</code>，<code>_</code>。最重要的是不要在文件名中使用空格，如果想表示词与词的间隔，用下划线代替。</li>
</ol>
<h1 id="探究操作系统"><a class="markdownIt-Anchor" href="#探究操作系统"></a> 探究操作系统</h1>
<h2 id="选项和参数"><a class="markdownIt-Anchor" href="#选项和参数"></a> 选项和参数</h2>
<p>大多数命令经常有一个或多个用来改变命令行为的选项，选项后面可能带有一个或多个参数，看起来像这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> -options arguments</span><br></pre></td></tr></table></figure>
<p>大多数命令使用的选项是由一个中划线加上一个字符组成。但是许多命令也支持长选项，长选项由两个中划线加上一个单词组成。<br />
许多命令也允许把多个短选项串在一起使用，例如<code>ls</code>有两个选项，<code>l</code>选项产生长格式输出，<code>t</code>选项按文件修改时间的先后排序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -lt</span><br></pre></td></tr></table></figure>
<p>加上长选项<code>reverse</code>，结果会以相反顺序输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -lt --reverse</span><br></pre></td></tr></table></figure>
<h2 id="ls长格式输出的含义"><a class="markdownIt-Anchor" href="#ls长格式输出的含义"></a> ls长格式输出的含义</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 32059 2007-04-03 11:05 oo-cd-cover.odf</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-rw-r--r--</code>：对于文件的访问权限。第一个字符指明文件类型。在不同类型之间，开头的<code>-</code>说明是一个普通文件，<code>d</code>表明是一个目录，<code>l</code>是一个符号链接。其后三个字符是文件所有者的访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限。</li>
<li><code>1</code>：文件的硬链接数目</li>
<li><code>root</code>：文件所有者的用户名</li>
<li><code>root</code>：文件所属用户组的名字</li>
<li><code>32059</code>：以字节数表示的文件大小</li>
<li><code>2007-04-03 11:05</code>：上次修改文件的时间和日期</li>
<li><code>oo-cd-cover.odf</code>：文件名</li>
</ul>
<h2 id="确定文件类型"><a class="markdownIt-Anchor" href="#确定文件类型"></a> 确定文件类型</h2>
<p>Linux系统并不要求文件名反映文件内容，一个类似<code>picture.jpg</code>的文件名我们会期望它包含JPEG压缩图像，但Linux却不这样要求它，它完全可以是一个可执行脚本。<br />
使用<code>file</code>命令可以打印出文件内容的简单描述，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ file picture.jpg</span><br><span class="line">picture.jpg: JPEG image data, JFIF standard 1.01</span><br></pre></td></tr></table></figure>
<h2 id="浏览文本文件"><a class="markdownIt-Anchor" href="#浏览文本文件"></a> 浏览文本文件</h2>
<p>用<code>less</code>命令浏览文本文件，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ less /etc/passwd</span><br></pre></td></tr></table></figure>
<p>less程序常用的键盘命令如下：</p>
<ul>
<li><code>Page Up</code> / <code>b</code>：向上翻一页</li>
<li><code>Page Down</code> / <code>space</code>：向下翻一页</li>
<li><code>Up Arrow</code>：向上翻一行</li>
<li><code>Down Arrow</code>：向下翻一行</li>
<li><code>G</code>：移动到最后一行</li>
<li><code>1G</code> / <code>g</code>：移动到第一行</li>
<li><code>/charaters</code>：向下查找指定字符串</li>
<li><code>n</code>：向下查找下一个出现的字符串，这个字符串是之前所指定查找的</li>
<li><code>h</code>：显示帮助屏幕</li>
<li><code>q</code>：退出<code>less</code>程序</li>
</ul>
<h2 id="符号链接"><a class="markdownIt-Anchor" href="#符号链接"></a> 符号链接</h2>
<p>有时会看到一个目录列出这样一条信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -&gt; libc-2.6.so</span><br></pre></td></tr></table></figure>
<p>注意到这条信息第一个字符是<code>l</code>，并且有两个文件名。<br />
这是一个特殊文件，叫做符号链接（也称为软链接或者symlink）。符号链接使得一个文件可以被多个文件名所指向。<br />
考虑这样一种情景：一个程序要求使用名为<code>foo</code>的文件，但是<code>foo</code>经常改变版本号，为了方便管理版本，我们会希望在文件名中包含版本号，例如<code>foo-2.6</code>或<code>foo-2.7</code>，但这样一来，每次更新版本后，我们必须修改每个使用该文件的程序，使它们去寻找新文件名，这非常麻烦。<br />
但利用符号链接，我们可以创建叫做<code>foo</code>的符号链接，使它指向<code>foo-2.6</code>，这样一来，一个程序打开文件<code>foo</code>时，实际上打开的是<code>foo-2.6</code>。当更新版本后，我们只需要删除原来的符号链接，创建一个指向新版本的符号链接。想回到旧版本也很方便，只需删除指向新版本的符号链接，创建指向旧版本的符号链接即可。</p>
<h2 id="硬链接"><a class="markdownIt-Anchor" href="#硬链接"></a> 硬链接</h2>
<p>还有一种链接类型叫做硬链接，硬链接同样允许文件有多个名字，但是硬链接以不同的方法来创建多个文件名。</p>
<h1 id="操作文件和目录"><a class="markdownIt-Anchor" href="#操作文件和目录"></a> 操作文件和目录</h1>
<h2 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h2>
<p>因为shell频繁地使用文件名，shell提供了特殊字符来帮助你快速指定一组文件名。这些特殊字符叫做通配符。使用通配符允许你依据字符的组合模式来选择文件名。<br />
接受文件名作为参数的任何命令，都可以使用通配符。</p>
<table>
<thead>
<tr>
<th style="text-align:left">通配符</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">匹配任意多个字符（包括0个或者1个）</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">匹配任意一个字符（不包括0个）</td>
</tr>
<tr>
<td style="text-align:left"><code>[characters]</code></td>
<td style="text-align:left">匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>[!characters]</code></td>
<td style="text-align:left">匹配任意一个不属于字符集中的字符</td>
</tr>
<tr>
<td style="text-align:left"><code>[[:class:]]</code></td>
<td style="text-align:left">匹配任意一个属于指定字符类中的字符</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">常用字符类</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>[:alnum:]</code></td>
<td style="text-align:left">匹配任意一个字母或数字</td>
</tr>
<tr>
<td style="text-align:left"><code>[:alpha:]</code></td>
<td style="text-align:left">匹配任意一个字母</td>
</tr>
<tr>
<td style="text-align:left"><code>[:digit:]</code></td>
<td style="text-align:left">匹配任意一个数字</td>
</tr>
<tr>
<td style="text-align:left"><code>[:lower:]</code></td>
<td style="text-align:left">匹配任意一个小写字母</td>
</tr>
<tr>
<td style="text-align:left"><code>[:upper:]</code></td>
<td style="text-align:left">匹配任意一个大写字母</td>
</tr>
</tbody>
</table>
<p>借助通配符，可以为文件名构建非常复杂的选择标准。</p>
<ul>
<li><code>*</code>：所有文件</li>
<li><code>g*</code>：文件名以g开头的文件</li>
<li><code>b*.txt</code>：以b开头，中间有0个或任意多个字符，并以txt结尾的文件</li>
<li><code>Data???</code>：以Data开头，后面跟着3个字符的文件</li>
<li><code>[abc]*</code>：文件名以a或b或c开头的文件</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>：以<code>BACKUP.</code>开头，紧接着3个数字的文件</li>
<li><code>[[:upper:]]*</code>：以大写字母开头的文件</li>
<li><code>[![:digit:]]*</code>：不以数字开头的文件</li>
<li><code>*[[:lower:]123]</code>：以小写字母结尾，或者以数字1或2或3结尾的文件</li>
</ul>
<h2 id="创建目录"><a class="markdownIt-Anchor" href="#创建目录"></a> 创建目录</h2>
<p><code>mkdir</code>命令用来创建目录，它这样工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir directory...</span><br></pre></td></tr></table></figure>
<p>三个小圆点跟在命令参数后面表示这个参数可以重复，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1</span><br><span class="line">mkdir dir1 dir2 dir3</span><br></pre></td></tr></table></figure>
<p>分别创建一个目录dir1和三个目录dir1,dir2和dir3</p>
<h2 id="复制文件和目录"><a class="markdownIt-Anchor" href="#复制文件和目录"></a> 复制文件和目录</h2>
<p><code>cp</code>命令可以复制文件和目录，它有两种用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp item1 item2</span><br></pre></td></tr></table></figure>
<p>复制单个文件或目录item1到文件或目录item2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp item... directory</span><br></pre></td></tr></table></figure>
<p>复制多个文件或目录到一个目录下</p>
<p>常用选项如下：</p>
<ul>
<li><code>-a</code> / <code>--archive</code>：复制文件和目录，以及它们的属性</li>
<li><code>-i</code> / <code>--interactive</code>：在覆盖已存在文件之前，提示用户确认。如果这个选项不指定，<code>cp</code>命令会默认覆盖文件。</li>
<li><code>-r</code> / <code>--recursive</code>：递归地复制目录及目录中的内容。当复制目录时，需要这个选项（或者-a 选项），否则会忽略目录只复制文件。</li>
<li><code>-u</code> / <code>--update</code>：当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</li>
<li><code>-v</code> / <code>--verbose</code>：显示详细的命令操作信息，例如复制了哪些文件到哪些地方</li>
</ul>
<p>常见示例：</p>
<ul>
<li><code>cp file1 file2</code>：复制文件 file1 内容到文件 file2。如果 file2 已经存在，file2的内容会被 file1 的内容覆盖。如果 file2 不存在，则会创建file2。</li>
<li><code>cp -i file1 file2</code>：这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被覆盖之前，会提示用户确认是否要覆盖。</li>
<li><code>cp file1 file2 dir1</code>：复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。</li>
<li><code>cp dir1/* dir2</code>：使用一个通配符，通配符会将<code>dir1/*</code>展开为所有<code>dir1</code>中的文件名，等价于<code>dir1/a dir1/b ...</code>，在目录 dir1 中的所有文件都被复制到目录 dir2 中。dir2 必须已经存在。</li>
<li><code>cp -r dir1 dir2</code>：复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在，创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。如果目录 dir2 存在，则目录 dir1 (和目录中的内容) 将会被复制到 dir2 中。</li>
</ul>
<h2 id="移动和重命名文件"><a class="markdownIt-Anchor" href="#移动和重命名文件"></a> 移动和重命名文件</h2>
<p><code>mv</code>命令可以执行文件移动和文件命名任务，但不管哪种操作，完成后原来的文件名都将不存在。<code>mv</code>的使用方法与<code>cp</code>很像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv item1 item2</span><br></pre></td></tr></table></figure>
<p>把文件或目录item1移动或重命名为item2，或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv item... directory</span><br></pre></td></tr></table></figure>
<p>把一个或多个项目从一个目录移动到另一个目录</p>
<p>常用选项如下：</p>
<ul>
<li><code>-i</code> / <code>--interactive</code>：在覆盖已存在文件之前，提示用户确认。如果这个选项不指定，<code>mv</code>命令会默认覆盖文件。</li>
<li><code>-u</code> / <code>--update</code>：当把文件从一个目录移动到另一个目录时，仅移动目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</li>
<li><code>-v</code> / <code>--verbose</code>：显示详细的命令操作信息，例如移动了哪些文件到哪些地方</li>
</ul>
<p>常见示例：</p>
<ul>
<li><code>mv file1 file2</code>：移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容覆盖。如果 file2 不存在，则创建 file2。这两种情况下，file1 都不再存在。</li>
<li><code>mv -i file1 file2</code>：这条命令和上面的命令一样，除了如果 file2 存在的话，在文件 file2 被覆盖之前，会提示用户确认是否要覆盖。</li>
<li><code>mv file1 file2 dir1</code>：移动 file1 和 file2 到目录 dir1。目录 dir1 必须存在。</li>
<li><code>mv dir1 dir2</code>：如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1的内容到目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。</li>
</ul>
<h2 id="删除文件和目录"><a class="markdownIt-Anchor" href="#删除文件和目录"></a> 删除文件和目录</h2>
<p><code>rm</code>命令用来删除文件和目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm item...</span><br></pre></td></tr></table></figure>
<p>item代表一个或多个文件目录</p>
<p>常用选项如下：</p>
<ul>
<li><code>-i</code> / <code>--interactive</code>：在删除已存在的文件前，提示用户确认信息。如果不指定这个选项，rm 会默默地删除文件</li>
<li><code>-r</code> / <code>--recursive</code>：递归地删除文件，这意味着，如果要删除一个目录，而此目录又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</li>
<li><code>-f</code> / <code>--force</code>：不显示提示信息。<code>rm</code>命令默认会在删除不存在的文件给出提示并且返回非正常退出代码<code>1</code>，以及在删除写保护的文件时要求用户确认，<code>-f</code>选项覆盖了“–interactive”选项，并且使得在上述操作时不再提示直接确认并返回正常退出代码<code>0</code>。</li>
<li><code>-v</code> / <code>--verbose</code>：显示详细的命令操作信息，例如删除了哪些文件和目录</li>
</ul>
<p>常见示例：</p>
<ul>
<li><code>rm file1</code>：默默地删除文件</li>
<li><code>rm -i file1</code>：除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。</li>
<li><code>rm -r file1 dir1</code>：删除文件 file1, 目录 dir1，及 dir1 中的内容。</li>
<li><code>rm -rf file1 dir1</code>：同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍<br />
会继续执行。</li>
</ul>
<p>注意：<br />
小心的使用<code>rm</code>，Linux中没有复原命令。<br />
尤其要小心通配符，例如你只想删除一个目录中的HTML文件，输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm *.html</span><br></pre></td></tr></table></figure>
<p>这是正确的，但如果不小心多输入了一个空格</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm * .html</span><br></pre></td></tr></table></figure>
<p>这个命令实际上会删除目录中的所有文件，还会抱怨没有文件叫做<code>.html</code><br />
因此，当你使用带有通配符的 rm 命令时（除了仔细检查输入的内容外），先用 ls 命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头按键，重新调用刚刚执行的命令，用 rm 替换 ls。</p>
<h2 id="创建链接"><a class="markdownIt-Anchor" href="#创建链接"></a> 创建链接</h2>
<p><code>ln</code>命令既可创建硬链接，也可以创建符号链接。</p>
<h3 id="硬链接-2"><a class="markdownIt-Anchor" href="#硬链接-2"></a> 硬链接</h3>
<p>硬链接是最初Unix创建链接的方式，在文件系统中，每个文件是对应一个inode数据，并用一个整数来指代这个incode。incode本身没有名字，因此一个文件名实际上就是一个硬链接，一个文件名关联到某个incode对应的文件。通过<code>ls -li</code>命令可以看到incode。<br />
创建硬链接，就是创建一个新的文件名，使它关联到某个incode对应的文件。<br />
硬链接和原始文件是无法区分的，实际上也没有所谓的“原始文件”，又或者说每个硬链接都是原始文件。对任何一个硬链接关联的文件修改时，自然也会影响所有其他文件名关联的对象，因为它们指向的都是相同的incode对应的文件。<br />
Linux维护关联到每个incode上的硬链接数目，创建一个新的硬链接时链接数就加1，删除一个硬链接时链接数就减1。只有当链接数为0时才会真正从文件系统删除文件对象，其他时候只不过是删除所关联的文件名。<br />
由于硬链接只是文件名，因此不管新建多少个文件名，都不会占用额外的空间。<br />
硬链接有两个局限：</p>
<ol>
<li>不能创建目录的硬链接
<ul>
<li>因为硬链接与原来的文件本身无法区分开，如果允许创建目录的硬链接，那么一个子目录完全可能指向它的祖父目录，进而破坏了文件系统的有向无环图结构，由于在遍历时我们无法检测到环，这会造成死循环。</li>
</ul>
</li>
<li>不能创建一个文件所在文件系统之外（例如其他磁盘分区）的文件的硬链接。
<ul>
<li>每个文件系统会为文件提供不同的incode，对于一个相同的incode，在一个磁盘分区与另一个磁盘分区所关联的文件完全可能是不同的。如果允许创建到其他文件系统的硬链接，这个incode到底应该指的是哪一个分区的文件？</li>
</ul>
</li>
</ol>
<p>要创建一个硬链接，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file link</span><br></pre></td></tr></table></figure>
<h3 id="符号链接-2"><a class="markdownIt-Anchor" href="#符号链接-2"></a> 符号链接</h3>
<p>符号链接类似一个快捷方式，它本身是一个新的文件，有着和所关联文件不同的incode并且占用不同的空间，它存储的内容是所关联文件的完整路径。<br />
在访问或者修改符号链接时，系统会自动的去访问或修改它所关联的文件。<br />
如果删除符号链接，源文件仍然存在，不会被删除。<br />
如果删除源文件，符号链接仍然存在，但是此时它是一个失效的坏链接，因为所指向的位置并不存在文件。通常在<code>ls</code>命令中用红色文本显示坏链接。<br />
要创建一个符号链接，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s path link</span><br></pre></td></tr></table></figure>
<p><code>path</code>可以是一个文件或是一个目录，既可以是绝对链接也可以是相对链接。<br />
注意，当它是相对链接时，起始路径是<code>link</code>所在位置。在下列代码中，误以为符号链接指向的是当前目录<code>playground</code>下的<code>fun</code>文件，但实际指向的是<code>dir1</code>目录下的<code>fun</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rcocco@DESKTOP:~/playground$ ls</span><br><span class="line">dir1  dir2  fun  fun-hard  fun-sym</span><br><span class="line">rcocco@DESKTOP:~/playground$ ln -s fun dir1/fun-sym-error</span><br><span class="line">rcocco@DESKTOP:~/playground$ ls -l dir1</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 rcocco rcocco 3 Sep 23 18:57 fun-sym-error -&gt; fun</span><br></pre></td></tr></table></figure>
<p>正确的做法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rcocco@DESKTOP-QA2OJJO:~/playground$ ls</span><br><span class="line">dir1  dir2  fun  fun-hard  fun-sym</span><br><span class="line">rcocco@DESKTOP-QA2OJJO:~/playground$ ln -s ../fun dir1/fun-sym-ok</span><br><span class="line">rcocco@DESKTOP-QA2OJJO:~/playground$ ls -l dir1</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 rcocco rcocco 3 Sep 23 18:57 fun-sym-error -&gt; fun</span><br><span class="line">lrwxrwxrwx 1 rcocco rcocco 6 Sep 23 19:00 fun-sym-ok -&gt; ../fun</span><br></pre></td></tr></table></figure>
<p>使用相对路径名有一些好处，在移动或者重命名包含符号链接的目录时，不会破坏链接。</p>
<h1 id="使用命令"><a class="markdownIt-Anchor" href="#使用命令"></a> 使用命令</h1>
<p>命令是以下四种形式之一：</p>
<ol>
<li>一个可执行程序，就像我们看到的位于目录<code>/usr/bin</code>中的文件一样。这一类程序可以是由诸如<code>C</code>和<code>C++</code>写成的程序编译的二进制文件，也可以是由诸如<code>shell</code>、<code>python</code>等脚本语言写成的程序。</li>
<li>一个内建于shell自身的命令，bash支持若干命令，内部叫做shell命令(builtins)。例如<code>cd</code>命令。</li>
<li>一个shell函数。这些是小规模的shell脚本，它们混合到环境变量中。</li>
<li>一个命令别名。我们可以定义自己的命令，建立在其他命令之上。</li>
</ol>
<h2 id="显示命令的类型"><a class="markdownIt-Anchor" href="#显示命令的类型"></a> 显示命令的类型</h2>
<p><code>type</code>命令用于显示一个给定的命令属于以上四种中的哪一种形式。它像这样工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> <span class="built_in">type</span></span><br><span class="line"><span class="built_in">type</span> is a shell builtins</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> ls</span><br><span class="line">ls is aliased to `ls --color=tty`</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> cp</span><br><span class="line">cp is /bin/cp</span><br><span class="line">[me@linuxbox ~]$ <span class="function"><span class="title">log</span></span>()&#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">&quot;log something&quot;</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> <span class="built_in">log</span></span><br><span class="line"><span class="built_in">log</span> is a <span class="keyword">function</span></span><br><span class="line"><span class="built_in">log</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;log something&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="显示可执行程序的位置"><a class="markdownIt-Anchor" href="#显示可执行程序的位置"></a> 显示可执行程序的位置</h2>
<p>有时不只安装了可执行程序的一个版本，为了确定一个可执行程序的准确位置，使用<code>which</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">which</span> ls</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure>
<p>这个命令只对可执行程序有效，不包括内建命令和命令别名。例如对内建命令<code>cd</code>使用<code>which cd</code>，将得不到回应，或者报错。</p>
<h2 id="得到命令文档"><a class="markdownIt-Anchor" href="#得到命令文档"></a> 得到命令文档</h2>
<h3 id="内建命令的帮助文档"><a class="markdownIt-Anchor" href="#内建命令的帮助文档"></a> 内建命令的帮助文档</h3>
<p><code>help</code>命令用于提供内建命令的帮助文档，用法是<code>help</code>加空格加内建命令，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">help</span> <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span>: <span class="built_in">cd</span> [-L|-P] [dir]</span><br><span class="line">Change ...</span><br></pre></td></tr></table></figure>
<p>命令语法说明中的方括号表示可选项目，竖杠表示互斥选项。这里意味着<code>cd</code>命令可能有一个<code>-L</code>选项或者<code>-P</code>选项，然后可能有一个参数<code>dir</code></p>
<h3 id="显示用法信息的选项"><a class="markdownIt-Anchor" href="#显示用法信息的选项"></a> 显示用法信息的选项</h3>
<p>许多可执行程序支持一个<code>--help</code>选项，这个选项是显示命令所支持的语法和选项说明。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ mkdir --<span class="built_in">help</span></span><br><span class="line">Usage: mkdir [OPTION] DIRECTORY...</span><br><span class="line">Create ...</span><br></pre></td></tr></table></figure>
<p>一些程序不支持 --help 选项，但不管怎样试一下。这经常会导致输出错误信息，但同时能揭示一样的命令用法信息。</p>
<h3 id="显示程序手册页"><a class="markdownIt-Anchor" href="#显示程序手册页"></a> 显示程序手册页</h3>
<p>许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页 (man page)。<br />
一个特殊的叫做 man 的分页程序，可用来浏览他们。它是这样使用的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man program</span><br></pre></td></tr></table></figure>
<p>“program”是要浏览的命令名。<br />
手册文档的格式有点不同，一般地包含一个标题、命令语法的纲要、命令用途的说明、以及每个命令选项的列表和说明。然而，手册文档通常并不包含实例，它打算作为一本参考手册，而不是教程。作为一个例子，浏览一下 ls 命令的手册文档：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ man ls</span><br></pre></td></tr></table></figure>
<p>在大多数 Linux 系统中，man 使用 less 工具来显示参考手册，所以当浏览文档时，你所熟悉的 less 命令都能有效。</p>
<p>man 所显示的参考手册，被分成几个章节，它们不仅仅包括用户命令，也包括系统管理员命令、程序接口、文件格式等等。下表描绘了手册的布局：</p>
<ol>
<li>用户命令</li>
<li>程序接口内核系统调用</li>
<li>C库函数程序接口</li>
<li>特殊文件，比如说设备结点和驱动程序</li>
<li>文件格式</li>
<li>游戏娱乐，如屏幕保护程序</li>
<li>其他方面</li>
<li>系统管理员命令</li>
</ol>
<p>有时候，我们需要查看参考手册的特定章节，从而找到我们需要的信息。例如我们要查找一种文件格式，但同时它也是一个命令名。如果没有指定章节号，我们总是得到第一个匹配项，可能是第一章节的用户命令。我们这样使用 man 命令，来指定章节号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man section search_term</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ man 5 passwd</span><br></pre></td></tr></table></figure>
<p>命令运行结果会显示文件<code>/etc/passwd</code>的文件格式说明手册。</p>
<h3 id="搜索程序手册页"><a class="markdownIt-Anchor" href="#搜索程序手册页"></a> 搜索程序手册页</h3>
<p><code>apropos</code>命令或者<code>man -k</code>命令与选项，用来在参考手册中搜索某个关键字，查询所有标题中包含该关键词的手册页名字及章节，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ man -k passwd</span><br><span class="line">chgpasswd (8)        - update group passwords <span class="keyword">in</span> batch mode</span><br><span class="line">chpasswd (8)         - update passwords <span class="keyword">in</span> batch mode</span><br><span class="line">fgetpwent_r (3)      - get passwd file entry reentrantly</span><br><span class="line">getpwent_r (3)       - get passwd file entry reentrantly</span><br><span class="line">gpasswd (1)          - administer /etc/group and /etc/gshadow</span><br><span class="line">grub-mkpasswd-pbkdf2 (1) - generate hashed password <span class="keyword">for</span> GRUB</span><br><span class="line">openssl-passwd (1ssl) - compute password hashes</span><br><span class="line">pam_localuser (8)    - require users to be listed <span class="keyword">in</span> /etc/passwd</span><br><span class="line">passwd (1)           - change user password</span><br><span class="line">passwd (1ssl)        - compute password hashes</span><br><span class="line">passwd (5)           - the password file</span><br><span class="line">passwd2des (3)       - RFS password encryption</span><br><span class="line">update-passwd (8)    - safely update /etc/passwd, /etc/shadow and /etc/group</span><br></pre></td></tr></table></figure>
<p><code>whatis</code>命令或者<code>man -f</code>命令与选项，用来在参考手册中搜索某个关键字，查询手册页名字为该关键词的手册页及章节，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ man -f passwd</span><br><span class="line">passwd (5)           - the password file</span><br><span class="line">passwd (1)           - change user password</span><br><span class="line">passwd (1ssl)        - compute password hashes</span><br></pre></td></tr></table></figure>
<h3 id="显示程序info条目"><a class="markdownIt-Anchor" href="#显示程序info条目"></a> 显示程序Info条目</h3>
<p>GNU 项目提供了一个命令程序手册页的替代物，称为 “info”。<br />
info 程序读取 info 文件，info 文件是树型结构，分化为各个结点，每一个包含一个题目。info 文件包含超级链接，它可以让你从一个结点跳到另一个结点。一个超级链接可通过它开头的星号来辨别出来，把光标放在它上面并按下 enter 键，就可以激活它。输入 “info”，接着输入程序名称，启动 info。下表中的命令，当显示一个 info 页面时，用来控制阅读器。</p>
<ul>
<li><code>?</code>：显示命令帮助</li>
<li><code>PgUp or Backspace</code>：显示上一页</li>
<li><code>PgDn or Space</code>：显示下一页</li>
<li><code>n</code>：下一个，显示下一个结点</li>
<li><code>p</code>：上一个，显示上一个结点</li>
<li><code>u</code>：显示当前结点的父节点，通常是个菜单</li>
<li><code>Enter</code>：激活光标位置下的超级链接</li>
<li><code>q</code>：退出</li>
</ul>
<h3 id="readme文件和其他程序文档"><a class="markdownIt-Anchor" href="#readme文件和其他程序文档"></a> README文件和其他程序文档</h3>
<p>许多安装在你系统中的软件，都有自己的文档文件，这些文件位于<code>/usr/share/doc</code>目录下。这些文件大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。一些文件是 HTML 格式，可用网页浏览器来阅读。我们可能遇到许多以 “.gz” 结尾的文件。这表示 gzip 压缩程序已经压缩了这些文件。gzip 软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip 压缩的文本文件的内容。</p>
<h2 id="用别名alias创建命令"><a class="markdownIt-Anchor" href="#用别名alias创建命令"></a> 用别名(alias)创建命令</h2>
<p>多个命令可以放在一行，只要用分号<code>;</code>隔开，例如<code>cd /usr; ls; cd</code>，先更改目录到<code>/usr</code>，然后列出目录内容，最后回到家目录。<br />
可以用<code>alias</code>命令把这一串命令转变为一个命令，第一步就是为新命令起一个名字，首先用<code>type</code>命令查询名字是否已经存在系统中。<br />
然后我们创建命令别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">alias</span> foo=<span class="string">&#x27;cd /usr; ls; cd -&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在命令 “alias” 之后，输入所起的名字&quot;foo&quot;，紧接着（没有空格）是一个等号，等号之后是一串用引号引起的字符串，字符串的内容要赋值给 foo。我们定义了别名之后，这个命令别名可以使用在任何地方。</p>
<p>删除别名，使用<code>unalias</code>命令，像这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">unalias</span> foo</span><br><span class="line">[me@linuxbox ~]$ <span class="built_in">type</span> foo</span><br><span class="line">bash: <span class="built_in">type</span>: foo: not found</span><br></pre></td></tr></table></figure>
<p>有时也会特意将别名命名为已经存在的命令，例如之前见到的 ls 命令，它把一个普遍用到的颜色选项加到了默认的<code>ls</code>命令后面。</p>
<p>要查看所有定义在系统环境中的别名，使用不带参数的<code>alias</code>命令。</p>
<h1 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h1>
<p>I/O 重定向可能是命令行最酷的特性。“I/O” 代表输入/输出，通过这个工具，你可以将命令的输入来源以及输出地点重定向为文件。也可以把多个命令连接起来组成一个强大的命令管道。</p>
<p>我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成：</p>
<ol>
<li>程序运行结果；这是说，程序要完成的功能。</li>
<li>我们得到状态和错误信息，这些告诉我们程序进展。</li>
</ol>
<p>如果我们观察一个命令，像 ls，会看到它的运行结果和错误信息显示在屏幕上。<br />
与 Unix 主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行结果输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下，标准输入连接到键盘。I/O 重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，但是通过 I/O 重定向，我们可以做出改变。</p>
<h2 id="标准输出重定向"><a class="markdownIt-Anchor" href="#标准输出重定向"></a> 标准输出重定向</h2>
<p>使用<code>&gt;</code>重定向符后接文件名，将标准输出重定向到除屏幕以外的另一个文件。例如，把<code>ls</code>命令的结果存储到文件中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</span><br><span class="line">[me@linuxbox ~]$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 167878 2008-02-01 15:07 ls-output.txt</span><br></pre></td></tr></table></figure>
<p>如果调整一下，把<code>ls</code>的参数换成一个不存在的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt</span><br><span class="line">ls: cannot access /bin/usr: No such file or directory</span><br><span class="line">[me@linuxbox ~]$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 me me 0 2008-02-01 15:08 ls-output.txt</span><br></pre></td></tr></table></figure>
<p>我们收到一个错误信息。这讲得通，因为我们指定了一个不存在的目录<code>/bin/usr</code>, 但是为什么这条错误信息显示在屏幕上而不是被重定向到文件<code>ls-output.txt</code>？答案是，ls 程序不把它的错误信息输送到标准输出。反而，像许多写得不错的 Unix 程序，ls 把错误信息送到标准错误。因为我们只是重定向了标准输出，而没有重定向标准错误，所以错误信息被送到屏幕。</p>
<p>另外，注意到文件的长度变成了0，这是因为使用<code>&gt;</code>重定向符输出结果时，目标文件总是从开头被重写。因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ &gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<p>简单地使用重定向符<code>&gt;</code>，没有命令在它之前，这会清空一个已存在文件的内容或是创建一个新的空文件。</p>
<p>如果想把重定向结果追加到文件后面，而不是每次从开头重写文件，使用<code>&gt;&gt;</code>重定向符，像这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<p>使用<code>&gt;&gt;</code>操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会被创建，就如使用了<code>&gt;</code>操作符。</p>
<h2 id="标准错误重定向"><a class="markdownIt-Anchor" href="#标准错误重定向"></a> 标准错误重定向</h2>
<p>标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符 0、1 和 2。shell 使用文件描述符提供了一种表示法来重定向文件。单纯的标准输出重定向<code>&gt;</code>实际上是<code>1&gt;</code>。因为标准错误和文件描述符 2 一样，我们用这种表示法来重定向标准错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; ls-error.txt</span><br></pre></td></tr></table></figure>
<p>注意文件描述符<code>2</code>必须紧挨着重定向符号<code>&gt;</code>，如果分开<code>ls -l /bin/usr 2 &gt; ls-error.txt</code>，<code>2</code>将被理解为<code>ls</code>命令的参数，然后将标准输出重定向到<code>ls-error.txt</code>文件。</p>
<h2 id="重定向标准输出和错误到同一个文件"><a class="markdownIt-Anchor" href="#重定向标准输出和错误到同一个文件"></a> 重定向标准输出和错误到同一个文件</h2>
<p>有时我们需要把一个命令的所有输出保存到一个文件里，这就需要同时重定向标准输出和标准错误。<br />
当然可以这么写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-all-output.txt 2&gt; ls-all-output.txt</span><br></pre></td></tr></table></figure>
<p>但是如果文件相同，写两遍文件名很麻烦。可以这么写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>意思是，先将标准输出重定向到<code>ls-output.txt</code>，然后将标准错误重定向到标准输出对应的文件，也就是<code>ls-output.txt</code>。重定向的顺序很重要，如果是<code>ls -l /bin/usr 2&gt;&amp;1 &gt;ls-output.txt</code>将会先将标准错误重定向到标准输出，然后将标准输出重定向到<code>ls-output.txt</code>文件。<br />
在<code>2&gt;&amp;1</code>这个语法中<code>2&gt;&amp;</code>必须连着写，理由如下：</p>
<ol>
<li>之所以要加<code>&amp;</code>是因为<code>2&gt;1</code>表示重定向标准错误到名为<code>1</code>的文件中，<code>&amp;</code>在这里表示后面的是文件描述符而不是文件名。</li>
<li><code>2</code>必须紧挨着重定向符号<code>&gt;</code>，如果分开<code>ls -l /bin/usr &gt; ls-output.txt 2 &gt;&amp;1</code>，将被理解为先将命令的标准输出重定向到<code>ls-output.txt</code>文件，列出目录<code>/bin/usr</code>的列表，然后将命令的标准输出重定向到它自己的标准输出，列出目录<code>2</code>的列表</li>
<li><code>&gt;</code>和<code>&amp;</code>之间不能有空格，<code>2&gt; &amp;1</code>会被理解为将标准错误重定向到一个名为<code>&amp;1</code>的文件，然而Linux文件名中的<code>&amp;</code>是不能直接输入的，所以会报语法错误。如果输入的是<code>2&gt;\&amp;1</code>，将会被正确理解为重定向到<code>&amp;1</code>文件。</li>
<li><code>&amp;</code>在这里表示后面是文件描述符，你可能会觉得<code>&amp;2&gt;&amp;1</code>更标准，但是<code>ls &amp;2&gt;&amp;1</code>会被理解为<code>ls &amp;</code>和<code>2&gt;&amp;1</code>，即<code>ls</code>在后台运行，然后将命令<code>2</code>的标准输出重定向到它自己的标准输出。</li>
</ol>
<p>新版本的bash提供了更加简便的写法<code>&amp;&gt;</code>来将标准输出和标准错误重定向到相同文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<h2 id="处理不需要的输出"><a class="markdownIt-Anchor" href="#处理不需要的输出"></a> 处理不需要的输出</h2>
<p>如果我们不想要一个命令的输出结果，希望直接丢弃，可以把它重定向到<code>/dev/null</code>，这个文件是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做任何处理。<br />
要隐藏命令错误信息可以这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /bin/usr 2&gt; /dev/null</span><br></pre></td></tr></table></figure>
<h2 id="连接文件与重定向输入"><a class="markdownIt-Anchor" href="#连接文件与重定向输入"></a> 连接文件与重定向输入</h2>
<p><code>cat</code>命令可以读取一个或多个文件，然后复制它们到标准输出，就像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file...</span><br></pre></td></tr></table></figure>
<p>因为<code>cat</code>可以接受多个文件作为参数，所以也经常用来把文件连接到一起，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat movie.mpeg.0* &gt; movie.mpeg</span><br></pre></td></tr></table></figure>
<p>由于通配符总是以有序的方式展开，所以连接文件的顺序得到了正确处理。<br />
如果不给<code>cat</code>参数，它会从标准输入读入数据，默认情况下标准输入连接到键盘，因此它会等待用户输入内容，当用户输入Ctrl+D告诉<code>cat</code>已经在标准输入中到达了文件末尾（EOF），它就会复制标准输入到标准输出。所以出现输入的文本重复出现这种现象。<br />
如果此时我们重定向标准输出，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ cat &gt; lazy_dog.txt</span><br><span class="line">The quick brown fox jumped over the lazy dog.</span><br></pre></td></tr></table></figure>
<p>然后输入Ctrl+D，文本就被保存到了<code>lazy_dog.txt</code>文件。</p>
<p>使用<code>&lt;</code>重定向操作符，可以把标准输入从键盘改成文件，当然对于<code>cat</code>来说，<code>cat &lt; lazy_dog.txt</code>和<code>cat lazy_dog.txt</code>结果是一样的。</p>
<h2 id="管道线"><a class="markdownIt-Anchor" href="#管道线"></a> 管道线</h2>
<p>使用管道操作符<code>|</code>，一个命令的标准输出可以通过管道送到另一个命令的标准输入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure>
<p>例如用<code>less</code>来查看任何命令的输出，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls -l /usr/bin | less</span><br></pre></td></tr></table></figure>
<h2 id="过滤器"><a class="markdownIt-Anchor" href="#过滤器"></a> 过滤器</h2>
<p>过滤器也是一个命令，它接受输入，以某种方式改变它，然后输出它。例如<code>sort</code>会将所有输入排序然后输出。<br />
利用管道线结合过滤器可以对数据完成一些复杂的操作，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ ls /bin /usr/bin | sort | less</span><br></pre></td></tr></table></figure>
<p>这里<code>ls</code>命令列出两个目录，普通情况下它会分别输出，但通过<code>sort</code>可以将所有输出的文件和文件夹混合在一起排序然后由<code>less</code>查看</p>
<p>权限 775：111 111 101 对应rwxrwxr-x</p>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<p>《The Linux Command Line》</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/命令行.html">https://rcocco.github.io/categories/计算机/命令行.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F.html"><i class="fa fa-chevron-left">  </i><span>图片格式</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/Android.html"><span>Android</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>