<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Git"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco2014@gmail.com"><meta name="copyright" content="rcocco"><title>Git | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E4%B8%8E%E5%85%B6%E4%BB%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text"> Git与其他版本控制系统的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B8%8E%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.</span> <span class="toc-text"> 三种状态与三个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text"> 工作流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEgit"><span class="toc-number">2.</span> <span class="toc-text"> 配置Git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A7%93%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1"><span class="toc-number">2.1.</span> <span class="toc-text"> 设置姓名和邮箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text"> 提高命令输出的可读性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text"> 修改文本编辑器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.</span> <span class="toc-text"> 检查配置信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text"> 初始化仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%93%E5%BA%93"><span class="toc-number">3.1.</span> <span class="toc-text"> 在本地创建新仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">3.2.</span> <span class="toc-text"> 从远程仓库克隆到本地</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text"> 查看状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text"> 将文件添加到暂存区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text"> 未跟踪文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%B2%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text"> 已跟踪文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6"><span class="toc-number">5.3.</span> <span class="toc-text"> 忽略文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9B%B4%E6%94%B9%E5%89%8D%E5%90%8E%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text"> 查看更改前后的差别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0"><span class="toc-number">7.</span> <span class="toc-text"> 提交更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text"> 删除文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text"> 移动文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2"><span class="toc-number">10.</span> <span class="toc-text"> 查看提交历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C"><span class="toc-number">11.</span> <span class="toc-text"> 撤销操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%8A%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">11.1.</span> <span class="toc-text"> 修改上次提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E5%88%B0%E4%B9%8B%E5%89%8D%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="toc-number">11.2.</span> <span class="toc-text"> 恢复到之前的提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E6%9A%82%E5%AD%98"><span class="toc-number">11.3.</span> <span class="toc-text"> 取消暂存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">11.4.</span> <span class="toc-text"> 撤销对文件的修改</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="toc-number">12.</span> <span class="toc-text"> 本地分支</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="toc-number">12.1.</span> <span class="toc-text"> 分支的实质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><span class="toc-number">12.2.</span> <span class="toc-text"> 创建分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"><span class="toc-number">12.3.</span> <span class="toc-text"> 切换分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-number">12.4.</span> <span class="toc-text"> 贮藏与清理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.5.</span> <span class="toc-text"> 合并分支综合示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="toc-number">12.6.</span> <span class="toc-text"> 分支管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">13.</span> <span class="toc-text"> 远程仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">13.1.</span> <span class="toc-text"> 查看远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">13.2.</span> <span class="toc-text"> 添加远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%E6%8A%93%E5%8F%96%E4%B8%8E%E6%8B%89%E5%8F%96"><span class="toc-number">13.3.</span> <span class="toc-text"> 从远程仓库中抓取与拉取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">13.4.</span> <span class="toc-text"> 推送到远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">13.5.</span> <span class="toc-text"> 查看某个远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-number">13.6.</span> <span class="toc-text"> 远程仓库的重命名与移除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-number">14.</span> <span class="toc-text"> 远程分支</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5"><span class="toc-number">14.1.</span> <span class="toc-text"> 远程分支不会自动同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="toc-number">14.2.</span> <span class="toc-text"> 跟踪分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E5%8F%96"><span class="toc-number">14.3.</span> <span class="toc-text"> 拉取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-number">14.4.</span> <span class="toc-text"> 删除远程分支</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">15.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">171</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Git</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/">软件使用问题</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>;;;</p>
<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p>Git是一个版本控制软件，开发者将源代码存入名叫“Git 仓库”的资料库中并加以使用。<br />
Github是一个网站，是在网络上提供 Git 仓库的一项服务。</p>
<span id="more"></span>
<h2 id="git与其他版本控制系统的区别"><a class="markdownIt-Anchor" href="#git与其他版本控制系统的区别"></a> Git与其他版本控制系统的区别</h2>
<p>Git和其他版本控制系统的区别在于对待数据的方式。<br />
其他版本控制系统通常是基于差异的版本控制，它们保存的信息是：每个文件中增加了什么内容、删除了什么内容。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004113024676_28248.png" alt="存储每个文件与初始版本的差异" width="621" /><br />
而在Git中，每当提交更新或保存项目时，Git会为所有文件创建一个快照，然后保存这个快照。为了节约空间与时间，如果文件没有被修改，Git就不会重新保存该文件，而是创建一个链接指向之前存储的文件。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004113252239_25045.png" alt="存储项目随时间改变的快照" width="621" /></p>
<h2 id="三种状态与三个阶段"><a class="markdownIt-Anchor" href="#三种状态与三个阶段"></a> 三种状态与三个阶段</h2>
<p>Git中有三种状态，你的文件可能处于其中之一：</p>
<ul>
<li>已修改(modified)：修改了文件，但还没保存到数据库中。</li>
<li>已暂存(staged)：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交(commited)：数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这使得Git项目有三个阶段：工作区、暂存区和Git目录。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004115331339_5843.png" alt="工作目录、暂存区域以及 Git 仓库" width="621" /></p>
<ul>
<li>工作区：是项目的某个版本提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</li>
<li>Git目录：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</li>
</ul>
<p>如果 Git 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。<br />
如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。<br />
如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。</p>
<h2 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h2>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<h1 id="配置git"><a class="markdownIt-Anchor" href="#配置git"></a> 配置Git</h1>
<p>Git提供了<code>git config</code>命令来进行一些配置，这些配置保存在几个文件中：</p>
<ol>
<li><code>/etc/gitconfig</code>文件：保存系统中所有用户的通用配置，需要使用<code>--system</code>选项来读写它，通常只有超级管理员才能修改它。</li>
<li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件：保存当前用户的通用配置，需要使用<code>--global</code>选项来读写它。注意通用配置对所有仓库都生效。</li>
<li>当前仓库的Git目录中的<code>config</code>文件，即<code>.git/config</code>：不加选项默认情况下就是读写它。</li>
</ol>
<p>下面的配置文件优先于上面的配置文件，例如当前仓库的Git目录中的配置文件优先于<code>~/.gitconfig</code>文件。</p>
<h2 id="设置姓名和邮箱"><a class="markdownIt-Anchor" href="#设置姓名和邮箱"></a> 设置姓名和邮箱</h2>
<p>第一次使用Git软件首先要设置姓名和邮箱，姓名和邮箱会用在 Git 的提交日志中。由于在 GitHub 上公开仓库时，这里的姓名和邮箱地址也会随着提交日志一同被公开，所以请不要使用不便公开的隐私信息。<br />
下面两条命令，第一条设置姓名，第二条设置邮箱。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your_name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>姓名和邮箱信息保存在<code>~/.gitconfig</code>文件，也可以直接在这个文件中修改姓名和邮箱。</p>
<h2 id="提高命令输出的可读性"><a class="markdownIt-Anchor" href="#提高命令输出的可读性"></a> 提高命令输出的可读性</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui auto</span><br></pre></td></tr></table></figure>
<p><code>~/.gitconfig</code>中会增加下面一行。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[color]</span></span><br><span class="line">  <span class="attr">ui</span> = auto</span><br></pre></td></tr></table></figure>
<p>这样一来，各种命令的输出就会变得更容易分辨。</p>
<h2 id="修改文本编辑器"><a class="markdownIt-Anchor" href="#修改文本编辑器"></a> 修改文本编辑器</h2>
<p>当 Git 需要你输入信息时会调用文本编辑器。 如果未配置，Git 会使用操作系统默认的文本编辑器。Linux系统下需要输入编辑器的名字，而Windows系统下需要输入编辑器可执行文件的完整路径。<br />
下面两条命令，第一条适用于Linux系统，将文本编辑器设置为vim，第二条适用于Windows系统，将文本编辑器设置为VS Code。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor vim</span><br><span class="line">git config --global core.editor <span class="string">&quot;C:/Program Files/Microsoft VS Code\Code.exe&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="检查配置信息"><a class="markdownIt-Anchor" href="#检查配置信息"></a> 检查配置信息</h2>
<p>使用<code>git config --list</code>命令来列出所有 Git 当时能找到的配置。<br />
你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。<br />
如果只想看到具体某一项配置，也可以输入<code>git config &lt;key&gt;</code>，其中<code>&lt;key&gt;</code>是某个配置的名字，例如<code>user.name</code></p>
<h1 id="初始化仓库"><a class="markdownIt-Anchor" href="#初始化仓库"></a> 初始化仓库</h1>
<p>初始化仓库有两种办法：</p>
<ul>
<li>一种是在将本地尚未进行版本控制的目录变成Git仓库。</li>
<li>另一种是从其他地方克隆一个已经存在的Git仓库到本地。</li>
</ul>
<h2 id="在本地创建新仓库"><a class="markdownIt-Anchor" href="#在本地创建新仓库"></a> 在本地创建新仓库</h2>
<p>进入到要被Git管理的目录，然后输入<code>git init</code>。成功后该目录下会有一个隐藏的<code>.git</code>子目录。</p>
<h2 id="从远程仓库克隆到本地"><a class="markdownIt-Anchor" href="#从远程仓库克隆到本地"></a> 从远程仓库克隆到本地</h2>
<p>使用<code>git clone</code>命令从下载远程仓库的所有内容到本地。<br />
下面的命令会在当前目录下创建一个名为<code>training-kit</code>的目录，并在这个目录下初始化一个<code>.git</code>文件夹，从远程仓库拉取下所有数据放入<code>.git</code>文件夹，然后从中读取最新版本的文件的拷贝。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/github/training-kit.git</span><br></pre></td></tr></table></figure>
<p>如果想修改目录的名字，可以在URL后面指定了一个新的目录名，例如下面的命令会在当前目录创建一个名为<code>mygit</code>的目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/github/training-kit.git mygit</span><br></pre></td></tr></table></figure>
<h1 id="查看状态"><a class="markdownIt-Anchor" href="#查看状态"></a> 查看状态</h1>
<p><code>git status</code>命令用于显示各文件的状态。<br />
工作目录下的每个文件都只可能是这几种状态：</p>
<ul>
<li>已跟踪：表示文件已经被纳入了版本控制，Git已经知道这个文件，在上一次快照中有他们的记录。在工作一段时间后，它们的状态可能是未修改、已修改或已暂存。</li>
<li>未跟踪：除了已跟踪文件之外的所有文件都是未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。</li>
</ul>
<p><img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004141428305_30501.png" alt="文件的状态变化周期" width="621" /></p>
<p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为Git刚刚检出了它们，而你尚未编辑过它们。输入<code>git status</code>命令会看到这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>这说明工作目录是干净的，所有已跟踪文件在上次提交后都没有更改过。而且当前目录下没有出现任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是“master”,这是默认的分支名。</p>
<p>现在在目录下创建一个新的<code>README</code>文件，果之前并不存在这个文件，使用<code>git status</code>命令，你将看到一个新的未跟踪文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>
<p>可以看到输出的信息告诉你，新建的<code>README</code>文件出现在<code>Untracked files</code>下面。未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理<code>README</code>这个文件。</p>
<h1 id="将文件添加到暂存区"><a class="markdownIt-Anchor" href="#将文件添加到暂存区"></a> 将文件添加到暂存区</h1>
<p><code>git add</code>是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p>
<h2 id="未跟踪文件"><a class="markdownIt-Anchor" href="#未跟踪文件"></a> 未跟踪文件</h2>
<p>对于一个未跟踪的文件，使用<code>git add</code>命令开始跟踪它，例如<code>git add README</code>。此时再运行<code>git status</code>会看到<code>README</code>文件已跟踪，并处于暂存状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure>
<p>只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行<code>git add</code>时的版本将被留存在后续的历史记录中。<br />
<code>git add</code>命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<h2 id="已跟踪文件"><a class="markdownIt-Anchor" href="#已跟踪文件"></a> 已跟踪文件</h2>
<p>对于一个已跟踪的文件，例如<code>CONTRIBUTING.md</code>，如果你修改了它的内容，再输入<code>git status</code>命令，会看到类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>文件<code>CONTRIBUTING.md</code>出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行<code>git add</code>命令。</p>
<h2 id="忽略文件"><a class="markdownIt-Anchor" href="#忽略文件"></a> 忽略文件</h2>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的 .a 文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="comment"># 忽略任何目录下名为 build 的文件夹</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span></span><br><span class="line"><span class="comment"># 两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<h1 id="查看更改前后的差别"><a class="markdownIt-Anchor" href="#查看更改前后的差别"></a> 查看更改前后的差别</h1>
<p>要查看尚未暂存的文件更新了哪些部分，即工作目录中当前文件和暂存区域快照之间的差异，可以不加参数使用<code>git diff</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index e69de29..cb5dc9f 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+<span class="comment"># Git教程</span></span><br></pre></td></tr></table></figure>
<p><code>+</code>号标出的是新添加的行，<code>-</code>号标出的是被删除的行。上面显示的内容中，工作目录中的当前文件比起暂存区中的文件新添加了一行<code># Git教程</code>。<br />
注意，不加参数的<code>git diff</code>本身只显示尚未暂存的改动，如果你已经暂存了所有更新过的文件，运行<code>git diff</code>后就不会有任何输出。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，即已暂存文件与最后一次提交的文件差异，使用<code>git diff --cached</code>命令。</p>
<h1 id="提交更新"><a class="markdownIt-Anchor" href="#提交更新"></a> 提交更新</h1>
<p>每次准备提交前，先用<code>git status</code>看下，你所需要的文件是不是都已暂存起来了，然后使用<code>git commit</code>命令提交更新。<br />
在提交时需要输入提交信息，它是对这个提交的概述，最好具有意义，以便将来在历史记录中能方便的找到所需的提交记录。</p>
<ul>
<li>如果提交信息很简短，适合在命令行中输入，使用<code>git commit -m</code>命令，例如<code>&quot;git commit -m &quot;something you write&quot;</code>，其中参数后的被引号括起来的<code>something you write</code>就是提交信息。</li>
<li>如果提交信息很长，需要在文本编辑器中输入，不加<code>-m</code>直接使用<code>git commit</code>命令。Git就会启动文本编辑器。并显示如下文本：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span><br><span class="line"><span class="comment"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Initial commit</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment"># (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># new file: README.md</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
第一行是空行，以<code>#</code>开头的行是注释，注释所在行会被忽略，不会保存到提交信息中。<br />
对于较长的提交信息，一般在第一行简述内容，空一行，然后写详细内容。<br />
写完后保存并关闭编辑器，刚才在文本编辑器中写的提交信息就会被提交。<br />
如果不想提交，可以将提交信息留空，直接关闭编辑器，提交就会中止。</li>
</ul>
<p>提交完成后会出现类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[master 463dc4f] Story 182: Fix benchmarks <span class="keyword">for</span> speed</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure>
<p>它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h1 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h1>
<p>删除文件时需要使用<code>git rm</code>命令，如果只是简单地从工作目录中手工删除文件，运行<code>git status</code>时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到，此时还是需要运行<code>git rm</code>记录来此次移除文件的操作。下一次提交时，该文件就不再纳入版本管理了。<br />
如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>如果想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项，例如<code>git rm --cached README</code>，<code>git rm</code>命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。</p>
<h1 id="移动文件"><a class="markdownIt-Anchor" href="#移动文件"></a> 移动文件</h1>
<p>移动文件时需要使用<code>git mv</code>命令，例如<code>git mv file_from file_to</code>。<br />
<code>git mv README.md README</code>就相当于三条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv README.md README</span><br><span class="line">git rm README.md</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure>
<p>如果分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code>需要一条命令而非三条命令，直接用<code>git mv</code>方便得多。 不过有时候用其他工具批处理重命名的话，要记得在提交前删除旧的文件名，再添加新的文件名。</p>
<h1 id="查看提交历史"><a class="markdownIt-Anchor" href="#查看提交历史"></a> 查看提交历史</h1>
<p><code>git log</code>命令可以查看以往仓库中提交的日志。包括什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。类似下面的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">commit cd246af63a29f611cf80ee1d512a3c31d0bed9d2</span><br><span class="line">Author: alex &lt;alex@gmail.com&gt;</span><br><span class="line">Date:   Sat Oct 3 18:51:45 2020 +0800</span><br><span class="line"></span><br><span class="line">    First commit.</span><br><span class="line"></span><br><span class="line">    something <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p>commit 栏旁边显示的“cd246a……”是代表这个提交的哈希值。Git 的其他命令中，在引用某个提交时会用到这个哈希值。<br />
Author 栏显示我们给 Git 设置的用户名和邮箱地址。<br />
Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息。</p>
<ul>
<li>有时不想看到很长的提交信息，可以使用<code>git log --pretty=short</code>命令，让每个提交信息只显示第一行。</li>
<li>有时不想看到作者时间等信息，只想知道提交的哈希值以及第一行提交信息，可以使用<code>git log --pretty=oneline</code>命令，它把一个提交的各种信息简短的写在一行里。</li>
<li>只要在 git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。例如<code>git log README.md</code></li>
<li>如果想查看提交所带来的改动，可以加上 <code>-p</code>参数，文件的前后差别就会显示在提交信息之后，例如<code>git log -p README.md</code>，就可以只查看 <a target="_blank" rel="noopener" href="http://README.md">README.md</a> 文件的提交日志以及提交前后的差别。</li>
<li><code>git log --graph</code>命令可以用图表形式形象地展示你的分支、合并历史。</li>
</ul>
<h1 id="撤销操作"><a class="markdownIt-Anchor" href="#撤销操作"></a> 撤销操作</h1>
<h2 id="修改上次提交"><a class="markdownIt-Anchor" href="#修改上次提交"></a> 修改上次提交</h2>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有<code>--amend</code>选项的提交命令<code>git commit --amend</code>来重新提交。这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。<br />
例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<h2 id="恢复到之前的提交"><a class="markdownIt-Anchor" href="#恢复到之前的提交"></a> 恢复到之前的提交</h2>
<p>Git使用<code>git reset --hard</code>命令将仓库的 HEAD、暂存区和当前工作树恢复到之前的某次提交的状态。<br />
首先需要知道恢复到哪个提交，通过<code>git log</code>可以查看到历次提交的哈希值，在恢复命令后面输入想要恢复的那次提交的哈希值，就可以完全恢复到该时间点的状态，例如<code>git reset --hard cd24</code>。哈希值不必输入完整，一般只需要输前四位即可，如果有多个提交前四位相同，就需要继续输到能够区分于其他提交的长度。<br />
如果不想输入哈希值，也可以使用简便写法，在Git中，<code>HEAD</code>表示最新的提交，<code>HEAD^</code>表示上一个提交，<code>HEAD^^</code>表示上上个提交，即每往前一个提交，就在后面加一个符号<code>^</code>。符号多时不容易数，所以<code>HEAD^^^</code>也可以写成<code>HEAD~3</code>。</p>
<p>如果已经恢复到之前的某次提交，想反悔，同样可以使用<code>git reset --hard</code>命令，但需要知道对应提交的哈希值。<code>git log</code>是看不到相对于最新提交的将来版本的哈希值的，需要使用<code>git reflog</code>命令查看提交与恢复记录。</p>
<h2 id="取消暂存"><a class="markdownIt-Anchor" href="#取消暂存"></a> 取消暂存</h2>
<p>如果已经使用<code>git add</code>命令暂存了文件，又希望撤回。在输入<code>git status</code>命令时在 “Changes to be committed” 文字正下方会提示你使用<code>git restore --staged &lt;file&gt;</code>来取消暂存，例如<code>git restore --staged a.txt</code>。</p>
<h2 id="撤销对文件的修改"><a class="markdownIt-Anchor" href="#撤销对文件的修改"></a> 撤销对文件的修改</h2>
<p>如果你并不想保留对<code>CONTRIBUTING.md</code>文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code>也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>即Changes not staged for commit 文字正下方提示你使用<code>git restore &lt;file&gt;</code>来撤回对工作目录中的文件的修改。</p>
<h1 id="本地分支"><a class="markdownIt-Anchor" href="#本地分支"></a> 本地分支</h1>
<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。</p>
<h2 id="分支的实质"><a class="markdownIt-Anchor" href="#分支的实质"></a> 分支的实质</h2>
<p>如前所述，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 <strong>快照</strong> 。</p>
<p>每次使用<code>git add</code>暂存文件时，暂存操作会为每一个文件计算SHA-1检验和，然后把当前版本的文件保存成一个blob对象。<br />
每次使用<code>git commit</code>提交时，提交操作会把每一个目录中的blob对象的指针、blob对象的名字、其他子目录的tree对象的指针保存成一个tree对象。然后把提交的作者、时间、提交信息、根目录的tree对象的指针，以及指向这个提交的父对象的指针，一起保存成一个commit对象。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004164136969_15351.png" alt="首次提交对象及其树结构" width="621" /><br />
首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004164331607_4465.png" alt="提交对象及其父对象" width="621" /><br />
Git 的分支，其实本质上仅仅是指向提交对象的可变指针，所以它的创建和销毁都非常高效。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004164449577_25949.png" alt="分支及其提交历史" width="621" /></p>
<h2 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h2>
<p>分支只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code>命令，即<code>git branch testing</code>。这会在当前所在的提交对象上创建一个指针，如下图。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004164750200_27646.png" alt="两个指向相同提交历史的分支" width="621" /><br />
为了知道当前在哪一个分支上，Git还有一个名为 HEAD 的特殊指针。它指向当前所在的分支。在本例中，你仍然在 master 分支上。 因为<code>git branch</code>命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。如果想要创建分支的同时切换到新新建的那个分支，可以使用<code>git checkout -b</code>命令。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004164956370_4766.png" alt="HEAD 指向当前所在的分支" width="621" /><br />
你可以简单地使用<code>git log</code>命令查看各个分支当前所指的对象。提供这一功能的参数是 <code>--decorate</code>。在输出中可以看到，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f30ab (HEAD -&gt; master, testing) add feature <span class="comment">#32 - ability to add new formats to the central interface</span></span><br><span class="line">34ac2 Fixed bug <span class="comment">#1328 - stack overflow under certain conditions</span></span><br><span class="line">98ca9 The initial commit of my project</span><br></pre></td></tr></table></figure>
<h2 id="切换分支"><a class="markdownIt-Anchor" href="#切换分支"></a> 切换分支</h2>
<p>要切换到一个已存在的分支，你需要使用<code>git checkout</code>命令。 例如切换到新创建的 testing 分支去，使用<code>git checkout testing</code>。这样 HEAD 就指向 testing 分支了。如图。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004165325865_27174.png" alt="HEAD 指向当前所在的分支" width="621" /><br />
如果此时再提交一次，可以发现 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行<code>git checkout</code>时所指的对象。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004165439035_20609.png" alt="HEAD 分支随着提交操作自动向前移动" width="621" /><br />
还可以再切换回 master 分支，输入<code>git checkout master</code>。如图。这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004165730174_10506.png" alt="检出时 HEAD 随之移动" width="621" /><br />
如果此时再次进行提交，就会如下图，项目的提交历史出现了分叉。因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004165905858_17746.png" alt="项目分叉历史" width="621" /></p>
<h2 id="贮藏与清理"><a class="markdownIt-Anchor" href="#贮藏与清理"></a> 贮藏与清理</h2>
<p>为了不让当前分支的修改影响到其他分支，在切换分支前需要保证工作目录是干净的。有两个办法：</p>
<ul>
<li>如果做完了一个阶段的任务，可以暂存并提交所有文件，工作目录就会是干净的。</li>
<li>如果工作没做完，使用<code>git stash</code>或者<code>git stash push</code>将已跟踪的文件贮藏，存储到栈上。此时再查看<code>git status</code>会提示工作目录是干净的。之后可以使用<code>git stash list</code>看到所有贮藏记录，然后用<code>git stash apply</code>把最新一次的贮藏恢复到当前工作目录，又或者根据记录中的名字用<code>git stash apply stash@&#123;2&#125;</code>恢复更早的贮藏。恢复贮藏不会自动删除它，要想删除栈上的贮藏，需要使用<code>git stash drop</code>加上要删除的贮藏的名字。如果想恢复最新的贮藏同时删除栈上的贮藏，可以用一条命令<code>git stash pop</code>完成。应用贮藏时不要求目录是干净的，也不要求应用到当初贮藏的分支，但可能出现合并冲突。</li>
</ul>
<h2 id="合并分支综合示例"><a class="markdownIt-Anchor" href="#合并分支综合示例"></a> 合并分支综合示例</h2>
<p>假设当前有两次提交，第一次提交包括一个index.html的网页文件，第二次提交包括一个CSS文件。记录如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commit 3249ecc69d93af4a4a70168e287f1423c5f35151 (HEAD -&gt; master)</span><br><span class="line">Author: rcocco &lt;rcocco@qq.com&gt;</span><br><span class="line">Date:   Sun Oct 4 17:18:19 2020 +0800</span><br><span class="line"></span><br><span class="line">    update css</span><br><span class="line">commit 470c2c8dc7f4486a369a9e2dcd56741067149313</span><br><span class="line">Author: rcocco &lt;rcocco@qq.com&gt;</span><br><span class="line">Date:   Sun Oct 4 17:17:48 2020 +0800</span><br><span class="line"></span><br><span class="line">    update index page</span><br></pre></td></tr></table></figure>
<ul>
<li>开启新任务：为了网页更好看，你现在打算编写一个新的CSS文件。<br />
一个新任务应该创建基于master创建一个新分支，这是因为master分支通常是主干分支，主干分支中并没有开发到一半的代码，可以随时供他人查看，因而可以放心大胆的从其创建分支，我们在新分支上进行的任务也不影响其他人从主干分支创建分支，使用<code>git branch iss53</code>命令创建一个名为 iss53 的分支，然后用<code>git checkout iss53</code>切换到该分支（也可以使用<code>git checkout -b iss53</code>一条命令创建并切换到该分支）。</li>
<li>新的CSS编写了一半，你突然接到电话说你之前编写的网页文件有问题，需要紧急修改。<br />
切换分支前需要保证目录是干净的。<code>git status</code>检查一下，目录不是干净的，把文件暂存，然后<code>git stash</code>贮藏。再<code>git status</code>一下，目录是干净的。<code>git checkout master</code>切换到 master 分支，在master分支的基础上创建新的修复分支<code>git checkout -b hotfix</code>。修改并提交后，<code>git checkout master</code>回到 master 分支，然后用<code>git merge master</code>将 hotfix 分支合并回 master 分支。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   Updating 3249ecc..95289a3</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 10 ++++++----</span><br><span class="line"> 1 file changed, 6 insertions(+), 4 deletions(-)</span><br></pre></td></tr></table></figure>
可以看到Fast-forward这个词，由于你想要合并的分支 hotfix 所指向的提交 C4 是你所在的提交 C2 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201004195252599_31869.png" alt="master 被快进到 hotfix" width="621" /><br />
关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix 分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支，即<code>git branch -d hotfix</code>。</li>
<li>现在可以回到之前工作的分支 iss53，然后<code>git stash apply</code>恢复贮藏，完成工作后切回 master 分支合并。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> my.css | 7 +++++++</span><br><span class="line"> 1 file changed, 7 insertions(+)</span><br><span class="line"> create mode 100644 my.css  </span><br></pre></td></tr></table></figure>
这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201005093840864_21985.png" alt="一次典型合并中所用到的三个快照" width="621" /><br />
和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201005093959702_7583.png" alt="一个合并提交" width="621" /><br />
合并完成后就可以<code>git branch -d iss53</code>删除分支。</li>
<li>有时在两个分支对同一个文件的同一个部分做了不同的修改，这时Git就没有办法采用上面两种策略进行合并， Git不知道怎样合并才是你需要的，它会产生合并冲突：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging my.css</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> my.css</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">(fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">(use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">(use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line">    both modified:   my.css</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.footer &#123;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">  color: red;</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">  color: blue;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss02</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[target] &#123;</span></span><br><span class="line"><span class="string">  font-size: 16px;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>与<code>=======</code> 之间的部分是当前 HEAD 的内容，<code>=======</code>与<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss02</code>之间的部分是要合并的 iss02 分支中的内容。我们在编辑器中将其改成我们希望的文件的最终的样子，既可以保留上面的部分，也可以保留下面的部分，还可以全部去掉重写，并且要删掉<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss02</code>等行，因为它们并不是文件最终样子的一部分。<br />
在修改完毕后，我们需要<code>git add</code>暂存文件然后<code>git commit</code>进行提交。这次提交就会成功创建一个合并提交。</li>
</ul>
<h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h2>
<ul>
<li>不加参数的<code>git branch</code>命令可以显示当前所有分支的列表：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iss53</span><br><span class="line">*master</span><br><span class="line">testing</span><br></pre></td></tr></table></figure>
可以看到 master 分支左侧标有<code>*</code>（星号），表示这是我们当前所在的分支。也就是当前 HEAD 指针所指向的分支。</li>
<li>如果加选项<code>-v</code>，即<code>git branch -v</code>，可以额外看到每个分支的最后一次提交是什么。</li>
<li><code>git branch --merged</code>可以列出列表中已经合并到当前分支的分支，在这个列表中分支名字前没有<code>*</code>号的分支通常可以使用<code>git branch -d</code>删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。。反之，<code>git branch --no-merged</code>可以列出列表中尚未合并到当前分支的分支，不能使用<code>git branch -d</code>命令删除它。除非使用<code>-D</code>选项强制删除。</li>
<li><code>git branch -a</code>可以连远程分支一并列出</li>
</ul>
<h1 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h1>
<h2 id="查看远程仓库"><a class="markdownIt-Anchor" href="#查看远程仓库"></a> 查看远程仓库</h2>
<p>如果想查看你已经配置的远程仓库服务器，可以运行<code>git remote</code>命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字。<br />
你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>
<p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure>
<p>这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限</p>
<h2 id="添加远程仓库"><a class="markdownIt-Anchor" href="#添加远程仓库"></a> 添加远程仓库</h2>
<p>之前使用的<code>git clone</code>命令是自动添加远程仓库的， 如果想自己来手动添加仓库，使用<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程 Git 仓库，同时指定一个方便使用的简写。例如<code>git remote add pb https://github.com/paulboone/ticgit</code>。<br />
现在你可以在命令行中使用字符串<code>pb</code>来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行<code>git fetch pb</code></p>
<h2 id="从远程仓库中抓取与拉取"><a class="markdownIt-Anchor" href="#从远程仓库中抓取与拉取"></a> 从远程仓库中抓取与拉取</h2>
<p>从远程仓库中获得数据，可以执行：<code>git fetch &lt;remote&gt;</code>。这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。<br />
如果你使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意<code>git fetch</code>命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。<br />
如果你的当前分支设置了跟踪远程分支， 那么可以用<code>git pull</code>命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，<code>git clone</code>命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h2 id="推送到远程仓库"><a class="markdownIt-Anchor" href="#推送到远程仓库"></a> 推送到远程仓库</h2>
<p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：<code>git push origin master</code>。如果你已经设置了本地分支跟踪的上游分支，也可以直接<code>git push</code>。<br />
只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p>
<h2 id="查看某个远程仓库"><a class="markdownIt-Anchor" href="#查看某个远程仓库"></a> 查看某个远程仓库</h2>
<p>如果想要查看某一个远程仓库的更多信息，可以使用<code>git remote show &lt;remote&gt;</code>命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>
<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull， 就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p>
<h2 id="远程仓库的重命名与移除"><a class="markdownIt-Anchor" href="#远程仓库的重命名与移除"></a> 远程仓库的重命名与移除</h2>
<p>你可以运行<code>git remote rename</code>来修改一个远程仓库的简写名。 例如，想要将<code>pb</code>重命名为<code>paul</code>，可以用<code>git remote rename</code>。例如<code>git remote rename pb paul</code>。<br />
值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。</p>
<p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用<code>git remote remove</code>或<code>git remote rm</code>，例如<code>git remote remove paul</code>。<br />
一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
<h1 id="远程分支"><a class="markdownIt-Anchor" href="#远程分支"></a> 远程分支</h1>
<p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过<code>git ls-remote &lt;remote&gt;</code>来显式地获得远程引用的完整列表， 或者通过<code>git remote show &lt;remote&gt;</code>获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>的形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看origin/master分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以origin/iss53来表示。</p>
<p>假设你的网络里有一个在git.ourcompany.com的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为origin/master。 这是一个远程跟踪分支，你不能直接在这个分支上进行工作，所以Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201005104138645_23318.png" alt="克隆之后的服务器与本地仓库" width="621" /></p>
<h2 id="远程分支不会自动同步"><a class="markdownIt-Anchor" href="#远程分支不会自动同步"></a> 远程分支不会自动同步</h2>
<p>如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 <a target="_blank" rel="noopener" href="http://git.ourcompany.com">git.ourcompany.com</a> 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。<br />
<img src="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/_v_images/20201005104353472_17421.png" alt="本地与远程的工作可以分叉" width="621" /><br />
此时你再<code>git push &lt;remote&gt; &lt;branch&gt;</code>会失败，提示你推送失败，远程仓库包括你本地没有的工作，通常是因为其他人已经推送了，要求你首先同步获取远程仓库的内容才能推送。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;https://github.com/rcocco/bgdata.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
<p>用<code>git fetch &lt;remote&gt;</code>命令更新本地数据库，移动远程分支的指针，然而当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。<br />
可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;serverfix&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="跟踪分支"><a class="markdownIt-Anchor" href="#跟踪分支"></a> 跟踪分支</h2>
<p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;serverfix&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;serverfix&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;sf&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在，本地分支 sf 会自动从 origin/serverfix 拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>
<p>如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should <span class="keyword">do</span> it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>
<p>这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。<br />
需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。</p>
<h2 id="拉取"><a class="markdownIt-Anchor" href="#拉取"></a> 拉取</h2>
<p>当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<h2 id="删除远程分支"><a class="markdownIt-Anchor" href="#删除远程分支"></a> 删除远程分支</h2>
<p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<p>《Github入门与实践》<br />
<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/315911/git-for-beginners-the-definitive-practical-guide#316055">Git for beginners: The definitive practical guide</a><br />
<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">《Pro Git》</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco2014@gmail.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/软件使用问题/Git.html">https://rcocco.github.io/categories/计算机/软件使用问题/Git.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/Chrome.html"><i class="fa fa-chevron-left">  </i><span>Chrome</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/Github.html"><span>Github</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>