<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Express"><meta name="keywords" content=""><meta name="author" content="rcocco,rcocco@qq.com"><meta name="copyright" content="rcocco"><title>Express | rcocco's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f232b8a2af9088714735280ce974c8b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-193110637-1', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text"> 概览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text"> 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text"> 编写中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 获取请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">2.1.3.</span> <span class="toc-text"> Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 抛出错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.1.5.</span> <span class="toc-text"> 错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text"> 使用中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 加载方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text"> 内置中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 静态文件中间件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%BD%93%E8%A7%A3%E6%9E%90%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text"> 请求体解析中间件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text"> 调试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">4.</span> <span class="toc-text"> 路由</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-number">5.</span> <span class="toc-text"> 使用模板引擎</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text"> 数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text"> 应用程序生成器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text"> 基本方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text"> 路由方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text"> 静态服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text"> 属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">12.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bbs"><span class="toc-number">13.</span> <span class="toc-text"> BBS</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">rcocco</div><div class="author-info__description text-center">personal blog</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/rcocco">我的Github</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">179</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rcocco's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Express</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Web%E5%BC%80%E5%8F%91/">Web开发</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a target="_blank" rel="noopener" href="https://expressjs.com/en/starter/installing.html">https://expressjs.com/en/starter/installing.html</a></p>
<h1 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h1>
<p>express是NodeJS语言的HTTP服务器框架，最简单的服务器如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h1>
<p>Express是一个中间件Web框架，其自身的功能很少：Express应用程序本质上是一系列中间件函数调用。</p>
<h2 id="编写中间件"><a class="markdownIt-Anchor" href="#编写中间件"></a> 编写中间件</h2>
<p>中间件是形如<code>function(req, res)</code>，<code>function(req, res, next)</code>或<code>function(err, req, res, next)</code>的函数。也可以是在这三种形式基础上加<code>async</code>的异步函数。<br />
函数内部可以执行任何代码、修改请求和响应对象、结束请求-响应周期、调用堆栈中的下一个中间件。<br />
<code>function(req, res)</code>仅用于结束请求-响应周期的中间件。<br />
<code>function(err, req, res, next)</code>用于错误处理中间件。<br />
<code>function(req, res, next)</code>用于任何非错误处理的中间件。</p>
<p>在中间件内调用以下函数将结束请求-响应周期。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>res.download()</td>
<td>提示客户端下载文件</td>
</tr>
<tr>
<td>res.end()</td>
<td>结束响应过程</td>
</tr>
<tr>
<td>res.json()</td>
<td>发送JSON响应</td>
</tr>
<tr>
<td>res.jsonp()</td>
<td>发送具有JSONP支持的JSON响应</td>
</tr>
<tr>
<td>res.redirect()</td>
<td>重定向请求</td>
</tr>
<tr>
<td>res.render()</td>
<td>渲染视图模板</td>
</tr>
<tr>
<td>res.send()</td>
<td>发送各种类型的响应</td>
</tr>
<tr>
<td>res.sendFile()</td>
<td>将文件作为八位字节流发送。</td>
</tr>
<tr>
<td>res.sendStatus()</td>
<td>设置响应状态代码，并将其字符串表示形式发送为响应正文。</td>
</tr>
</tbody>
</table>
<ul>
<li>在任何中间件内调用<code>next()</code>将请求传递给下一个中间件。</li>
<li>在任何中间件的同步代码中抛出异常，Express会捕获并处理该错误。</li>
<li>在任何中间件内调用<code>next(err)</code>会参数作为错误对象传给Express，通常用于异步代码。</li>
<li>在app.METHOD()或router.METHOD()方法加载的中间件内调用<code>next('route')</code>，它会跳过本次调用该方法加载的所有中间件（包括错误处理中间件）。</li>
<li>在router.use()和router.METHOD()方法加载的中间件内调用<code>next('router')</code>，它会跳过router实例加载的所有中间件（包括错误处理中间件）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出日志，调用下一个中间件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myLogger</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;LOGGED&#x27;</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改请求对象，以便之后的中间件使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestTime</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  req.requestTime = <span class="built_in">Date</span>.now()</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结束请求-响应周期的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendHello</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误处理中间件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  res.status(<span class="number">400</span>).send(err.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块化的中间件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Implement the middleware function based on the options object</span></span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mw = <span class="built_in">require</span>(<span class="string">&#x27;./my-middleware.js&#x27;</span>)</span><br><span class="line">app.use(mw(&#123; <span class="attr">option1</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">option2</span>: <span class="string">&#x27;2&#x27;</span> &#125;))</span><br></pre></td></tr></table></figure>
<h3 id="获取请求头"><a class="markdownIt-Anchor" href="#获取请求头"></a> 获取请求头</h3>
<p><code>req.get(field)</code>或<code>req.header(field)</code>，如果请求头不存在则返回<code>undefined</code>。</p>
<h3 id="添加方法"><a class="markdownIt-Anchor" href="#添加方法"></a> 添加方法</h3>
<p>可以为req和res对象提供新的方法或者修改已有方法，只需要在<code>app.request</code>和<code>app.response</code>，或<code>express.request</code>和<code>express.response</code>这些原型对象上添加方法。<br />
为<code>express</code>添加将会影响所有已实例化的<code>app</code>。<br />
访问器属性，如<code>req.secure</code>和<code>req.ip</code>也可以修改，但数据属性如<code>req.baseUrl</code>和<code>req.originalUrl</code>不行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆盖原来的sendStatus</span></span><br><span class="line">app.response.sendStatus = <span class="function"><span class="keyword">function</span> (<span class="params">statusCode, type, message</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code is intentionally kept simple for demonstration purpose</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.contentType(type)</span><br><span class="line">    .status(statusCode)</span><br><span class="line">    .send(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">res.sendStatus(<span class="number">404</span>, <span class="string">&#x27;application/json&#x27;</span>, <span class="string">&#x27;&#123;&quot;error&quot;:&quot;resource not found&quot;&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// 覆盖原来的访问器属性ip</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(app.request, <span class="string">&#x27;ip&#x27;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.get(<span class="string">&#x27;Client-IP&#x27;</span>) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h3>
<p>要向客户端发送<code>Set-Cookie</code>请求头以设置Cookie，使用<code>res.cookie(name, value, [option])</code>。可以调用多次以设置多个键值对。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(<span class="string">&#x27;loginUser&#x27;</span>, <span class="string">&#x27;Alex&#x27;</span>, &#123;</span><br><span class="line">    maxAge: <span class="number">86400000</span> * <span class="number">10</span>, <span class="comment">// 要求客户端在n毫秒后自动删除cookie</span></span><br><span class="line">    httpOnly: <span class="literal">true</span>, <span class="comment">// 要求客户端不允许修改cookie</span></span><br><span class="line">    signed: <span class="literal">true</span></span><br><span class="line">  &#125;).cookie(<span class="string">&#x27;sessionID&#x27;</span>, <span class="string">&#x27;asduhasd&#x27;</span>, &#123;</span><br><span class="line">    path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>要向客户端发送请求以删除某个Cookie，使用<code>res.clearCookie(name [, options])</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.clearCookie(<span class="string">&#x27;loginUser&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>要获取客户端发送的<code>cookie</code>，使用<code>cookie-parser</code>中间件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">&quot;weqroqnscvkbeiwruq&quot;</span>;</span><br><span class="line"><span class="comment">// 传递secret以启用cookie签名，它是一个字符串</span></span><br><span class="line"><span class="comment">// 不传递将不使用签名cookie</span></span><br><span class="line">app.use(cookieParser(secret));</span><br><span class="line"><span class="comment">// 未签名的cookie在req.cookies对象里</span></span><br><span class="line"><span class="comment">// 签名的cookie在req.signedCookies对象里</span></span><br><span class="line"><span class="comment">// 属性键是cookie键，属性值是cookie指</span></span><br><span class="line">req.cookies.name</span><br><span class="line">req.signedCookies.name</span><br></pre></td></tr></table></figure>
<p>登录时post相关验证信息，<br />
服务器返回Set-Cookie:user=a@qq.com; Path=/<br />
Set-cookie: loginSession=ajiodjasodijoada<br />
用户在访问其他页面时带上<br />
Cookies: <a href="mailto:user=a@qq.com">user=a@qq.com</a>; loginSession=asjdioajdioajs</p>
<p>客户端发来cookie，你要验证cookie的正确性，就必须从服务器取出sessionid，<br />
这个sessionid要么是在内存中，要么是在文件系统，要么是在数据库文件中。</p>
<ul>
<li>增加（固定次数的） hash 次数等价于改变 hash 函数，并不会让破解更困难（除了可能会让 hash 计算更慢这方面）</li>
<li>加盐是为了让每个用户用不同的 hash 函数，从而无效化彩虹表和频率统计</li>
</ul>
<p>攻击者的目标是找到一个字符串作为密码输入系统的时候可以通过验证，譬如系统要求</p>
<p>hash1(hash2(input)) == saved_hash</p>
<p>并不是说找到了 found=hash2(password) 就可以的——目标是解方程 hash1(hash2(x)) = y，而 x=found 并不是一个解。注意：这两个 hash 都是在服务器算的，在客户端算的已经被建模为 input 了。</p>
<p>@msg7086 #50 不知道您回复的是哪一层，不过无论如何，安全的系统不怕代码泄露。</p>
<p>Session是一个抽象概念，用来识别特定用户。<br />
在实现时，可以用cookie，也可以用URL。<br />
用cookie实现时cookie存的值是sessionID，session的具体数据保存在服务器。</p>
<p>express-session是更抽象的，它支持不同的会话存储（例如文件，数据库，缓存和诸如此类）。<br />
cookie-session是一个简单/轻量级的基于cookie（cookie是唯一受支持的存储引擎：所有会话信息都存储在cookie中的客户端上）会话实现。</p>
<p>页面发一个查看登录信息请求，通过JS修改默认的右上角用户信息。</p>
<p>uid-safe用法<br />
uid(n)，会创建一个n位uid，返回的是n<em>3</em>4长度的BASE64编码值</p>
<h3 id="抛出错误"><a class="markdownIt-Anchor" href="#抛出错误"></a> 抛出错误</h3>
<p>要在中间件中触发一个错误，有两种方式：</p>
<ol>
<li>直接抛出异常：这种方法仅适用于同步代码，因为Express无法捕获到异步函数的回调中抛出的异常。</li>
<li>调用<code>next(err)</code>：将错误对象作为参数传递给<code>next</code>方法，这种方法既适用于同步代码，也适用于异步代码。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwErrorSync</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同步代码中直接throw</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;BROKEN&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抛出异常的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwError</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;/file-does-not-exist&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 异步代码抛出异常的方法是将错误传给next</span></span><br><span class="line">      next(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果异步函数的回调函数的参数是<code>(err)</code>，只有异常而没有数据，那么可以将不带参数的<code>next</code>调用和带参数的<code>next</code>调用两种情况合并，直接传递<code>next</code>函数以简化代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeFile</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    fs.writeFile(<span class="string">&#x27;/inaccessible-path&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦Express捕获到错误，则会将当前请求视为错误，并且将跳过所有剩余的非错误处理路由和中间件函数，直接将请求交给最近的错误处理中间件。</p>
<h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3>
<p>Express提供了默认的错误处理中间件，它被自动添加到所有中间件的最后，它的处理是将错误和调用栈信息发送给客户端。<br />
如果在开始发送响应后调用了带参数的<code>next()</code>（例如，如果在将响应流传输到客户端时遇到错误），则Express默认错误处理程序将关闭连接并使请求失败。<br />
因此，如果已经把将响应头发送到客户端，添加自定义错误处理程序时，必须委派给默认的Express错误处理程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (res.headersSent) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(err)</span><br><span class="line">  &#125;</span><br><span class="line">  res.status(<span class="number">500</span>)</span><br><span class="line">  res.render(<span class="string">&#x27;error&#x27;</span>, &#123; <span class="attr">error</span>: err &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你调用带参数的<code>next</code>多次，那么会触发默认错误处理程序，即便已经存在自定义的错误处理中间件。</p>
<p>错误处理中间件是接收四个参数<code>(err, req, res, next)</code>的中间件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">customErrorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">&#x27;Something broke!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误处理中间件要么结束请求-响应周期，要么继续调用<code>next(err)</code>将请求交给下一个错误处理中间件。不这么做将导致请求被挂起。<br />
错误处理中间件通常会向客户端发送4或5开头的状态码，然后发送HTML错误页面，简单消息或JSON字符串。</p>
<h2 id="使用中间件"><a class="markdownIt-Anchor" href="#使用中间件"></a> 使用中间件</h2>
<p>根据加载中间件的方法的不同，可以将中间件分为两大类：</p>
<ol>
<li>应用级中间件：通过<code>express()</code>得到的实例<code>app</code>上加载的中间件。</li>
<li>路由器级中间件：通过<code>express.Router()</code>得到的实例<code>router</code>上加载的中间件。</li>
</ol>
<p>Express还分出了三种中间件：</p>
<ol>
<li>错误处理中间件：接受四个参数<code>(err, req, res, next)</code>的中间件</li>
<li>内置中间件：用来提供静态资源的<code>express.static</code>，用来解析JSON请求的<code>express.json</code>，用来解析URL编码请求的<code>express.urlencoded</code>。</li>
<li>第三方中间件：需要通过Node.js模块安装的中间件，例如<code>cookie-parser</code>。</li>
</ol>
<h3 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h3>
<p>当服务器收到一个请求后，这个请求会依次被传入所有已加载的中间件。</p>
<ol>
<li>如果经过的中间件结束了请求-响应周期，那么就不再传递给之后的中间件。</li>
<li>如果经过的中间件没有结束请求-响应周期，但调用了<code>next()</code>函数，那么请求就会被传给下一个中间件。</li>
<li>如果经过的中间件没有结束请求-响应周期，也没有调用<code>next()</code>函数，那么请求会被挂起。</li>
</ol>
<p>由于请求会按照顺序传入所有已加载的中间件，因此中间件的加载顺序很重要。</p>
<h3 id="加载方法"><a class="markdownIt-Anchor" href="#加载方法"></a> 加载方法</h3>
<p>在通过<code>express()</code>得到的实例<code>app</code>上加载的中间件称为应用级中间件。应用级中间件使用<code>app.use()</code>或<code>app.METHOD()</code>进行加载。这些方法的参数都是一样的，<code>METHOD</code>是指小写的HTTP请求，如<code>get</code>，<code>post</code>等，还有一个特殊的<code>all</code>表示所有方法，它等价于在<code>app.use</code>加载的中间件中对请求方法作判断，仅处理该方法的请求。</p>
<p>Express加载中间件的核心方法就是<code>app.use()</code>，其他加载方法都可以以它为基础实现。<br />
以<code>app.use([path,] callback [, callback...])</code>函数为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(middleware1)</span><br><span class="line">app.use(<span class="string">&quot;/abcd&quot;</span>, middleware1)</span><br><span class="line">app.use(<span class="string">&quot;/abcd&quot;</span>, middleware1, middleware2)</span><br><span class="line">app.use(<span class="string">&quot;/abcd&quot;</span>, [middleware1, middleware2])</span><br><span class="line">app.use(middleware1, [middleware2, middleware3], middleware4)</span><br></pre></td></tr></table></figure>
<p><code>app.use</code>的第一个参数是可选的路径参数<code>path</code>，如果没有传递该参数，则它的默认值是<code>/</code>。当请求的路径以<code>path</code>开头时，就会将请求传递给此<code>path</code>对应的所有中间件方法。<br />
<code>path</code>参数可以是一个纯字符串，也可以是模式字符串，还可以是正则表达式，又或者是上述三种类型混合的数组。<br />
在模式字符串中有以下语法：</p>
<ul>
<li>点<code>.</code>和连字符<code>-</code>只有字符串含义</li>
<li>括号<code>()</code>用于分组。</li>
<li>命名参数：即正则中的命名捕获组，它的语法为冒号后跟参数名称<code>:参数名称</code>，参数名称只能是<code>[A-Za-z0-9_]</code>中的字符。
<ul>
<li>在参数名称后面加问号<code>?</code>可以使该命名参数变为可选的，例如<code>/bar/:foo?</code>匹配<code>/bar</code>和<code>/bar/abc</code></li>
<li>在参数名称后加<code>*</code>表示匹配零个或多个参数，例如<code>/bar/:foo*</code>匹配<code>/bar</code>和<code>/bar/123/456</code>（在Express 4.x版本中，由于BUG，0个或多个需要使用<code>&#123;0,&#125;</code>代替星号<code>*</code>）</li>
<li>在参数名称后加<code>+</code>表示匹配一个或多个参数。</li>
<li>命名参数默认捕获除了点、连字符和斜杠以外的所有字符，即<code>[^.-/]+</code>，要改变捕获规则，可以在命名参数后面加一个括号，括号内写正则表达式，例如<code>:id(\\d&#123;4,4&#125;)</code>。捕获的值可以在<code>req.params</code>对象中获取到。</li>
</ul>
</li>
<li>未命名参数：例如<code>/(.*)</code>，注意单独的<code>*</code>等价于<code>(.*)</code>，因此也可以写成<code>/*</code>。星号<code>*</code>匹配任意个所有字符。</li>
</ul>
<p><code>middleware</code>参数可以是一个中间件函数，也可以是多个中间件函数，还可以是中间件函数数组，又或者是上述三种的组合。</p>
<p>可以多次调用<code>app.use</code>在同一个<code>path</code>上加载中间件，它也会按调用顺序处理。</p>
<p>除了应用级中间件，还有路由级中间件，在通过<code>express.Router()</code>得到的实例<code>router</code>上加载的中间件称为路由级中间件，路由级中间件使用<code>router.use()</code>或<code>router.METHOD()</code>进行加载。<br />
<code>router</code>可以理解为一个模块，要想使用这些路由级中间件，最终要还要通过<code>app.use(path, router)</code>将其作为整体加载，当请求URL匹配<code>path</code>时，控制权将交给<code>router</code>，进而交给由<code>router</code>加载的中间件。</p>
<h2 id="内置中间件"><a class="markdownIt-Anchor" href="#内置中间件"></a> 内置中间件</h2>
<h3 id="静态文件中间件"><a class="markdownIt-Anchor" href="#静态文件中间件"></a> 静态文件中间件</h3>
<p>要提供静态文件（例如图像，CSS文件和JavaScript文件），可以使用Express中的内置中间件函数<code>express.static(root, [options])</code>。当找不到请求的文件时，它会调用<code>next()</code>将请求交给下一个中间件，因此该中间件可以放在最前面。<br />
<code>root</code>是静态资源的根目录，它不是请求URL的一部分，而是查找的起点。<br />
<code>root</code>如果是相对路径，则是相对于启动node的目录。因此最好写为绝对路径，使得不管在哪里启动node效果都是一样的。<br />
如果想让URL也匹配某个虚拟路径前缀，可以在<code>app.use</code>函数第一个参数中添加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">http://localhost:3000/images/kitten.jpg</span></span><br><span class="line"><span class="comment">public/images/kitten.jpg</span></span><br><span class="line"><span class="comment">http://localhost:3000/css/style.css</span></span><br><span class="line"><span class="comment">public/css/style.css</span></span><br><span class="line"><span class="comment">http://localhost:3000/hello.html</span></span><br><span class="line"><span class="comment">public/hello.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">app.use(<span class="string">&#x27;/static&#x27;</span>, express.static(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">http://localhost:3000/static/images/kitten.jpg</span></span><br><span class="line"><span class="comment">public/images/kitten.jpg</span></span><br><span class="line"><span class="comment">http://localhost:3000/static/css/style.css</span></span><br><span class="line"><span class="comment">public/css/style.css</span></span><br><span class="line"><span class="comment">http://localhost:3000/static/hello.html</span></span><br><span class="line"><span class="comment">public/hello.html</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以多次调用<code>static</code>方法来指定多个静态资源根目录，查找静态文件时会按顺序在这些目录下查找文件，如果找到了就不再其他根目录查找了。</p>
<h2 id="请求体解析中间件"><a class="markdownIt-Anchor" href="#请求体解析中间件"></a> 请求体解析中间件</h2>
<p><code>express.urlencoded([options])</code>将<code>content-type:application/x-www-form-urlencoded</code>的请求解析为键值对。将结果保存在<code>req.body</code>里。</p>
<h1 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h1>
<p>Express在内部使用<code>debug</code>模块输出日志，debug类似于的增强版本console.log，区别在于不必生产代码中注释掉日志。默认情况下，日志记录是关闭的，可以使用DEBUG环境变量有条件地将其打开。</p>
<h1 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h1>
<p>路由是指服务器如何响应特定（URL和METHOD）的HTTP请求。<br />
在Express中，<code>app.METHOD()</code>是最常用的用于加载路由中间件的方法。</p>
<p>处理相同请求路径的不同方法是很常见的需求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/public&quot;</span>, middleware1)</span><br><span class="line">app.post(<span class="string">&quot;/public&quot;</span>, middleware2)</span><br><span class="line">app.put(<span class="string">&quot;/public&quot;</span>, middleware3)</span><br><span class="line">app.delete(<span class="string">&quot;/public&quot;</span>, middleware4)</span><br></pre></td></tr></table></figure>
<p>为了避免重复书写请求路径，可以使用<code>app.route(path)</code>方法创建一个允许链式调用的路由，之后的路由方法不再需要传递<code>path</code>参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">&#x27;/book&#x27;</span>).get(middleware1)</span><br><span class="line">  .post(middleware2).put(middleware3)</span><br></pre></td></tr></table></figure>
<p>路由级中间件经常单独编写为一个模块文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> router = express.Router()</span><br><span class="line">router.use(middleware1)</span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, middleware2)</span><br><span class="line">router.get(<span class="string">&#x27;/about&#x27;</span>, middleware3)</span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure>
<p>使用时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> birds = <span class="built_in">require</span>(<span class="string">&#x27;./birds&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/birds&#x27;</span>, birds)</span><br></pre></td></tr></table></figure>
<p>现在当请求以<code>/birds</code>开头，就会进入路由级中间件。因此现在可以处理对<code>/birds</code>和<code>/birds/about</code>的请求。</p>
<h1 id="使用模板引擎"><a class="markdownIt-Anchor" href="#使用模板引擎"></a> 使用模板引擎</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置模板文件路径</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, <span class="string">&#x27;./views&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置模板引擎</span></span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;pug&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>自定义的模板引擎：<br />
第一个参数是扩展名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.engine(<span class="string">&#x27;myhbs&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">path, options, cb</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// path是模板文件路径</span></span><br><span class="line">  <span class="comment">// options是传给模板的数据</span></span><br><span class="line">  cb(<span class="literal">null</span>, <span class="string">&#x27;&lt;h1&gt;aisdoia&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = mysql.connect(<span class="string">&#x27;mysql://10.2.2.2:3306&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> db = sqlsite.open(<span class="string">&#x27;./website.data&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> post = <span class="keyword">await</span> db.run(<span class="string">&quot;SELECT * FROM User&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>核心方法是<code>app.use((req, res,next)=&gt;&#123;&#125;)</code>，请求和响应会按顺序经过所有<code>app.use</code>，在函数内调用<code>next()</code>将使得请求和响应继续到下一个<code>app.use</code><br />
<code>app.use((err,req,res,next)=&gt;&#123;&#125;)</code>四个参数时第一个参数为异常对象，如果出现错误将前进到最近一个具有四参数的<code>app.use</code></p>
<p><code>req</code>上是请求相关对象，请求的方法、参数、请求体类型<br />
<code>app.get('/question/:questionId')</code>，其中<code>:questionId</code>是模型匹配部分，其变量名为<code>questionId</code><br />
<code>app.use</code>第一个参数也可以是路径，它的含义是要求URL以这个参数开头，在回调函数中读取到的URL不包括第一个参数的部分。<br />
<code>app.get</code>第一个参数是路径，要求URL完全匹配这部分。</p>
<h1 id="应用程序生成器"><a class="markdownIt-Anchor" href="#应用程序生成器"></a> 应用程序生成器</h1>
<p>一次性使用：<code>npx express-generator</code><br />
多次使用：<br />
1. 安装：<code>npm install -g express-generator</code><br />
2. 使用：<code>express --view=pug myapp</code></p>
<h1 id="基本方法"><a class="markdownIt-Anchor" href="#基本方法"></a> 基本方法</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// req和res提供了简便的函数，不需要自己res.writeHead写流</span></span><br><span class="line">  res.redirect(<span class="number">302</span>, <span class="string">&#x27;/foo/bar&#x27;</span>)</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    a:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.jsonp(&#123;</span><br><span class="line">    a:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  req.is(<span class="string">&quot;html&quot;</span>)</span><br><span class="line">  req.accepts(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">  <span class="comment">// 调用next()才会进入下一个use</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 仅处理GET的中间件</span></span><br><span class="line">  <span class="keyword">if</span>(req.method == <span class="string">&#x27;GET&#x27;</span> &amp;&amp; req.url == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 等价于上面的</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line">server.listen(<span class="number">8005</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;listening on port 8005&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">8005</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;listening on port 8005&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>app.use可以调用多次，用于中间件，请求和响应会按照顺序执行所有的<code>app.use</code></p>
<p>实现app</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">app</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">use</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.push(callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middlewares = [f1, f2, f3, f4]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task = <span class="literal">null</span>;</span><br><span class="line">  next();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( task = middlewares.shift() ) &#123;</span><br><span class="line">      task(req, res, next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composeMiddlewares</span>(<span class="params">middlwares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> middlewares.reduceRight(<span class="function">(<span class="params">prev, f</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      f(req, res, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        prev(req, res)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composeMiddlewares</span>(<span class="params">middlwares</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">acc , elem</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">      elem(req, res, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        acc(req, res);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = middlewares.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    current = combine(current, middwares[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>app.use是最基本的函数，其他都是它的包装。</p>
<h1 id="路由方法"><a class="markdownIt-Anchor" href="#路由方法"></a> 路由方法</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/&quot;</span>, handlerFunction)</span><br><span class="line">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(req.header[<span class="string">&#x27;content-type&#x27;</span>] == <span class="string">&#x27;application/json&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    req.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">      body += data.toString();</span><br><span class="line">    &#125;)</span><br><span class="line">    req.on(<span class="string">&quot;end&quot;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      req.body = body;</span><br><span class="line">      next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 自带函数有一个类似上面的函数</span></span><br><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">true</span>&#125;))</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  req.body</span><br><span class="line">  req.headers</span><br><span class="line">  req.method</span><br><span class="line">  req.url</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> baseDir = path.resolve(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> targetPath = path.join(baseDir, req.url);</span><br><span class="line">  fs.open(targetPath, <span class="string">&#x27;r&#x27;</span>, <span class="function">(<span class="params">err, fd</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.code === <span class="string">&#x27;ENOENT&#x27;</span>) &#123;</span><br><span class="line">        next(); <span class="comment">// 文件不存在</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fs.createReadStream(targetPath, &#123;fd&#125;).pipe(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="静态服务器"><a class="markdownIt-Anchor" href="#静态服务器"></a> 静态服务器</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以foo作为根路径</span></span><br><span class="line">app.use(express.static(<span class="string">&quot;./foo&quot;</span>))</span><br><span class="line">app.use(express.static(<span class="string">&quot;./bar&quot;</span>))</span><br><span class="line"><span class="comment">// url路径以/static开头才能进来</span></span><br><span class="line"><span class="comment">// 不要求url路径与实际路径是相同的</span></span><br><span class="line"><span class="comment">// url路径以/static开头，后面的部分才在根路径中查找。</span></span><br><span class="line">app.use(<span class="string">&#x27;/static&#x27;</span>, express.static(<span class="string">&quot;./test&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>多个用法的意思是，对同一个文件，先在foo文件夹里找，找不到再到bar文件夹里找。</p>
<h1 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询字符串</span></span><br><span class="line">req.query</span><br><span class="line">req.query.next</span><br></pre></td></tr></table></figure>
<h1 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hbs</span>(<span class="params">tpl, data</span>) </span>&#123;</span><br><span class="line">  tpl.replace(<span class="regexp">/&#123;&#123;\s*(.+?)\s*&#125;&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data[key];</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效率低，tpl作为模板通常是不变的，一般的用法是用这个模板不断去匹配各种各样的字符串。<br />
<code>var tplFunc = Handlebars.compile(tpl);</code>得到了一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tplFunc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + data.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lodash模板</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">&lt;%= name %&gt;</span></span><br><span class="line"><span class="string">&lt;% list.forEach(item =&gt; &#123; %&gt;</span></span><br><span class="line"><span class="string">  &lt;%= item.name %&gt;</span></span><br><span class="line"><span class="string">  &lt;%= item.age %&gt;</span></span><br><span class="line"><span class="string">&lt;% &#125;) %&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<h1 id="bbs"><a class="markdownIt-Anchor" href="#bbs"></a> BBS</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(<span class="string">&#x27;loginUser&#x27;</span>, user.email, &#123;</span><br><span class="line">  maxAge: <span class="number">3</span>* <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000</span>,</span><br><span class="line">  signed:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>svgCaptcha</code>库验证码</p>
<p><code>formidable</code>解析表单（包括文件）<br />
<code>multer</code>上传文件</p>
<p>头像：上传文件有单独的接口，该接口收到文件后返回一个文件的URL。<br />
上传界面会加上一个隐藏的控件，其值为该URL。</p>
<p>上传文件，存到一个文件夹，在数据库中保存路径。</p>
<p>密码多遍MD5，<br />
md5(md5(password) + md5(salt))</p>
<p>验证码，需要知道下发的session对应哪个验证码值</p>
<p>删除时，如果用的是get接口，当一张图片的src是删除接口的地址，那么加载这个图片的用户将会删除自己的帖子。</p>
<p>防止其他页面删除自己的内容，解决方案是csrf-token，请求时有个隐藏的token，服务器收到后首先验证token，通过了才执行逻辑。<br />
另一个是cookie的same-site选项，不写就可以。</p>
<p>登录一般用用户名登录，邮箱仅用来做验证激活。</p>
<p>密码找回：<br />
<code>/forgot</code>提交找回表单，服务器收到email后，为这个email生成一个token（例如随机数）。根据token组合出一个URL，如<code>/forgot/123198239127</code>。此页面的逻辑就是修改特定用户的密码，任何人进入这个页面都可以修改该用户的密码。<br />
token和email的对应关系应该保存起来。并且设置一个定时器，到一定时间就删除这个对应关系，让修改密码页面失效。<br />
如果对应关系存在，就在访问<code>/forgot/123198239127</code>页面时修改对应用户的密码。</p>
<p>GET请求不应该处理有副作用的请求。（例如删除）<br />
GET 获取资源</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rcocco@qq.com">rcocco</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rcocco.github.io/categories/计算机/Web开发/Express.html">https://rcocco.github.io/categories/计算机/Web开发/Express.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rcocco.github.io">rcocco's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/BOM%E6%A6%82%E8%BF%B0.html"><i class="fa fa-chevron-left">  </i><span>BOM概述</span></a></div><div class="next-post pull-right"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Web%E5%BC%80%E5%8F%91/Koa.html"><span>Koa</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a2cb0efab90aafe77d70',
  clientSecret: '4ab6a1536933e9a284900f708bef988ffb8c152f',
  repo: 'gitalk_comments',
  owner: 'rcocco',
  admin: 'rcocco',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By rcocco</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>